\documentclass[a4paper, 12pt]{article}

% packages
\usepackage{amssymb}
\usepackage[fleqn]{mathtools}
\usepackage{tikz}
\usepackage{enumerate}
\usepackage{bussproofs}
\usepackage{xcolor}
\usepackage[margin=1.3cm]{geometry}
\usepackage{logicproof}
\usepackage{diagbox}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{lstautogobble}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{tipa}
\usepackage{pgfplots}

% tikz libraries
\usetikzlibrary{
    decorations.pathreplacing,
    arrows,
    shapes.gates.logic.US,
    circuits.logic.US,
    calc,
    automata,
    positioning,
    intersections
}

\pgfplotsset{compat=1.16}

\pgfmathdeclarefunction{gauss}{2}{%
  \pgfmathparse{1/(#2*sqrt(2*pi))*exp(-((x-#1)^2)/(2*#2^2))}%
}

\allowdisplaybreaks % allow environments to break
\setlength\parindent{0pt} % no indent

% shorthand for verbatim
% this clashes with logicproof, so maybe fix this at some point?
\catcode`~=\active
\def~#1~{\texttt{#1}}

% code listing
\lstdefinestyle{main}{
    numberstyle=\tiny,
    breaklines=true,
    showspaces=false,
    showstringspaces=false,
    tabsize=2,
    numbers=left,
    basicstyle=\ttfamily,
    columns=fixed,
    fontadjust=true,
    basewidth=0.5em,
    autogobble,
    xleftmargin=3.0ex,
    mathescape=true
}
\newcommand{\dollar}{\mbox{\textdollar}} %
\lstset{style=main}

% augmented matrix
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
\hskip -\arraycolsep
\let\@ifnextchar\new@ifnextchar
\array{#1}}
\makeatother

% ceiling / floor
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

% custom commands
\newcommand{\indefint}[2]{\int #1 \, \mathrm{d}#2}
\newcommand{\defint}[4]{\int_{#1}^{#2} #3 \, \mathrm{d}#4}
\newcommand{\pdif}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\dif}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}}
\newcommand{\limit}[2]{\raisebox{0.5ex}{\scalebox{0.8}{$\displaystyle{\lim_{#1 \to #2}}$}}}
\newcommand{\summation}[2]{\sum\limits_{#1}^{#2}}
\newcommand{\product}[2]{\prod\limits_{#1}^{#2}}
\newcommand{\intbracket}[3]{\left[#3\right]_{#1}^{#2}}
\newcommand{\laplace}{\mathcal{L}}
\newcommand{\fourier}{\mathcal{F}}
\newcommand{\mat}[1]{\boldsymbol{#1}}
\renewcommand{\vec}[1]{\boldsymbol{#1}}
\newcommand{\rowt}[1]{\begin{bmatrix}
    #1
\end{bmatrix}^\top}
\DeclareMathOperator*{\argmax}{argmax}
\DeclareMathOperator*{\argmin}{argmin}

\newcommand{\ulsmash}[1]{\underline{\smash{#1}}}

\newcommand{\powerset}[0]{\wp}
\renewcommand{\emptyset}[0]{\varnothing}

\makeatletter
\newsavebox{\@brx}
\newcommand{\llangle}[1][]{\savebox{\@brx}{\(\m@th{#1\langle}\)}%
  \mathopen{\copy\@brx\kern-0.5\wd\@brx\usebox{\@brx}}}
\newcommand{\rrangle}[1][]{\savebox{\@brx}{\(\m@th{#1\rangle}\)}%
  \mathclose{\copy\@brx\kern-0.5\wd\@brx\usebox{\@brx}}}
\makeatother
\newcommand{\lla}{\llangle}
\newcommand{\rra}{\rrangle}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\crnr}[1]{\text{\textopencorner} #1 \text{\textcorner}}
\newcommand{\bnfsep}[0]{\ |\ }
\newcommand{\concsep}[0]{\ ||\ }

\newcommand{\axiom}[1]{\AxiomC{#1}}
\newcommand{\unary}[1]{\UnaryInfC{#1}}
\newcommand{\binary}[1]{\BinaryInfC{#1}}
\newcommand{\trinary}[1]{\TrinaryInfC{#1}}
\newcommand{\quaternary}[1]{\QuaternaryInfC{#1}}
\newcommand{\quinary}[1]{\QuinaryInfC{#1}}
\newcommand{\dproof}[0]{\DisplayProof}

\newcommand{\ttbs}{\char`\\}
\newcommand{\lrbt}[0]{\ \bullet\ }

% colours
\newcommand{\violet}[1]{\textcolor{violet}{#1}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\teal}[1]{\textcolor{teal}{#1}}

% reasoning proofs
\usepackage{ltablex}
\usepackage{environ}
\keepXColumns
\NewEnviron{reasoning}{
    \begin{tabularx}{\textwidth}{rlX}
        \BODY
    \end{tabularx}
}
\newcommand{\proofline}[3]{$(#1)$ & $#2$ & \hfill #3 \smallskip \\}
\newcommand{\proofarbitrary}[1]{& take arbitrary $#1$ \smallskip \\}
\newcommand{\prooftext}[1]{\multicolumn{3}{l}{#1} \smallskip \\}
\newcommand{\proofmath}[3]{$#1$ & = $#2$ & \hfill #3 \smallskip \\}
\newcommand{\prooftherefore}[1]{& $\therefore #1$ \smallskip \\}
\newcommand{\proofbc}[0]{\prooftext{\textbf{Base Case}}}
\newcommand{\proofis}[0]{\prooftext{\textbf{Inductive Step}}}

% ER diagrams
\newcommand{\nattribute}[4]{
    \node[draw, state, inner sep=0cm, minimum size=0.2cm, label=#3:{#4}] (#1) at (#2) {};
}
\newcommand{\mattribute}[4]{
    \node[draw, state, accepting, inner sep=0cm, minimum size=0.2cm, label=#3:{#4}] (#1) at (#2) {};
}
\newcommand{\dattribute}[4]{
    \node[draw, state, dashed, inner sep=0cm, minimum size=0.2cm, label=#3:{#4}] (#1) at (#2) {};
}
\newcommand{\entity}[3]{
    \node[] (#1-c) at (#2) {#3};
    \node[inner sep=0cm] (#1-l) at ($(#1-c) + (-1, 0)$) {};
    \node[inner sep=0cm] (#1-r) at ($(#1-c) + (1, 0)$) {};
    \node[inner sep=0cm] (#1-u) at ($(#1-c) + (0, 0.5)$) {};
    \node[inner sep=0cm] (#1-d) at ($(#1-c) + (0, -0.5)$) {};
    \draw
    ($(#1-c) + (-1, 0.5)$) -- ($(#1-c) + (1, 0.5)$) -- ($(#1-c) + (1, -0.5)$) -- ($(#1-c) + (-1, -0.5)$) -- cycle;
}
\newcommand{\relationship}[3]{
    \node[] (#1-c) at (#2) {#3};
    \node[inner sep=0cm] (#1-l) at ($(#1-c) + (-1, 0)$) {};
    \node[inner sep=0cm] (#1-r) at ($(#1-c) + (1, 0)$) {};
    \node[inner sep=0cm] (#1-u) at ($(#1-c) + (0, 1)$) {};
    \node[inner sep=0cm] (#1-d) at ($(#1-c) + (0, -1)$) {};
    \draw
    ($(#1-c) + (-1, 0)$) -- ($(#1-c) + (0, 1)$) -- ($(#1-c) + (1, 0)$) -- ($(#1-c) + (0, -1)$) -- cycle;
}

% actual document
\begin{document}
    \section*{CO212 - Networks and Communications}
        \subsection*{14th January 2020 \hfill Week 1, Lecture 1}
            \subsubsection*{Evolution of the Internet}
                Literally only writing this part so I have something for the first lecture.
                \begin{itemize}
                    \itemsep0em
                    \item (1969 - October) first message sent on ARPANET; "login", crashed after "l" and "o" were sent
                    \item (1971) universities in West and East coast of USA connected
                    \item (1980) London connected
                \end{itemize}
        \subsection*{14th January 2020 \hfill Week 2, Lecture 1}
            \subsubsection*{World Wide Web (WWW)}
                This is an example of an \textbf{application} on the internet, based on HTTP (HyperText Transfer Protocol).
                A web browser (the client) sends a \violet{request} to the web server over a pipe, which can be any form of connection between the two devices (can also be the same device), which in turn sends back a \teal{response}.
                \begin{center}
                    \begin{tikzpicture}
                        \node at (6, 1) {\shortstack{~GET /pixel.gif HTTP/1.1~\\~Host: www.example.com~\\~...~}};
                        \node at (6, -3) {\shortstack{~HTTP/1.1 200 OK~\\~...~\\~[binary data]~\\~...~}};
                        \node at (1, -1) {\shortstack{web\\browser}};
                        \node at (11, -1) {\shortstack{web\\server}};
                        \draw (0, 0) -- (2, 0) -- (2, -2) -- (0, -2) -- cycle;
                        \draw (10, 0) -- (12, 0) -- (12, -2) -- (10, -2) -- cycle;
                        \draw[violet] (2, -0.5) edge[->, bend left=10] (10, -0.5);
                        \draw[teal] (10, -1.5) edge[->, bend left=10] (2, -1.5);
                    \end{tikzpicture}
                \end{center}
            \subsubsection*{Layers}
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{application layer}
                        \medskip

                        Any software written for the internet is on the application layer.
                    \item \textbf{transport layer}
                        \medskip

                        In the \textbf{transport layer}, packets leave your (client) machine to the server, and the server sends back packets to your client.
                        This layer divides a (big) message into smaller chunks, and sends them to the other side (re-ordered) to be presented to the recipient.
                    \item \textbf{network layer}
                        \medskip

                        The \textbf{route / path} (sequences of switches a packet goes through) each packet takes can be different from the others, and is often the most optimal route available.
                        This is done on the \textbf{network layer}, which routers are a part of.
                        \begin{center}
                            \begin{tikzpicture}
                                \node at (1, -1) {\shortstack{web\\browser}};
                                \node at (11, -1) {\shortstack{web\\server}};
                                \draw (0, 0) -- (2, 0) -- (2, -2) -- (0, -2) -- cycle;
                                \draw (10, 0) -- (12, 0) -- (12, -2) -- (10, -2) -- cycle;
                                \node[state, minimum size=1cm] (0) at (4, 1) {};
                                \node[state, minimum size=1cm] (1) at (5, -1) {};
                                \node[state, minimum size=1cm] (2) at (6, -3) {};
                                \node[state, minimum size=1cm] (3) at (7, 0) {};
                                \node[state, minimum size=1cm] (4) at (8, -2) {};
                                \node[state, minimum size=1cm] (5) at (8, 1) {};
                                \draw[violet] (2, -1) -- (0) -- (3) -- (2) -- (4) -- (10, -1);
                                \draw
                                (0) -- (1)
                                (0) -- (5)
                                (1) -- (3)
                                (1) -- (4)
                                (4) -- (5);
                            \end{tikzpicture}
                        \end{center}
                    \item \textbf{data link layer}
                        \medskip

                        Our devices are linked to the network on the \textbf{data link layer}, via network interface controllers (NICs).
                        Examples of this include Ethernet, fiber optic network cards, as well as wireless devices such as WiFi access points, and USB dongles for 4G.
                        A communication link is any connection between packet switches and / or end systems.
                    \item \textbf{physical layer}
                        \medskip

                        Finally, on the \textbf{physical layer}, there are various forms of communication media, including fiber-optic cables, twisted-pair copper wire, coaxial cables, and wireless local-area links (802.11, Bluetooth, etc).
                \end{itemize}
        \subsection*{16th January 2020 \hfill Week 2, Lecture 2}
            \subsubsection*{Circuit Switching}
                Old phones used circuit switching, which creates a connection between the two points, which is used for the entire communication.
                This isn't used for the internet as the failure of one node in the circuit would lead the the entire communication dropping - whereas a different route would be calculated in packet switching.
                \medskip

                Compared to packet switching, it has an expensive setup phase, but will need very little processing once the connection is established.
                However, it is inefficient for sharing resources - if a node is used as part of a circuit, it cannot be used by another connection for a different circuit.
                The resources are blocked once a connection is established (hence it is an inefficient way to use the network).
                On the other hand, packet switching has no setup cost, but has a processing cost, as well as space overhead, for every packet.
                It has a processing cost for forwarding the packets, as well as space overhead as there must be redundant data for each packet, such that it is self contained.
                It is specifically designed to share links, hence it allows for a better utilisation of network resources.
            \subsubsection*{Protocols}
                A protocol is a set of rules (an agreement between communicating parties on how communication is to proceed), run by end systems as well as packet switches.
                It must be unambiguous, complete (includes actions and / or responses for all possible situations), and also define all necessary message formats.
                The phases are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{handshake} \hfill establishes identities and / or context
                    \item \textbf{conversation} \hfill free-form exchange
                    \item \textbf{closing} \hfill terminating the conversation
                \end{itemize}
                The internet protocol stack is based on the 5 layers briefly covered in the previous lecture.
                Some examples of design issues that can be encountered are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{addressing} \hfill how to denote the intended recipient
                    \item \textbf{error control} \hfill how to detect (and possibly fix) transmission errors, e.g. checksums
                    \item \textbf{flow control} \hfill ensure data travels through communication media without issues
                    \item \textbf{multiplexing / demultiplexing} \hfill conversion of data into binary, and parallel communications
                    \item \textbf{routing} \hfill which route is chosen
                \end{itemize}
                Most network layers are either connection-oriented, where a connection is first established, data is exchanged, and the connection is finally released, or connectionless, where data is marked with its destination.
                \medskip

                The TCP/IP (4 layer) stack consists of application, transport, internet, and network access (which combines data link and physical).
                On the other hand, the OSI (7 layer) model consists of the application layer, presentation, session, transport, network, data link, and physical.
                \begin{center}
                    \hfill
                    \begin{tabular}{|c|}
                        \hline
                        \violet{application} \\
                        \hline
                        \violet{presentation} \\
                        \hline
                        \violet{session} \\
                        \hline
                        \blue{transport} \\
                        \hline
                        \red{network} \\
                        \hline
                        \teal{data link} \\
                        \hline
                        \teal{physical} \\
                        \hline
                    \end{tabular}
                    \hfill
                    \begin{tabular}{|c|}
                        \hline
                        \violet{application} \\
                        \hline
                        \blue{transport} \\
                        \hline
                        \red{network / internet} \\
                        \hline
                        \teal{data link} \\
                        \hline
                        \teal{physical} \\
                        \hline
                    \end{tabular}
                    \hfill
                    \begin{tabular}{|c|}
                        \hline
                        \violet{application} \\
                        \hline
                        \blue{transport} \\
                        \hline
                        \red{internet} \\
                        \hline
                        \teal{network access} \\
                        \hline
                    \end{tabular}
                    \hfill \phantom{}
                \end{center}
                A \textbf{service} is a set of primitives that a layer provides to the layer above it, whereas a \textbf{protocol} is a set of rules that prescribe the layout and meaning of packets.
                In a protocol stack, layer $k$ puts its entire packet as data into a layer $k - 1$ packet, the latter may add a header and / or a trailer.
                This may have to be split across several lower level packets (\textbf{fragmentation}).
                An example of protocol layering is as follows;
                \begin{center}
                    \begin{tikzpicture}[x=0.75cm, y=0.75cm]
                        \begin{scope}[shift={(0, 0)}]
                            \node at (1, 0.5) {source machine};
                            \node at (1, -0.5) {$M$};
                            \node at (0, -2.5) {\teal{$H_4$}};
                            \node at (1.5, -2.5) {\violet{$M$}};
                            \node at (-3, -4.5) {\teal{$H_3$}};
                            \node at (-2, -4.5) {\violet{$H_4$}};
                            \node at (-1, -4.5) {\violet{$M_1$}};
                            \node at (3, -4.5) {\teal{$H_3$}};
                            \node at (4.5, -4.5) {\violet{$M_2$}};
                            \node at (-4, -6.5) {\teal{$H_2$}};
                            \node at (-3, -6.5) {\violet{$H_3$}};
                            \node at (-2, -6.5) {\violet{$H_4$}};
                            \node at (-1, -6.5) {\violet{$M_1$}};
                            \node at (0, -6.5) {\teal{$T_2$}};
                            \node at (2, -6.5) {\teal{$H_2$}};
                            \node at (3, -6.5) {\violet{$H_3$}};
                            \node at (4.5, -6.5) {\violet{$M_2$}};
                            \node at (6, -6.5) {\teal{$T_2$}};
                            \draw (0, 0) -- (2, 0) -- (2, -1) -- (0, -1) -- cycle;
                            \draw[teal] (-0.5, -2) -- (2.5, -2) -- (2.5, -3) -- (-0.5, -3) -- cycle
                            (0.5, -2) -- (0.5, -3);
                            \draw[teal] (-3.5, -4) -- (-0.5, -4) -- (-0.5, -5) -- (-3.5, -5) -- cycle
                            (-2.5, -4) -- (-2.5, -5)
                            (-1.5, -4) -- (-1.5, -5);
                            \draw[teal] (2.5, -4) -- (5.5, -4) -- (5.5, -5) -- (2.5, -5) -- cycle
                            (3.5, -4) -- (3.5, -5);
                            \draw[teal] (-4.5, -6) -- (0.5, -6) -- (0.5, -7) -- (-4.5, -7) -- cycle
                            (-3.5, -6) -- (-3.5, -7)
                            (-2.5, -6) -- (-2.5, -7)
                            (-1.5, -6) -- (-1.5, -7)
                            (-0.5, -6) -- (-0.5, -7);
                            \draw[teal] (1.5, -6) -- (6.5, -6) -- (6.5, -7) -- (1.5, -7) -- cycle
                            (2.5, -6) -- (2.5, -7)
                            (3.5, -6) -- (3.5, -7)
                            (5.5, -6) -- (5.5, -7);
                            \draw
                            (1, -1) edge[->] (1, -2)
                            (1, -3) edge[->] (-2, -4)
                            (1, -3) edge[->] (4, -4)
                            (-2, -5) edge[->] (-2, -6)
                            (4, -5) edge[->] (4, -6);
                        \end{scope}
                        \draw[dashed]
                        (2, -0.5) edge[<->, above] node{\tiny\shortstack{layer 5\\protocol}} (13, -0.5)
                        (2.5, -2.5) edge[<->, above] node{\tiny\shortstack{layer 4\\protocol}} (12.5, -2.5)
                        (5.5, -4.5) edge[<->, above] node{\tiny\shortstack{layer 3\\protocol}} (9.5, -4.5)
                        (6.5, -6.5) edge[<->, above] node{\tiny\shortstack{layer 2\\protocol}} (8.5, -6.5);
                        \draw
                        (1, -7) -- (1, -8) -- (14, -8) edge[->] (14, -7);
                        \begin{scope}[shift={(13, 0)}]
                            \node at (1, 0.5) {destination machine};
                            \node at (1, -0.5) {$M$};
                            \node at (0, -2.5) {$H_4$};
                            \node at (1.5, -2.5) {$M$};
                            \node at (-3, -4.5) {$H_3$};
                            \node at (-2, -4.5) {$H_4$};
                            \node at (-1, -4.5) {$M_1$};
                            \node at (3, -4.5) {$H_3$};
                            \node at (4.5, -4.5) {$M_2$};
                            \node at (-4, -6.5) {$H_2$};
                            \node at (-3, -6.5) {$H_3$};
                            \node at (-2, -6.5) {$H_4$};
                            \node at (-1, -6.5) {$M_1$};
                            \node at (0, -6.5) {$T_2$};
                            \node at (2, -6.5) {$H_2$};
                            \node at (3, -6.5) {$H_3$};
                            \node at (4.5, -6.5) {$M_2$};
                            \node at (6, -6.5) {$T_2$};
                            \draw (0, 0) -- (2, 0) -- (2, -1) -- (0, -1) -- cycle;
                            \draw (-0.5, -2) -- (2.5, -2) -- (2.5, -3) -- (-0.5, -3) -- cycle
                            (0.5, -2) -- (0.5, -3);
                            \draw (-3.5, -4) -- (-0.5, -4) -- (-0.5, -5) -- (-3.5, -5) -- cycle
                            (-2.5, -4) -- (-2.5, -5)
                            (-1.5, -4) -- (-1.5, -5);
                            \draw (2.5, -4) -- (5.5, -4) -- (5.5, -5) -- (2.5, -5) -- cycle
                            (3.5, -4) -- (3.5, -5);
                            \draw (-4.5, -6) -- (0.5, -6) -- (0.5, -7) -- (-4.5, -7) -- cycle
                            (-3.5, -6) -- (-3.5, -7)
                            (-2.5, -6) -- (-2.5, -7)
                            (-1.5, -6) -- (-1.5, -7)
                            (-0.5, -6) -- (-0.5, -7);
                            \draw (1.5, -6) -- (6.5, -6) -- (6.5, -7) -- (1.5, -7) -- cycle
                            (2.5, -6) -- (2.5, -7)
                            (3.5, -6) -- (3.5, -7)
                            (5.5, -6) -- (5.5, -7);
                            \draw
                            (1, -1) edge[<-] (1, -2)
                            (1, -3) edge[<-] (-2, -4)
                            (1, -3) edge[<-] (4, -4)
                            (-2, -5) edge[<-] (-2, -6)
                            (4, -5) edge[<-] (4, -6);
                        \end{scope}
                    \end{tikzpicture}
                \end{center}
                Note that the connection between the two machines can have multiple nodes in between, that can read up to a different physical layer.
                For example, if there was a link-layer switch after the source machine, it can read up to the link layer (layer 2), remove and add headers / trailers, and then send it on to the next device.
                The next device may be a router for example, which can read up to the network layer (layer 3), and do the same.
                \medskip

                The data from the layer above is known as the \violet{SDU (service data unit)}, and the SDU combined with a header, added by the current layer, is known as the \teal{PDU (protocol data unit)}.
        \subsection*{16th January 2020 \hfill Week 2, Lecture 3}
            \subsubsection*{Protocol Layers}
                The types of protocols on each layer are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{application layer}
                        \medskip

                        Protocols on the application layer defines functionality and message formats.
                        Some examples are as follows;
                        \begin{itemize}
                            \itemsep0em
                            \item \textbf{traditional} \hfill name services (DNS), sending email (SMTP), file transfer (FTP), web (HTTP(S))
                            \item \textbf{modern}
                                \subitem includes middleware protocols to support distributed systems with special protocols to handle replication, fault tolerance, caching, etc.
                            \item \textbf{high-level} \hfill special application-level protocols for e-commerce, banking etc.
                            \item \textbf{peer-to-peer} \hfill BitTorrent, old-Skype (awful API)
                        \end{itemize}
                    \item \textbf{transport layer}
                        \medskip

                        These protocols generally offer connection-oriented (TCP) as well as connectionless (UDP) services, which have varying degrees of reliability.
                        These often provide a network interface to application via sockets.
                        It's also important to note there is a difference between reliability and security; the former guarantees that the data is sent, whereas the latter ensures that it is encrypted in some form.
                        This layer also provides flow control; mechanisms to ensure fast senders don't overwhelm slow receivers.
                    \item \textbf{network layer}
                        \medskip

                        In this layer, the protocols generally describe how routing is performed, such as determining which computers / routers are in the network, the best route between two points, how to handle faults (such as a device going down), as well as handling congestion (when a router is overloaded and packets are dropped).
                    \item \textbf{data link layer}
                        \medskip

                        In this layer, we need to detect bit transmission errors.
                        This can be done by adding redundancy bits in frames to detect errors - for example adding a parity bit to every 7 bits, where a 1 indicates an odd number of 1s, and a 0 indicates an even number of 1s, or adding a checksum (cyclic redundancy check) which should match the bits before it.
                        \medskip

                        It also specifies how many computers can share a common channel, with the medium access control sub-layer (MAC).
                        A well known protocol is the Ethernet protocol.
                    \item \textbf{physical layer}
                        \medskip

                        This describes the transmission of raw bits, in terms of the physical mechanical and electrical issues.
                        For example, when two computers are connected with a wire, -3V may indicate to a binary 1, and +4V may correspond to a binary 0.
                        It may also specify the number of times the voltage can be changed per second.
                        \medskip

                        For example if the voltage can be changed 20,000 times per second, it indicates that the maximum transfer rate is 20,000 bits per second, which is 20 Kbps (20 kilobits per second).
                \end{itemize}
            \subsubsection*{Units}
                \begin{itemize}
                    \itemsep0em
                    \item 1 Byte = 8 bits \hfill note that a byte has an uppercase B, whereas a bit has lowercase b
                    \item 1000 Bytes = 1 KB \hfill (Kilobyte)
                    \item 1024 Bytes = 1 KiB \hfill (Kibibyte)
                \end{itemize}
                Typically we use powers of 10 for networks, but as long as we are consistent in what we use it is fine.
            \subsubsection*{Quantifying Data Transfer}
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{bandwidth}
                        \subitem the amount of information that \textbf{can} get into the connection in a time unit
                    \item \textbf{throughput}
                        \subitem the amount of information that \textbf{actually} get into the connection in a time unit - at steady-state, we assume zero accumulation of traffic therefore the input and output throughputs are equal
                    \item \textbf{latency}
                        \subitem the time it takes for one bit to go through the connection
                \end{itemize}
                Note that for the following formula, we use these values;
                \begin{itemize}
                    \itemsep0em
                    \item $t_0$ \hfill the time the first packet leaves the source
                    \item $t_1$ \hfill the time the first packet reaches the destination
                    \item $t_2$ \hfill the time all the packets reach the destination
                    \item $L$ \hfill the size of the packet in bits
                    \item latency (propagation delay) \hfill $d = t_1 - t_0$ (generally $\frac{\text{distance}}{\text{wave propagation speed}}$)
                        \subitem note that this is half the RTT (round-trip time)
                    \item throughput (link bandwidth) \hfill $R = \frac{L}{t_2 - t_1}$ (generally $\frac{\text{transferred bits}}{\text{duration}}$)
                    \item packetization (transmission delay / store-and-forward delay) \hfill $\frac{L}{R}$
                        \subitem time it takes for the entire packet to be received after the first bit is received
                    \item transfer time (propagation delay + transmission delay) \hfill $\Delta = d + \frac{L}{R}$
                \end{itemize}
                However, it's important to note that the connections are (almost) never direct, and therefore will have additional delays at each router.
                Note that our bandwidth is also bottlenecked by the lowest bandwidth.
                \begin{center}
                    \begin{tikzpicture}
                        \node at (1, -1) {\shortstack{source\\host}};
                        \node at (6, 0.5) {$d_x$};
                        \node at (6, -1) {router};
                        \node at (11, -1) {\shortstack{destination\\host}};
                        \draw (0, 0) -- (2, 0) -- (2, -2) -- (0, -2) -- cycle;
                        \draw (5, 0) -- (7, 0) -- (7, -2) -- (5, -2) -- cycle;
                        \draw (10, 0) -- (12, 0) -- (12, -2) -- (10, -2) -- cycle;
                        \draw
                        (2, -1) edge[->, above] node{$d_1, R_1$} (5, -1)
                        (7, -1) edge[->, above] node{$d_2, R_2$} (10, -1);
                    \end{tikzpicture}
                \end{center}
                \begin{align*}
                    d_\text{end-end} & = \begin{cases}
                        d_1 + \frac{L}{R_1} + d_x + d_2 & R_1 < R_2 \\
                        d_1 + d_x + \frac{L}{R_2} + d_2 & R_1 \geq R_2
                    \end{cases} \\
                    & = d_1 + d_x + d_2 + \frac{L}{\min (R_1, R_2)}
                \end{align*}
                The router delay, $d_x$ has two components; the processing delay $d_\text{proc}$ which is the processing time (checking for bit errors and determining the output link), as well as $d_q$, which is the queueing delay - the time waiting at the output link for transmission, which depends on how congested the router is.
                We can quantify the \textbf{traffic intensity} as follows;
                \begin{align*}
                    R & = \text{link bandwidth} \\
                    L & = \text{packet length (bits)} \\
                    a & = \text{average packet arrival rate} \\
                    \frac{La}{R} & = \text{traffic intensity} \\
                    \frac{La}{R} & \approx 0 & \text{small average queueing delay} \\
                    \frac{La}{R} & \to 1 & \text{large average queueing delay} \\
                    \frac{La}{R} & > 1 & \text{more working arriving than can be serviced, infinite delay}
                \end{align*}
        \subsection*{21st January 2020 \hfill Week 3, Lecture 1}
            \subsubsection*{Clients and Servers}
                We can distinguish between the two roles in a pair of communicating processes, in a connection-oriented model;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{client} \hfill initiates communication
                    \item \textbf{server} \hfill waits to be contacted
                \end{itemize}
                On the other hand, some applications have processes that act as both the client and the server, which is referred to P2P (or peer-to-peer) architecture.
            \subsubsection*{End System Applications}
                Internet applications are processes on the end systems.
                They must have a way of addressing each other, either via the internet (such as chat servers), or they can directly communicate (such as FTP) - but this depends on the protocol in use.
                Note that a single end system (or host) can run multiple programs, which run multiple processes, all of which connect through a network API provided by the operating system.
                Each process is addressed within its host by a \textbf{port number}.
                When an application wants to communicate with another application, the OS opens a socket, which allows data to be transferred between the two machines.
                \begin{center}
                    \begin{minipage}[t]{0.485\textwidth}
                        client application
                        \begin{enumerate}[1.]
                            \itemsep0em
                            \item create a socket $C$ by connecting to server application (connecting to host $H$ on port $P$)
                            \item read and write data to socket $C$
                            \item disconnect and destroy $C$
                        \end{enumerate}
                    \end{minipage}
                    \hfill
                    \begin{minipage}[t]{0.485\textwidth}
                        server application (on host $H$)
                        \begin{enumerate}[1.]
                            \itemsep0em
                            \item create a socket $S$ by accepting connection on part $P$ (port is often called a server socket)
                            \item read and write data to socket $S$
                            \item disconnect and destroy $S$
                        \end{enumerate}
                    \end{minipage}
                \end{center}
                The server application can open more sockets to server multiple clients at a time.
                A DDoS (distributed denial of service) attack works by opening many sockets, preventing the server from serving legitimate requests.
            \subsubsection*{The World Wide Web}
                Invented in 1989 (formally defined in 1991) by Sir Tim Berners-Lee.
                Based on the idea of hypertext and hyperlinks (based on a proposal by William Tunnicliffe in late 1960s).
                Commonly used terminology is as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{document} \hfill a webpage is called a document
                    \item \textbf{object} \hfill any called within a document (images, stylesheets, etc.)
                    \item \textbf{Uniform Resource Locator (URL)} \hfill specifies the address of an object
                    \item \textbf{browser} \hfill also called user agent - client used to access documents
                    \item \textbf{web server} \hfill application that makes documents and objects available through HTTP
                \end{itemize}
            \subsubsection*{Protocol}
                In general, the request and reply would include the following;
                \begin{center}
                    \begin{minipage}[t]{0.485\textwidth}
                        request
                        \begin{itemize}
                            \itemsep0em
                            \item protocol version
                            \item URL specification
                            \item connection attributes
                            \item content / feature negotiation
                        \end{itemize}
                    \end{minipage}
                    \hfill
                    \begin{minipage}[t]{0.485\textwidth}
                        reply
                        \begin{itemize}
                            \itemsep0em
                            \item protocol version
                            \item reply status / value
                            \item connection attributes
                            \item object attributes
                            \item content specification
                            \item content
                        \end{itemize}
                    \end{minipage}
                \end{center}
                A protocol should always include a version number, as it allows the protocol design to change.
                HTTP/2 will replace HTTP/1.x in the next few years (hopefully), as the former is able to fully multiplex a connection since all content is binary, and can use a single TCP connection for parallelism.
                \medskip

                The URL contains the host name, which determines where the requests goes, by mapping to a network address.
                The request consists of a request line, such as ~GET /path/to/index.html HTTP/1.1~, zero or more header lines, an empty line, followed by the object body (which can be empty).
                The request line contains a method, such as;
                \begin{itemize}
                    \itemsep0em
                    \item ~GET~ \hfill retrieve the object identified by the URL
                    \item ~POST~ \hfill allows for submission of data to the server
                    \item ~HEAD~ \hfill similar to ~GET~ but only receives headers
                    \item ~PUT~ \hfill requests the enclosed object to be stored under the given URL
                    \item ~DELETE~ \hfill deletes the given object
                    \item ~OPTIONS~ \hfill requests the available communication options for the given object
                \end{itemize}
                The status code in a server response is generally as follows;
                \begin{itemize}
                    \itemsep0em
                    \item ~1xx~ \hfill informational
                    \item ~2xx~ \hfill successful
                    \item ~3xx~ \hfill redirection (e.g. object has temporarily or permanently moved)
                    \item ~4xx~ \hfill client error (e.g. malformed request, unauthorised, object not found, method not allowed)
                    \item ~5xx~ \hfill server error (e.g. internal server error, service overloaded)
                \end{itemize}
        \subsection*{23rd January 2020 \hfill Week 3, Lecture 2}
            \subsubsection*{How HTTP uses TCP}
                HTTP uses TCP as it is essentially a file transfer protocol, which needs to be connection-oriented.
                The first version of HTTP uses a TCP connection for each object, which was an inefficient use of both the network and the operating system.
                HTTP/1.1 introduced persistent connection, which allows for an existing connection to be used to issue multiple requests (either sending a request, waiting for a response, sending the next request and so on, or through pipelining) - which will eventually close with a timeout.
                Pipelining allows the client to send all its requests without waiting for a response, and the server delivers them in response.
            \subsubsection*{Web Caching}
                A proxy is a server which acts as an intermediate between the client and the destination server.
                This can be used for caching by storing a copy of the content, which reduces load on the origin server, and also allows for lower latency.
                Data isn't cached for an extended period of time as it can lead to stale data (where old content is served to a user, even after the content is changed on the origin server).
                Proxies can also protect the clients by providing anonymity, as well blocking malicious content through the use of a single firewall on the proxy.
                However, this also acts as a single point of failure - if the proxy fails then the clients may not be able to connect.
                \medskip

                A ~HEAD~ request could be used to see if an object has been updated, which is less expensive than retrieving the entire object with a ~GET~ request.
                The request can also include ~Cache-Control: no-cache~, which indicates it does not want cached objects, thus requiring proxies to go to the origin server, or ~Cache-Control: max-age=20~, which only gets a cached object if the cache is less than 20 seconds old.
                \medskip

                On the other hand, the reply can also include ~Cache-Control: no-cache~, which informs the proxy not to cache the object, or ~Cache-Control: maxage=100; must-revalidate~, which specifies to the proxy that it must revalidate the object after 100 seconds.
            \subsubsection*{Sessions}
                Note that HTTP is a \textbf{stateless} protocol, which means that responses have no memory of past requests.
                However, HTTP allows higher-level applications to maintain \textbf{stateful} sessions, via the use of cookies.
                The ~Set-Cookie~ header is sent from a server, informing the client to store the cookie as a session identifier for that site.
                On the other hand, the client sends a ~Cookie~ header, which tells the server which session the request belongs to.
                This can be useful for storing identifying a user on a page (allowing for personalised pages).
                However, this can be also be used to track users for profiling and targeted advertising - leading to privacy issues.
            \subsubsection*{Dynamic Web Pages}
                Servers often generate pages on-the-fly, instead of only serving statically stored pages.
                CGI (common gateway interface) allows you to identify a program and its parameters in a URL, which then starts a process to execute the program and return any results as a regular web page.
                On the other hand, servelets in Java maintain state (whereas CGI is stateless), and the webserver contains an instance of the JVM.
                \medskip

                Another approach is for the web page to incorporate interpretable code, which is executed when the page is being processed on the client-side (via JavaScript).
                It's important to distinguish this from server-side processing in something such as PHP, which the user should not see.
            \subsubsection*{IP and Hosts}
                Each end system is identified and addressed by its IP address, which is 32 bits in IPv4, or 128 bits in IPv6.
                This is easy to process by a computer, as it can easily work in powers of two, but not practical for people to use.
                \medskip

                Host names are used to create human-readable "aliases" for IP addresses.
                Originally, before 1983, all mappings were in the ~hosts~ file, since there weren't many different hosts.
                However, as more hosts became present, DNS (Domain Name System) was developed, which provides a distributed lookup facility.
                \medskip

                There are 13 root DNS servers, which know where the top-level servers are located.
                The top-level domain servers are each associated with a top-level domain.
                However, knowing where to connect to requires a large amount of communication between servers.
                This can therefore be a bottleneck for applications, and also be a critical point of failure.
                To circumvent this, we can also cache DNS lookups.
                This improves performance as we do not have to do as much communication, and it also reduces the overall load on the DNS infrastructure.
                \medskip

                However, this can be an issue if enough DNS servers advertise an incorrect lookup, causing subsequent requests to point to an incorrect IP (DNS cache poisoning).
                \medskip

                DNS query types are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item ~A~ \hfill maps a host name to its address, \textbf{name} is a host name, and \textbf{value} is its IP address
                    \item ~NS~
                        \subitem a query for a name server, \textbf{name} is a domain name, and \textbf{value} is the authoritative name server for that domain
                    \item ~CNAME~
                        \subitem a query for a canonical name, \textbf{name} is a host name alias, \textbf{value} is the primary host name
                    \item ~MX~
                        \subitem a query for the mail exchange server \textbf{name} is a host or domain name, and \textbf{value} is the name of the mail server handling incoming mail
                \end{itemize}
                The DNS protocol is connectionless, and runs on UDP port 53.
                UDP (best effort) is used since it only involves two network packets (request and response), setting up and closing a TCP (reliable) connection every time would be wasteful.
                If it fails, it can just try again.
                \medskip

                \textbf{Round Robin DNS} is a load balancing technique, as it responds to DNS requests with a list of IP addresses instead of a single IP address.
                The IP at the top of list is returned a set number of times before it is moved to the bottom of the list (the IP that was previously second in the list is now at the top).
                If load balancing is used, the TTL should be small, as we want this to constantly change depending on server load.
        \subsection*{23rd January 2020 \hfill Week 3, Lecture 3}
            \subsubsection*{Content Distribution Networks (CDNs)}
                We have the following options when we want to provide a streaming service from millions of videos to many simultaneous users;
                \begin{enumerate}[1.]
                    \itemsep0em
                    \item single, large "mega-server"
                        \begin{itemize}
                            \itemsep0em
                            \item single point of failure, and point of network congestion
                            \item long path to distant clients (slow)
                            \item multiple copies of video sent over outgoing link
                        \end{itemize}
                        This solution does not scale to a large amount of users.
                    \item store multiple copies of videos at multiple geographically distributed sites
                        \begin{itemize}
                            \itemsep0em
                            \item \textbf{enter deep} \hfill push CDN servers into many access networks (close to users)
                                \subitem used by Akamai (216000+ servers, 120+ countries, 1500+ networks)
                            \item \textbf{bring home} \hfill smaller number of large clusters in PoPs near (not within) access networks
                                \subitem used by Limelight (80+ PoPs - Points of Presence)
                        \end{itemize}
                \end{enumerate}
                A CDN DNS can select a good CDN node by picking the CDN node closest to  the client, or a CDN node with the shortest delay to the client.
                However, it's important to note that the CDN doesn't know the IP address of the client, only the address of the local DNS which may not be fully accurate.
                An alternative is to let the client decide by giving a list of CDN servers.
                The client can then select the "best" based on the lowest RTT.
            \subsubsection*{Electronic Mail}
                While email was able to achieve asynchronous communication, one-to-many communication, as well as multimedia content it had a number of limitations.
                Privacy and security was an issue, as there was initially no authentication - hence messages could be modified or forged, and messages could be read by others.
                Additionally, it was unreliable as there were no delivery guarantees, and had no reliable acknowledgement system.
                \begin{center}
                    \begin{tikzpicture}
                        \node at (1, -1) {\shortstack{A's\\agent}};
                        \node at (5, -1) {\shortstack{A's\\mail\\server}};
                        \node at (9, -1) {\shortstack{B's\\mail\\server}};
                        \node at (13, -1) {\shortstack{B's\\agent}};
                        \draw (0, 0) -- (2, 0) -- (2, -2) -- (0, -2) -- cycle;
                        \draw (4, 1) -- (6, 1) -- (6, -3) -- (4, -3) -- cycle;
                        \draw (8, 1) -- (10, 1) -- (10, -3) -- (8, -3) -- cycle;
                        \draw (12, 0) -- (14, 0) -- (14, -2) -- (12, -2) -- cycle;
                        \draw
                        (2, -1) edge[->, above] node{~SMTP~} (4, -1)
                        (6, -1) edge[->, above] node{~SMTP~} (8, -1)
                        (10, -1) edge[->, above] node{\shortstack{~POP3/~\\~IMAP/~\\~HTTP~}} (12, -1);
                    \end{tikzpicture}
                \end{center}
                The user agent is the client the user uses to read, compose, reply, send and forward messages.
                The mail server can do the following;
                \begin{itemize}
                    \itemsep0em
                    \item accept messages for remote delivery (delivers message to remote destination server with transport protocol)
                    \item accept messages for local delivery (saves messages in local persistent mailbox)
                    \item allows user agents to access local mailboxes (to allow for retrieval and / or deletion of messages)
                \end{itemize}
            \subsubsection*{Simple Mail Transfer Protocol}
                It's important to note that the 'S' in SMTP does not stand for secure (no authentication).
                This is a connection-oriented protocol (TCP), on port 25.
                As it is a very simple protocol, it can be left unsecured - this is often targeted by spammers and phishers who use unsecured mail servers to send mail without using their own resources.
                \medskip

                The general format of using SMTP is headers, followed by an empty line, and then content.
                A single dot is used to end the email, and ~QUIT~ is used to exit.
                SMTP is completely oblivious to the contents of a message, other than the \textbf{received} header, which is added by each receiving SMTP server.
                This can be used to trace the origins of an email.
                \medskip

                The initial message format had many limitations - it only supported 7-bit text content, and was essentially only usable for the English language.
                The MIME (multipurpose internet mail extensions) format defined useful extensions on top of SMTP, which includes the following types;
                \begin{itemize}
                    \itemsep0em
                    \item ~text/plain~ \hfill normal ASCII message
                    \item ~text/html~ \hfill HTML-formatted message
                    \item ~image/jpeg~ \hfill contains only an image file
                    \item ~multipart/mixed~ \hfill consists of multiple parts
                \end{itemize}
            \subsubsection*{Post Office Protocol (POP3) and IMAP}
                The user's mailbox is often stored on a different machine than the user agent, but we need remote access to incoming (and outgoing) messages.
                However, POP3 is insecure (at least on port 110), due to the transmission of credentials in plain text.
                It also implicitly assumes the retrieved mail is deleted at the server, which isn't useful if people wanted to access mail from different clients.
                \medskip

                The internet message access protocol (IMAP) solves this, by storing messages on a server, and requiring the client to be online to read mail.
            \subsubsection*{Dark Web}
                TOR (The Onion Router) hides the user behind a series of machines (proxies), and also allows for access to ~.onion~ sites (as well as regular ones).
                This can be used for privacy purposes, as well as for circumventing censorship.
                The exit nodes of TOR can be owned by law enforcement agencies, allowing for a user to be compromised if they were to subpoena all intermediate proxies.
                \medskip

                Not that this shouldn't be confused with the \textbf{deep web}, which is typically just not indexed on the surface web.
        \subsection*{27th January 2020 \hfill Week 4, Lecture 1}
            \subsubsection*{Transport Layer}
                The transport layer provides both reliable connection-oriented services (TCP - transmission control protocol), as well as unreliable connection-less services (UDP - user datagram protocol).
                This provides for logical communication between application processes, and only runs on end hosts (not routers / switches).
                TCP data are called segments, whereas UDP data are called datagrams.
                \medskip

                We also assume that the underlying layer is working, with every host having a unique IP address, and that IP is a "best-effort" delivery service.
                This means that it has no guarantees on the integrity of data (or packet) transmission, nor does it guarantee the order of delivery of packets or segments.
            \subsubsection*{Data Encapsulation}
                For each layer, we have the following terminology - we can't refer to everything as packets;
                \begin{itemize}
                    \itemsep0em
                    \item application layer \hfill data
                    \item transport layer \hfill TCP segments or UDP datagrams
                        \subitem (TCP only) segmentation can be done when the segments are too large - if the UDP datagrams are too large, it cannot be sent
                    \item network / internet layer \hfill IP datagrams (or packets)
                        \subitem similarly, fragmentation can be done when the packets are too large
                    \item data link layer \hfill frames
                    \item physical layer \hfill bits
                \end{itemize}
            \subsubsection*{Ports}
                Note that it's possible for a client (one IP) to communicate with the same host (one IP) via multiple applications, such as HTTP and SMTP.
                Each application on ta host is identified with a unique port number - they can be thought of as cross-platform process identifiers.
                A socket consists of two pairs of ~ip\_address~ + ~port\_number~ + ~TCP/UDP~;
                such as
                \begin{center}
                    ~146.179.40.24:80 TCP~ $\Leftrightarrow$ ~192.168.1.1:7155 TCP~
                \end{center}
                The first 1024 ports (0 - 1023) are reserved, and cannot be used to form a connection as a client (unless it is done as a superuser).
            \subsubsection*{Transmission Control Protocol}
                TCP is the Internet's primary transport protocol.
                It is a connection-oriented service, and endpoints initially perform a handshake to establish a connection.
                This is a full-duplex service, thus both endpoints can send a receive at the same time.
                Some definitions for TCP are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{TCP segment} \hfill "envelope" for TCP data
                    \item \textbf{maximum segment size (MSS)}
                        \subitem maximum amount of application data transmitted in a single segment (does not include headers) - typically related to MTU to avoid network-level fragmentation
                    \item \textbf{maximum transmission unit (MTU)} \hfill largest link-layer frame available to the sender host
                        \subitem path MTU discovery (PMTUD) is used to determine the largest link-layer frame that can be sent on all links from the sender to the receiver
                \end{itemize}
                The TCP header consists of the following fields;
                \begin{itemize}
                    \itemsep0em
                    \item \violet{source and destination ports} \hfill 16-bit each (identifies applications)
                    \item \violet{sequence number} \hfill 32-bit (used to implement reliable data transfer)
                        \medskip

                        These numbers are not associated with the segments, but instead are associated with the bytes in the data stream.
                        It indicates the sequence number (the place) of the first byte carried by the TCP segment.
                        When the connection is initialised, a random ISN (initial sequence number) is decided upon to avoid accidentally receiving leftover segments.
                    \item \violet{acknowledgement number} \hfill 32-bit (used to implement reliable data transfer)
                        \medskip

                        Represents the first number not yet seen by the receiver (one higher than the sequence number of the last bit received).
                        These can be cumulative, and typically TCP implementations acknowledge every other packet;
                        \begin{center}
                            \begin{tikzpicture}[x=1.5cm, y=0.55cm]
                                \node at (4, -6) {$\vdots$};
                                \node at (0, 0.5) {~A~};
                                \node at (8, 0.5) {~B~};
                                \draw (0, 0) edge[->] (0, -7);
                                \draw (8, 0) edge[->] (8, -7);
                                \draw
                                (0, -1) edge[->, above] node{~[seq\#=1200,...], size(data) = 1000~} (8, -1)
                                (0, -3) edge[->, above] node{~[seq\#=2200,...], size(data) = 500~} (8, -3)
                                (8, -5) edge[->, above] node{~[seq\#=...,ack\#=2700]~} (0, -5);
                            \end{tikzpicture}
                        \end{center}
                        Note that because a TCP connection consists of a full-duplex link, there are two streams, hence two different sequence numbers (see the example below, of an "echo" application).
                        Acknowledgements are "piggybacked" on data segments.
                        \begin{center}
                            \begin{tikzpicture}[x=1.5cm, y=0.55cm]
                                \node at (4, -6) {$\vdots$};
                                \node at (0, 0.5) {~A~};
                                \node at (8, 0.5) {~B~};
                                \draw (0, 0) edge[->] (0, -8);
                                \draw (8, 0) edge[->] (8, -8);
                                \draw
                                (0, -1) edge[->, above] node{~[seq\#=100,data="C"]~} (8, -1)
                                (8, -3) edge[->, above] node{~[ack\#=101,seq\#=200,data="C"]~} (0, -3)
                                (0, -5) edge[->, above] node{~[seq\#=101,ack\#=201,data="i"]~} (8, -5)
                                (8, -7) edge[->, above] node{~[ack\#=201,seq\#=102,data="i"]~} (0, -7);
                            \end{tikzpicture}
                        \end{center}
                    \item receive window \hfill 16-bit (size of window on receiver end)
                    \item header length / offset \hfill 4-bit (size of TCP header in 32-bit words)
                    \item optional fields \hfill variable length (may be used to negotiate protocol parameters)
                    \item ~URG~ flag \hfill 1-bit (informs receiver some data is marked as urgent)
                    \item \violet{~ACK~ flag} \hfill 1-bit (value contained in the acknowledge number is a valid acknowledgement)
                        \medskip

                        See \textbf{acknowledgement number} above, and the \textbf{three-way handshake} section.
                    \item ~PSH~ flag \hfill 1-bit (solicit receiver to pass data to application immediately)
                    \item ~RST~ flag \hfill 1-bit (used during connection setup and shutdown)
                    \item \violet{~SYN~ flag} \hfill 1-bit (used during connection setup and shutdown)
                        \medskip

                        See the \textbf{three-way handshake} section below.
                    \item \violet{~FIN~ flag} \hfill 1-bit (used during connection shutdown)
                        \medskip

                        A client sends a TCP segment with ~FIN~ set, and the server responds with ~ACK~, and then the server sends a ~FIN~ TCP segment, client then responds with ~ACK~.
                        Closing a connection is simpler than initialising one.
                    \item \violet{checksum} \hfill 16-bit (used to detect transmission errors)
                \end{itemize}
            \subsubsection*{Three-Way Handshake}
                The three steps are as follows;
                \begin{enumerate}[1.]
                    \itemsep0em
                    \item \textbf{client} sends a TCP segment with ~SYN~ set, and an initial sequence number
                    \item \textbf{server} responds with another TCP segment with ~SYN~ set, as well as ~ACK~, the first unseen client sequence number, and the ISN for the server
                    \item \textbf{client} reserved with a TCP segment with ~ACK~ set, the first unseen server sequence number, and the client's new sequence number
                \end{enumerate}
                \begin{center}
                    \begin{tikzpicture}[x=1.5cm, y=0.55cm]
                        \node at (4, -6) {$\vdots$};
                        \node at (0, 0.5) {client};
                        \node at (8, 0.5) {server};
                        \draw (0, 0) edge[->] (0, -7);
                        \draw (8, 0) edge[->] (8, -7);
                        \draw
                        (0, -1) edge[->, above] node{~[SYN,seq\#=cli\_init\_seq]~} (8, -1)
                        (8, -3) edge[->, above] node{~[SYN,ACK,ack\#=cli\_init\_seq+1,seq\#=srv\_init\_seq]~} (0, -3)
                        (0, -5) edge[->, above] node{~[ACK,seq\#=cli\_init\_seq+1,ack\#=srv\_init\_seq+1]~} (8, -5);
                    \end{tikzpicture}
                \end{center}
            \subsubsection*{User Datagram Protocol}
                UDP only provides the two most basic functions of a transport protocol, which are application identification (multiplexing and demultiplexing), and an integrity check via a CRC-type checksum.
                There is no flow control, no error control, nor any retransmissions.
                The datagrams cannot be larger than 65K, there is no segmentation, and the router will just drop it.
                The 65K consists of 20B IP header, 8B UDP header, 65507B of data, coming to a total of 65535 bytes.
                In practice, only 500 to 1000 bytes are used (the smaller the datagram, the more likely it will arrive intact).
                \medskip

                Instead of just using IP, it adds port numbers on top of it, allowing us to differentiate between applications.
                This is a connection-less protocol, therefore there is no need to connect (just send the data) but each datagram packet must carry the full address and port of the recipient.
                The UDP header consists of the following fields;
                \begin{itemize}
                    \itemsep0em
                    \item source and destination ports \hfill 16-bit each
                    \item length of data \hfill 16-bit
                    \item checksum \hfill 16-bit
                \end{itemize}
                Any application where we care more about speed, we can use UDP, since it is generally faster (due to the lack of connection establishment), and also has a smaller packet overhead.
            \subsubsection*{Berkeley Socket Interface}
                The \textbf{Berkeley} socket interface is as follows;
                \begin{itemize}
                    \itemsep0em
                    \item ~SOCKET~ \hfill create a new communication endpoint
                    \item ~BIND~ \hfill attach a local address to a socket
                        \subitem the client and server each bind a transport-level address and a name to the locally created socket
                    \item ~LISTEN~ \hfill announce willingness to accept ~N~ connections
                        \subitem server starts listening on this socket, thus telling the kernel it will wait for connections from clients
                    \item ~ACCEPT~ \hfill block until a remote client wishes to establish a connection
                        \subitem this blocks the current thread, thus it is a synchronous operation
                        \subitem from here the server can accept or select connections from clients
                    \item ~CONNECT~ \hfill attempt to establish a connection
                        \subitem a client connects to the socket, it needs to provide the full transport-level address to locate the socket
                    \item ~SEND~ \hfill send data over a connection
                    \item ~RECEIVE~ \hfill receive data over a connection
                        \subitem now the client and server communicate through these operations on their respective sockets
                    \item ~CLOSE~ \hfill release the connection
                        \subitem end the communication, must be closed otherwise connections may be continued, and may run out of ports
                \end{itemize}
                \begin{center}
                    \begin{tikzpicture}[x=1.25cm, y=0.66cm]
                        \begin{scope}[shift={(0, 0)}]
                            \node at (1.5, 0.5) {server};
                            \node at (1.5, -0.5) {~SOCKET~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(0, -1.5)}]
                            \node at (1.5, -0.5) {~BIND~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(0, -3)}]
                            \node[violet] at (1.5, -0.5) {~LISTEN~};
                            \draw[violet] (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(0, -4.5)}]
                            \node[violet] at (1.5, -0.5) {~ACCEPT~};
                            \draw[violet] (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(0, -6)}]
                            \node at (1.5, -0.5) {~READ~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(0, -7.5)}]
                            \node at (1.5, -0.5) {~WRITE~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(0, -9)}]
                            \node at (1.5, -0.5) {~CLOSE~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \draw
                        (1.5, -1) -- (1.5, -1.5)
                        (1.5, -2.5) -- (1.5, -3)
                        (1.5, -4) -- (1.5, -4.5)
                        (1.5, -5.5) -- (1.5, -6)
                        (1.5, -7) -- (1.5, -7.5)
                        (1.5, -8.5) -- (1.5, -9)
                        (6.5, -1) -- (6.5, -4.5)
                        (6.5, -5.5) -- (6.5, -6)
                        (6.5, -7) -- (6.5, -7.5)
                        (6.5, -8.5) -- (6.5, -9)
                        (3, -5) edge[<->, dashed, violet] (5, -5)
                        (5, -6.5) edge[->] (3, -6.5)
                        (3, -8) edge[->] (5, -8)
                        (0, -8) edge[->, bend left=45] (0, -6.5)
                        (8, -8) edge[->, bend right=45] (8, -6.5);
                        \begin{scope}[shift={(5, 0)}]
                            \node at (1.5, 0.5) {client};
                            \node at (1.5, -0.5) {~SOCKET~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(5, -4.5)}]
                            \node[violet] at (1.5, -0.5) {~CONNECT~};
                            \draw[violet] (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(5, -6)}]
                            \node at (1.5, -0.5) {~WRITE~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(5, -7.5)}]
                            \node at (1.5, -0.5) {~READ~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(5, -9)}]
                            \node at (1.5, -0.5) {~CLOSE~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                    \end{tikzpicture}
                \end{center}
                Note that the part in \violet{violet} would not be present for UDP.
        \subsection*{30th January 2020 \hfill Week 4, Lecture 2}
            \subsubsection*{TCP vs UDP}
                The scenario is as follows; movie player app is being built that allows (paying) users to stream public domain movies.
                Since the users are paying, we should be using TCP, as it guarantees quality of service, whereas UDP does not.
                The difference in performance (TCP being slower than UDP) can be circumvented by pre-buffering (sending some data in advance for the client to store locally).
                This however doesn't work for live events - we can either switch to UDP, or introduce a delay between the feed and the live event.
            \subsubsection*{QUIC}
                QUIC (Quick UDP Internet Connections) is a new layer 4 protocol, implemented by a Google engineer in 2012.
                Originally, it was designed for general purpose, but now it is being used for HTTP (layer 5).
                This is still a draft, but is actively being used by some web servers.
            \subsubsection*{Finite-State Machines}
                A finite-state machine (FSM) is a mathematical abstraction, where states are represented as nodes, and transitions are directed edges between states, labelled with events.
                They are also known as finite-state automaton (FSA), deterministic finite-state automaton (DFA), and non-deterministic finite-state automaton (NFA) - multiple edges with the same label from one node.
                This can be used to specify protocols, where the states represent the state of a protocol, and transitions are characterised by an event / action label (event typically consists of an input message or timeout, whereas an action typically consists of an output message).
                $$\frac{\text{input / timeout (event)}}{\text{output (action)}}$$
                Examples of this are in the slides, for the TCP state machines for both the client and server.
            \subsubsection*{Reliable Data Transfer}
                TCP adds a reliable channel on top of an unreliable channel (IP) which is "best effort" delivery.
                The service provided by the transport layer sits on top of the service provided by the network layer.
                \begin{center}
                    \begin{tikzpicture}[x=1.1cm, y=0.5cm]
                        \node at (1.5, -1) {\shortstack{web\\browser}};
                        \node at (7.5, -1) {\shortstack{web\\server}};
                        \begin{scope}[shift={(0, 0)}]
                            \begin{scope}[shift={(0, 0)}]
                                \draw (0, 0) -- (3, 0) -- (3, -2) -- (0, -2) -- cycle;
                            \end{scope}
                            \begin{scope}[shift={(0, -4)}]
                                \node at (1.5, -1) {\shortstack{reliable-transfer\\protocol}};
                                \draw (0, 0) -- (3, 0) -- (3, -2) -- (0, -2) -- cycle;
                            \end{scope}
                            \draw
                            (1, -2) edge[->, left] node{~r\_send()~} (1, -4)
                            (1, -6) edge[left] node{~u\_send()~} (1, -8)
                            (2, -4) edge[->, right] node{~r\_recv()~} (2, -2)
                            (2, -8) edge[->, right] node{~u\_recv()~} (2, -6);
                        \end{scope}
                        \node at (4.5, -9) {best effort (unreliable) network};
                        \draw[dashed]
                        (2, -8) -- (7, -8)
                        (1, -8) -- (1, -10) -- (8, -10) -- (8, -8);
                        \draw
                        (-1, 0) edge[|-|, left] node{application} (-1, -2.9)
                        (-1, -3.1) edge[|-|, left] node{transport} (-1, -6.9)
                        (-1, -7.1) edge[|-|, left] node{network} (-1, -10);
                        \begin{scope}[shift={(6, 0)}]
                            \begin{scope}[shift={(0, 0)}]
                                \draw (0, 0) -- (3, 0) -- (3, -2) -- (0, -2) -- cycle;
                            \end{scope}
                            \begin{scope}[shift={(0, -4)}]
                                \node at (1.5, -1) {\shortstack{reliable-transfer\\protocol}};
                                \draw (0, 0) -- (3, 0) -- (3, -2) -- (0, -2) -- cycle;
                            \end{scope}
                            \draw
                            (1, -2) edge[->, left] node{~r\_send()~} (1, -4)
                            (1, -6) edge[left] node{~u\_send()~} (1, -8)
                            (2, -4) edge[->, right] node{~r\_recv()~} (2, -2)
                            (2, -8) edge[->, right] node{~u\_recv()~} (2, -6);
                        \end{scope}
                    \end{tikzpicture}
                \end{center}
                Another issue is transmitting data through a noisy channel.
                There is a chance no packets will be lost, but a a bit may be modified during the transmission (flipped).
                The stages of dealing with this are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{error detection} \hfill receiver must know when a received packet is corrupted
                        \medskip

                        Some strategies for detecting errors are as follows;
                        \begin{itemize}
                            \itemsep0em
                            \item sending redundant information
                                \subitem sending information twice, report an error if two different messages received - inefficient
                            \item error-detection codes
                                \subitem parity bit, adding a single bit at the end that is the XOR of all other bits in the message, if the recomputed XOR (by receiver) is different, then an error occurred
                        \end{itemize}
                    \item \textbf{receiver feedback} \hfill receiver must be able to alert sender that a corrupted packet was received
                        \medskip

                        ~ACK~s and ~NACK~s are also protected with an error-detection code, with corrupted ~ACK~s being treated as ~NACK~s.
                        This may possibly generate duplicate segments, however sequence numbers allow the receiver to ignore these data segments.
                    \item \textbf{retransmission} \hfill the sender must retransmit corrupted packets
                \end{itemize}
                Note that in the diagram below, ~[data]*~ indicates a packet containing ~data~ and an error-detection code, and $A$ represents the acknowledgement state.
                \begin{center}
                    \begin{tikzpicture}
                        \node[state, minimum size=1cm, accepting] (s) at (0, 0) {$S$};
                        \node[state, minimum size=1cm] (a) at (6, 0) {$A$};
                        \draw
                        (s) edge[->, bend left=20, above] node{$\dfrac{~r\_send(data)~}{~u\_send([data]*)~}$} (a)
                        (a) edge[->, bend left=20, below] node{$\dfrac{~u\_recv(pkt)~ \land ~pkt is ACK~}{}$} (s)
                        (a) edge[->, loop, out=45, in=-45, distance=2cm, right] node{$\dfrac{~u\_recv(pkt)~ \land ~pkt is NACK~}{~u\_send([data]*)~}$} (a);
                        \node[state, minimum size=1cm, accepting] (r) at (6, -3) {$R$};
                        \draw
                        (r) edge[->, loop, out=45, in=-45, distance=2cm, right] node{$\dfrac{~u\_recv(pkt)~ \land ~pkt is corrupted~}{~u\_send(NACK)~}$} (r)
                        (r) edge[->, loop, out=225, in=135, distance=2cm, left] node{$\dfrac{~u\_recv(pkt)~ \land ~pkt is good~}{~u\_send(ACK); r\_recv(pkt)~}$} (r);
                    \end{tikzpicture}
                \end{center}
                This is a synchronous (or stop-and-wait) for each segment, as the sender must receive a positive acknowledgement before it can take more data from the application layer.
                However, this can have issues when the ~ACK/NACK~ packets have issues.
                A way around this is for the sender to add a sequence number to each packet, thus allowing the receiver to determine whether a packet is a retransmission.
                If the sender does not hear an acknowledgement, due to some failure, it assumes a ~NACK~, and retransmits.
                However, if the receiver did actually send an acknowledgement, it would ignore the packet, since it knows it is a retransmission.
                It then resends the ~ACK~, and doesn't process the retransmitted.
                \medskip

                Since this is a stop-and-wait protocol for each segment, only one bit is needed for the sequence number - as all we need to do is distinguish between the next segment and the retransmission of the current segment.
                \medskip

                However, now that we have sequence numbers, we don't need both ~ACK~ and ~NACK~, since we can convey the same semantics by sending an ~ACK~ for the last good packet it received.
                \begin{center}
                    \begin{tikzpicture}
                        \node[state, minimum size=1cm, accepting] (s0) at (0, 0) {$S_0$};
                        \node[state, minimum size=1cm] (a0) at (6, 0) {$A_0$};
                        \node[state, minimum size=1cm] (s1) at (6, -6) {$S_1$};
                        \node[state, minimum size=1cm] (a1) at (0, -6) {$A_1$};
                        \draw
                        (s0) edge[->, above] node{$\dfrac{~r\_send(data)~}{~u\_send([0, data]*~)}$} (a0)
                        (a0) edge[->, right] node{$\dfrac{\begin{matrix}
                            ~u\_recv(pkt) ~ \land \\
                            ~pkt is good ~ \land \\
                            ~pkt is (ACK, 0)~
                        \end{matrix}}{}$} (s1)
                        (s1) edge[->, below] node{$\dfrac{~r\_send(data)~}{~u\_send([1, data]*~)}$} (a1)
                        (a1) edge[->, left] node{$\dfrac{\begin{matrix}
                            ~u\_recv(pkt) ~ \land \\
                            ~pkt is good ~ \land \\
                            ~pkt is (ACK, 1)~
                        \end{matrix}}{}$} (s0)
                        (a0) edge[->, loop, in=-45, out=45, distance=2cm, right] node{$\dfrac{\begin{matrix}
                            ~u\_recv(pkt) ~ \land \\
                            (~pkt is (ACK, 1) ~ \lor \\
                            ~pkt is corrupted~)
                        \end{matrix}}{~u\_send([0, data]*~}$} (a0)
                        (a1) edge[->, loop, in=135, out=225, distance=2cm, left] node{$\dfrac{\begin{matrix}
                            ~u\_recv(pkt) ~ \land \\
                            (~pkt is (ACK, 0) ~ \lor \\
                            ~pkt is corrupted~)
                        \end{matrix}}{~u\_send([1, data]*~}$} (a1);
                    \end{tikzpicture}
                \end{center}
                \begin{center}
                    \begin{tikzpicture}
                        \node[state, minimum size=1cm, accepting] (r0) at (0, 0) {$R_0$};
                        \node[state, minimum size=1cm] (r1) at (0, -5) {$R_1$};

                        \draw
                        (r0) edge[->, bend left=20, right] node{$\dfrac{\begin{matrix}
                            ~u\_recv(pkt) ~ \land \\
                            ~pkt is good ~ \land \\
                            ~seq\_num(pkt) is 0~
                        \end{matrix}}{~u\_send([ACK, 0]*); r\_recv(pkt)~}$} (r1)
                        (r1) edge[->, bend left=20, left] node{$\dfrac{\begin{matrix}
                            ~u\_recv(pkt) ~ \land \\
                            ~pkt is good ~ \land \\
                            ~seq\_num(pkt) is 1~
                        \end{matrix}}{~u\_send([ACK, 1]*); r\_recv(pkt)~}$} (r0)
                        (r0) edge[->, loop, out=45, in=-45, distance=2cm, right] node{$\dfrac{\begin{matrix}
                            ~u\_recv(pkt) ~ \land \\
                            ~pkt is corrupted~
                        \end{matrix}}{~u\_send([ACK, 1]*)~}$} (r0)
                        (r1) edge[->, loop, out=45, in=-45, distance=2cm, right] node{$\dfrac{\begin{matrix}
                            ~u\_recv(pkt) ~ \land \\
                            ~pkt is corrupted~
                        \end{matrix}}{~u\_send([ACK, 0]*)~}$} (r1)
                        (r0) edge[->, loop, out=135, in=225, distance=2cm, left] node{$\dfrac{\begin{matrix}
                            ~u\_recv(pkt) ~ \land \\
                            ~pkt is good ~ \land \\
                            ~snd seq\_num(pkt) is 1~
                        \end{matrix}}{~u\_send([ACK, 1]*)~}$} (r0)
                        (r1) edge[->, loop, out=135, in=225, distance=2cm, left] node{$\dfrac{\begin{matrix}
                            ~u\_recv(pkt) ~ \land \\
                            ~pkt is good ~ \land \\
                            ~snd seq\_num(pkt) is 0~
                        \end{matrix}}{~u\_send([ACK, 0]*)~}$} (r1);
                    \end{tikzpicture}
                \end{center}
            \subsubsection*{Acknowledgement Generation}
                The following are cases of segment arrival, and how the protocol handles them;
                \begin{itemize}
                    \itemsep0em
                    \item arrival of in-order segment with expected sequence number (all data up to expected sequence number already acknowledged)
                        \subitem delayed ~ACK~, wait up to 500ms for another in-order segment, if it doesn't arrive, send ~ACK~ for just this segment
                    \item arrival of in-order segment with expected sequence number (one other in-order segment awaiting ~ACK~, from above case)
                        \subitem immediately send cumulative ~ACK~ for both segments
                    \item arrival of out of order segment with higher-than-expected sequence number (gap detected)
                        \subitem immediately send duplicate ~ACK~ - the sender will know to fill in the gap, as it would've already seen this acknowledgement
                    \item arrival of segment that fills a gap in the received data
                        \subitem immediately send ~ACK~ if segment starts at lower end of gap
                \end{itemize}
                Additionally, it's important to note that lost packets can easily be treated as corrupted packets.
                Since I don't really want to draw the FSM again, add a ~start\_timer()~ after every ~u\_send(...)~, and an additional transition loop to $A_0$ and $A_1$, which sends the same data, but the input is ~timeout~.
                \medskip

                There's also a small section after this on the alternating bit protocol, which isn't used in practice.
        \subsection*{30th January 2020 \hfill Week 4, Lecture 3}
            \subsubsection*{Congestion Detection}
                If the queue of one or more routers between the sender and receiver overflow, we call it \textbf{congestion} - this has the visible effect of segments being dropped.
                The server can assume the network experiences congestion when it detects a segment loss; either on a timeout, hence no ~ACK~, or multiple acknowledgements, which is equivalent to ~NACK~.
                \medskip

                TCP we've described so far is referred to as TCP Reno.
                Another popular implementation is TCP Vegas, which aims to detect congestion before losses occur.
                It does this by predicting imminent packet loss via observing the RTT - the longer it is, the greater the congestion in the routers.
                However, flows with small RTTs are advantaged, compared to the ones with large RTTs, as their window can grow faster.
                TCP CUBIC circumvents this by making the window increase as a function of time rather than RTT.
            \subsubsection*{Congestion Window and Congestion Control}
                The congestion window, $W$, is maintained by the sender, and limits the amount of bytes that the sender pushes into the network before it blocks to wait for acknowledgements.
                \begin{center}
                    $\text{LastByteSent} - \text{LastByteAcked} \leq W = \min(\text{CongestionWindow}, \text{ReceiverWindow})$
                \end{center}
                This gives a resulting maximum output of roughly
                $$\lambda = \frac{W}{\text{RTT}}$$
                The phases are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{slow start}
                        \medskip

                        The initial value of $W$ is the maximum segment size (MSS), which is quite low for modern (high-speed) networks.
                        To result in a good throughput, TCP increases the sending rate exponentially for its first phase.
                        It increases $W$ by 1 MSS on every (positive) segment acknowledgement (doubles each time - the first ~ACK~ increases it by 1 MSS, the second ~ACK~ will be after sending 2 segments, hence it increases by a further s2 MSS, and so on), until it reaches some slow start threshold (ssthresh), or until congestion occurs.
                        If $W$ is greater than (ssthresh), then use congestion avoidance (if they are equal, either could be used).
                    \item \textbf{congestion avoidance}
                        \medskip

                        TCP then increases $W$ linearly in this phase.
                        $$W = W + \underbrace{\text{MSS} \cdot \frac{\text{MSS}}{W}}_\text{increment}$$
                        This happens until congestion is detected.
                    \item \textbf{Additive-Increase / Multiplicative-Decrease (AIMD)}
                        \begin{itemize}
                            \itemsep0em
                            \item at every good acknowledgement, increase $W$ in accordance with congestion avoidance ($\frac{\text{MSS}^2}{W}$)
                            \item at every packet loss event, TCP halves the congestion window
                                \medskip

                                There are two possibilities for packet loss.
                                TCP provides reliable data transfer by using a timer to detect lost segments.
                                If there is a timeout, without an ~ACK~, it means that there is likely a lost packet, hence a retransmission is required.
                                This timeout interval, $T$, must be larger than the RTT to avoid unnecessary retransmissions, however it shouldn't be too far from RTT, as we want to detect and retransmit lost segments as quickly as possible.
                                TCP sets its timeouts as follows, where (1) is the estimated RTT, and (2) is the variability estimate;
                                $$T = \underbrace{\overline{\text{RTT}}}_{(1)} + 4 \cdot \underbrace{\overline{\text{DevRTT}}}_{(2)}$$
                                The timeout is controlled by continuously estimating the current RTT.
                                \medskip

                                The agreement is that 3 duplicate ~ACK~s (hence 4 identical ~ACK~s overall), are interpreted as a ~NACK~ in \textbf{fast retransmit}.
                                While both timeouts and ~NACK~s signal a loss, they say different things about the status of the network, hence TCP should react differently.
                                A timeout indicates congestion, whereas the duplicate ~ACK~s suggests the network is able to still able to deliver segments along that path.
                                \medskip

                                In the formulae below, assume the current window size is $W = \overline{W}$;
                                \begin{itemize}
                                    \itemsep0em
                                    \item timeout
                                        \medskip

                                        In the event of a timeout, set $W = \text{MSS}$, and run slow start until $W$ reaches $\frac{\overline{W}}{2}$ (which is the new ssthresh), and then proceed with congestion avoidance.
                                    \item ~NACK~
                                        \medskip

                                        Similarly set ssthresh to $\frac{\overline{W}}{2}$, but set $W = \frac{\overline{W}}{2}$.
                                        We then continue to run congestion avoidance, which increases $W$ linearly - \textbf{fast recovery}.
                                \end{itemize}
                        \end{itemize}
                \end{itemize}
            \subsubsection*{Selective Repeat}
                The sender only transmits packets it suspects were lost or corrupted.
                However, if we were to use a TCP flavour that uses this, we'd need powerful routers in the path, as it requires storage and processing.
                \begin{itemize}
                    \itemsep0em
                    \item sender maintains a vector of acknowledgement flags
                    \item receiver maintains a vector of acknowledged flags
                        \subitem maintains a buffer of out-of-order packets
                    \item sender maintains a timer for each pending packet
                    \item sender resends a packet when its timer experiences
                    \item sender slides the window when the lowest pending sequence number is acknowledged
                \end{itemize}
                \begin{center}
                    \begin{tikzpicture}
                        \draw
                        (0, 0) -- (8, 0)
                        (0, -1) -- (8, -1);
                        \foreach \x in {0,...,16} {
                            \draw (0 + 0.5*\x, -1) -- (0 + 0.5*\x, 0);
                        }
                        \draw
                        (0, 0.5) edge[-|] (1.4, 0.5)
                        (1.6, 0.5) edge[|-|] (4.9, 0.5)
                        (5.1, 0.5) edge[|-|] (6.9, 0.5)
                        (7.1, 0.5) edge[|-] (8, 0.5)
                        (1.6, -1.5) edge[|-|] (6.9, -1.5);

                        \node at (-0.5, -0.5) {$\cdots$};
                        \node at (8.5, -0.5) {$\cdots$};
                        \node at (0, 1) {\tiny{acknowledged}};
                        \node at (3.25, 1) {\tiny{pending}};
                        \node at (6, 1) {\tiny{available}};
                        \node at (8, 1) {\tiny{unavailable}};
                        \node at (4.25, -2) {window size ($W$)};
                    \end{tikzpicture}
                \end{center}
            \subsubsection*{Flow Control vs Congestion Control}
                The former aims to not overflow the receiver, whereas the latter aims not to overflow the network.
                An example of flow control is as follows;
                \begin{center}
                    \begin{tikzpicture}
                        \node at (0, 1.5) {sender};
                        \node at (8, 1.5) {receiver};
                        \foreach \y in {0,...,6} {
                            \draw (9, 0.25 - \y) -- (11, 0.25 - \y) -- (11, -0.25 - \y) -- (9, -0.25 - \y) -- cycle;
                        }
                        \node at (9, 0.5) {\tiny{0K}};
                        \node at (11, 0.5) {\tiny{4K}};
                        \node at (10, 0) {\tiny{empty}};
                        \node at (9.5, -1) {\tiny{2K}};
                        \node at (9.5, -2) {\tiny{2K}};
                        \node at (10, -3) {\tiny{full}};
                        \node at (10, -4) {\tiny{full}};
                        \node at (10.5, -5) {\tiny{2K}};
                        \node at (9.25, -6) {\tiny{1K}};
                        \node at (10.5, -6) {\tiny{2K}};
                        \draw
                        (10, -0.75) -- (10, -1.25)
                        (10, -1.75) -- (10, -2.25)
                        (10, -4.75) -- (10, -5.25)
                        (9.5, -5.75) -- (9.5, -6.25)
                        (10, -5.75) -- (10, -6.25);
                        \draw
                        (0, 1) edge[->] (0, -7)
                        (8, 1) edge[->] (8, -7);
                        \draw
                        (0, -1) edge[->, above] node{~[2K] SEQ=0~} (8, -1)
                        (8, -2) edge[->, above] node{~ACK=2048,WIN=2048~} (0, -2)
                        (0, -3) edge[->, above] node{~[2K] SEQ=2048~} (8, -3)
                        (8, -4) edge[->, above] node{~ACK=4096,WIN=0~} (0, -4)
                        (8, -5) edge[->, above] node{~ACK=4096,WIN=2048~} (0, -5)
                        (0, -6) edge[->, above] node{~[1K] SEQ=4096~} (8, -6);
                        \node[rotate=90] at (-1, -4) {sender blocked};
                        \draw (-0.5, -3) edge[|-|] (-0.5, -5);
                    \end{tikzpicture}
                \end{center}
                The receiver sends the maximum number of bytes that may be sent (ReceiverWindow) along with the acknowledgement - a size of 0 is legal, and it means no more messages can be sent, except a 1-byte segment to ping receivers.
            \subsubsection*{Wireless TCP}
                TCP assumes that IP is running across wires.
                Therefore, when packets are lost, it assumes that this is due to congestion and slows down, whereas in wireless environments, packets are usually lost to channel reliability issues (where TCP should actually try harder).
                \medskip

                One solution it to split TCP connections to distinguish between wired and wireless IP.
                Another solution would be to allow the base station to do some retransmission, without informing the source (if it still fails, the source is then informed).
            \subsubsection*{Network Usage}
                We can quantify network usage with the utilisation factor;
                $$\frac{\text{how much we actually used the network}}{\text{how much we could have used it}}$$
                For example, if we were to rent a 24Mbps line, and download at 2MBps, we are at around 67\% utilisation (note the conversion from bits to bytes).
                This may be due to congestion control and / or flow control, as it may not be possible for all nodes in the route to support the amount of traffic you wish to send.
                \medskip

                If we have all the data, we can use the following formula for utilisation;
                $$U = \frac{\frac{L}{R}}{\text{RTT} + \frac{L}{R}}$$
                For example, if we have a RTT of 30ms, a channel with transmission rate $R = 1\text{Gbps}$, and a packet size $L = 1000 \text{bits}$, we have a utilisation of $U \approx 0.027\%$.
        \subsection*{4th February 2020 \hfill Week 5, Lecture 1}
            \subsubsection*{H/P/V/A/C}
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{hackers}
                        \medskip

                        Originally meant highly competent computer engineers who explore different ways of using / combining things.
                        Can be divided into the following;
                        \begin{itemize}
                            \itemsep0em
                            \item white hat \hfill a researcher who informs the company of problems before they go public
                            \item grey hat \hfill an analyst who does not inform anyone unless they get paid
                            \item black hat \hfill a malicious individual who abuses the findings to cause harm
                        \end{itemize}
                    \item \textbf{phreakers}
                        \medskip

                        Phone hackers - not as prevalent anymore, due to the telephone network being almost fully digital.
                        Playing the right frequencies allowed for access to administrative interface for a phone network.
                    \item \textbf{virii (creators)}
                        \medskip

                        Create viruses, for curiosity or money.
                        Popular viruses include ransomware, spyware, and Trojans (remotely controlled botnet, and profit from renting).
                        A rootkit is injected into the root account, running as the superuser, thus having more control.
                    \item \textbf{anarchists} \hfill "hacktivists"
                    \item \textbf{crackers}
                        \medskip

                        Originally meant wannabe hackers (script kiddies), who use the tools of others to infiltrate systems.
                \end{itemize}
            \subsubsection*{Methods and Tools}
                Some commonly used methods are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{credential reuse / stuffing} \hfill leaked ~email:password~ combinations tested on other services
                    \item \textbf{network monitor / packet sniffing} \hfill reading messages not intended for your NIC
                    \item \textbf{code / SQL injection} \hfill running your own code in someone else's system
                    \item \textbf{session / cookie hijacking} \hfill use another session without credentials
                    \item \textbf{wardriving} \hfill searching and using unsecured WiFi spots
                    \item \textbf{dumpster diving / trashing} \hfill physically checking trash for information
                    \item \textbf{clickjacking} \hfill forcing users to click on hidden links
                    \item \textbf{bat and switch} \hfill legitimate-looking ads leading to malicious destinations
                    \item \textbf{spoofing} \hfill IP (layer 3), MAC (layer 2), DNS poisoning
                \end{itemize}
                Some commonly used tools are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{rootkit} \hfill runs as an administrator (can reinstall itself)
                    \item \textbf{keyloggers} \hfill allows attackers to record all keypresses
                    \item \textbf{trojans} \hfill allows attackers to remote control an entire system (similar to \textit{TeamViewer} or VNC)
                    \item \textbf{TAILS} \hfill The Amnesic Incognito Live System - forgets on reboot
                    \item \textbf{Kali Linux} \hfill large collection of security and pentesting tools
                    \item \textbf{Metasploit} \hfill identifies systems and their vulnerabilities (similar to nmap)
                \end{itemize}
            \subsubsection*{Laws and Standards}
                Basically just a long list of laws (and their years), and organisations.
                \begin{itemize}
                    \itemsep0em
                    \item Computer Misuse Act (1990) \hfill most intrusions fall under this
                    \item Copyright, Designs, and Patents Act (1988) \hfill piracy
                    \item Criminal Justice Act (2003)
                    \item Data Protection Act (2018)
                    \item Defamation Act (2013) \hfill cyber-bullying
                    \item Disability Discrimination Act (2005)
                    \item Freedom of Information Act (2000) \hfill can be used against companies
                    \item Obscene Publications Act (1964)
                    \item Protection of Children Act (1978) \hfill 1999 version still being amended
                    \item Regulation of Investigatory Powers Act (2000)
                \end{itemize}
                Note that an intruder is trialled in both the country they reside in, as well as the laws of the country where the involved hosts are physically located.
                \begin{itemize}
                    \itemsep0em
                    \item IANA (Internet Assigned Numbers Authority) \hfill sets these standards, and assigns port numbers
                    \item ICANN (Internet Corporation for Assigned Numbers and Names) \hfill names for corporations
                    \item IETF (Internet Engineering Task Force) \hfill attempt to set standards straight
                    \item ISOC (Internet Society) \hfill push governments to update laws
                    \item EFF (Electronic Frontier Foundation) \hfill push rights (free speech and equality) online
                    \item W3C (World Wide Web Consortium)
                    \item ISO (International Organisation for Standardisation)
                \end{itemize}
        \subsection*{6th February 2020 \hfill Week 5, Lecture 2}
            \subsubsection*{}
\end{document}