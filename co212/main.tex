\documentclass[a4paper, 12pt]{article}

% packages
\usepackage{amssymb}
\usepackage[fleqn]{mathtools}
\usepackage{tikz}
\usepackage{enumerate}
\usepackage{bussproofs}
\usepackage{xcolor}
\usepackage[margin=1.3cm]{geometry}
\usepackage{logicproof}
\usepackage{diagbox}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{lstautogobble}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{tipa}
\usepackage{pgfplots}

% tikz libraries
\usetikzlibrary{
    decorations.pathreplacing,
    arrows,
    shapes.gates.logic.US,
    circuits.logic.US,
    calc,
    automata,
    positioning,
    intersections
}

\pgfplotsset{compat=1.16}

\pgfmathdeclarefunction{gauss}{2}{%
  \pgfmathparse{1/(#2*sqrt(2*pi))*exp(-((x-#1)^2)/(2*#2^2))}%
}

\allowdisplaybreaks % allow environments to break
\setlength\parindent{0pt} % no indent

% shorthand for verbatim
% this clashes with logicproof, so maybe fix this at some point?
\catcode`~=\active
\def~#1~{\texttt{#1}}

% code listing
\lstdefinestyle{main}{
    numberstyle=\tiny,
    breaklines=true,
    showspaces=false,
    showstringspaces=false,
    tabsize=2,
    numbers=left,
    basicstyle=\ttfamily,
    columns=fixed,
    fontadjust=true,
    basewidth=0.5em,
    autogobble,
    xleftmargin=3.0ex,
    mathescape=true
}
\newcommand{\dollar}{\mbox{\textdollar}} %
\lstset{style=main}

% augmented matrix
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
\hskip -\arraycolsep
\let\@ifnextchar\new@ifnextchar
\array{#1}}
\makeatother

% ceiling / floor
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

% custom commands
\newcommand{\indefint}[2]{\int #1 \, \mathrm{d}#2}
\newcommand{\defint}[4]{\int_{#1}^{#2} #3 \, \mathrm{d}#4}
\newcommand{\pdif}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\dif}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}}
\newcommand{\limit}[2]{\raisebox{0.5ex}{\scalebox{0.8}{$\displaystyle{\lim_{#1 \to #2}}$}}}
\newcommand{\summation}[2]{\sum\limits_{#1}^{#2}}
\newcommand{\product}[2]{\prod\limits_{#1}^{#2}}
\newcommand{\intbracket}[3]{\left[#3\right]_{#1}^{#2}}
\newcommand{\laplace}{\mathcal{L}}
\newcommand{\fourier}{\mathcal{F}}
\newcommand{\mat}[1]{\boldsymbol{#1}}
\renewcommand{\vec}[1]{\boldsymbol{#1}}
\newcommand{\rowt}[1]{\begin{bmatrix}
    #1
\end{bmatrix}^\top}
\DeclareMathOperator*{\argmax}{argmax}
\DeclareMathOperator*{\argmin}{argmin}

\newcommand{\ulsmash}[1]{\underline{\smash{#1}}}

\newcommand{\powerset}[0]{\wp}
\renewcommand{\emptyset}[0]{\varnothing}

\makeatletter
\newsavebox{\@brx}
\newcommand{\llangle}[1][]{\savebox{\@brx}{\(\m@th{#1\langle}\)}%
  \mathopen{\copy\@brx\kern-0.5\wd\@brx\usebox{\@brx}}}
\newcommand{\rrangle}[1][]{\savebox{\@brx}{\(\m@th{#1\rangle}\)}%
  \mathclose{\copy\@brx\kern-0.5\wd\@brx\usebox{\@brx}}}
\makeatother
\newcommand{\lla}{\llangle}
\newcommand{\rra}{\rrangle}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\crnr}[1]{\text{\textopencorner} #1 \text{\textcorner}}
\newcommand{\bnfsep}[0]{\ |\ }
\newcommand{\concsep}[0]{\ ||\ }

\newcommand{\axiom}[1]{\AxiomC{#1}}
\newcommand{\unary}[1]{\UnaryInfC{#1}}
\newcommand{\binary}[1]{\BinaryInfC{#1}}
\newcommand{\trinary}[1]{\TrinaryInfC{#1}}
\newcommand{\quaternary}[1]{\QuaternaryInfC{#1}}
\newcommand{\quinary}[1]{\QuinaryInfC{#1}}
\newcommand{\dproof}[0]{\DisplayProof}

\newcommand{\ttbs}{\char`\\}
\newcommand{\lrbt}[0]{\ \bullet\ }

% colours
\newcommand{\violet}[1]{\textcolor{violet}{#1}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\teal}[1]{\textcolor{teal}{#1}}

% reasoning proofs
\usepackage{ltablex}
\usepackage{environ}
\keepXColumns
\NewEnviron{reasoning}{
    \begin{tabularx}{\textwidth}{rlX}
        \BODY
    \end{tabularx}
}
\newcommand{\proofline}[3]{$(#1)$ & $#2$ & \hfill #3 \smallskip \\}
\newcommand{\proofarbitrary}[1]{& take arbitrary $#1$ \smallskip \\}
\newcommand{\prooftext}[1]{\multicolumn{3}{l}{#1} \smallskip \\}
\newcommand{\proofmath}[3]{$#1$ & = $#2$ & \hfill #3 \smallskip \\}
\newcommand{\prooftherefore}[1]{& $\therefore #1$ \smallskip \\}
\newcommand{\proofbc}[0]{\prooftext{\textbf{Base Case}}}
\newcommand{\proofis}[0]{\prooftext{\textbf{Inductive Step}}}

% ER diagrams
\newcommand{\nattribute}[4]{
    \node[draw, state, inner sep=0cm, minimum size=0.2cm, label=#3:{#4}] (#1) at (#2) {};
}
\newcommand{\mattribute}[4]{
    \node[draw, state, accepting, inner sep=0cm, minimum size=0.2cm, label=#3:{#4}] (#1) at (#2) {};
}
\newcommand{\dattribute}[4]{
    \node[draw, state, dashed, inner sep=0cm, minimum size=0.2cm, label=#3:{#4}] (#1) at (#2) {};
}
\newcommand{\entity}[3]{
    \node[] (#1-c) at (#2) {#3};
    \node[inner sep=0cm] (#1-l) at ($(#1-c) + (-1, 0)$) {};
    \node[inner sep=0cm] (#1-r) at ($(#1-c) + (1, 0)$) {};
    \node[inner sep=0cm] (#1-u) at ($(#1-c) + (0, 0.5)$) {};
    \node[inner sep=0cm] (#1-d) at ($(#1-c) + (0, -0.5)$) {};
    \draw
    ($(#1-c) + (-1, 0.5)$) -- ($(#1-c) + (1, 0.5)$) -- ($(#1-c) + (1, -0.5)$) -- ($(#1-c) + (-1, -0.5)$) -- cycle;
}
\newcommand{\relationship}[3]{
    \node[] (#1-c) at (#2) {#3};
    \node[inner sep=0cm] (#1-l) at ($(#1-c) + (-1, 0)$) {};
    \node[inner sep=0cm] (#1-r) at ($(#1-c) + (1, 0)$) {};
    \node[inner sep=0cm] (#1-u) at ($(#1-c) + (0, 1)$) {};
    \node[inner sep=0cm] (#1-d) at ($(#1-c) + (0, -1)$) {};
    \draw
    ($(#1-c) + (-1, 0)$) -- ($(#1-c) + (0, 1)$) -- ($(#1-c) + (1, 0)$) -- ($(#1-c) + (0, -1)$) -- cycle;
}

% actual document
\begin{document}
    \section*{CO212 - Networks and Communications}
        \subsection*{14th January 2020 \hfill Week 1, Lecture 1}
            \subsubsection*{Evolution of the Internet}
                Literally only writing this part so I have something for the first lecture.
                \begin{itemize}
                    \itemsep0em
                    \item (1969 - October) first message sent on ARPANET; "login", crashed after "l" and "o" were sent
                    \item (1971) universities in West and East coast of USA connected
                    \item (1980) London connected
                \end{itemize}
        \subsection*{14th January 2020 \hfill Week 2, Lecture 1}
            \subsubsection*{World Wide Web (WWW)}
                This is an example of an \textbf{application} on the internet, based on HTTP (HyperText Transfer Protocol).
                A web browser (the client) sends a \violet{request} to the web server over a pipe, which can be any form of connection between the two devices (can also be the same device), which in turn sends back a \teal{response}.
                \begin{center}
                    \begin{tikzpicture}
                        \node at (6, 1) {\shortstack{~GET /pixel.gif HTTP/1.1~\\~Host: www.example.com~\\~...~}};
                        \node at (6, -3) {\shortstack{~HTTP/1.1 200 OK~\\~...~\\~[binary data]~\\~...~}};
                        \node at (1, -1) {\shortstack{web\\browser}};
                        \node at (11, -1) {\shortstack{web\\server}};
                        \draw (0, 0) -- (2, 0) -- (2, -2) -- (0, -2) -- cycle;
                        \draw (10, 0) -- (12, 0) -- (12, -2) -- (10, -2) -- cycle;
                        \draw[violet] (2, -0.5) edge[->, bend left=10] (10, -0.5);
                        \draw[teal] (10, -1.5) edge[->, bend left=10] (2, -1.5);
                    \end{tikzpicture}
                \end{center}
            \subsubsection*{Layers}
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{application layer}
                        \medskip

                        Any software written for the internet is on the application layer.
                    \item \textbf{transport layer}
                        \medskip

                        In the \textbf{transport layer}, packets leave your (client) machine to the server, and the server sends back packets to your client.
                        This layer divides a (big) message into smaller chunks, and sends them to the other side (re-ordered) to be presented to the recipient.
                    \item \textbf{network layer}
                        \medskip

                        The \textbf{route / path} (sequences of switches a packet goes through) each packet takes can be different from the others, and is often the most optimal route available.
                        This is done on the \textbf{network layer}, which routers are a part of.
                        \begin{center}
                            \begin{tikzpicture}
                                \node at (1, -1) {\shortstack{web\\browser}};
                                \node at (11, -1) {\shortstack{web\\server}};
                                \draw (0, 0) -- (2, 0) -- (2, -2) -- (0, -2) -- cycle;
                                \draw (10, 0) -- (12, 0) -- (12, -2) -- (10, -2) -- cycle;
                                \node[state, minimum size=1cm] (0) at (4, 1) {};
                                \node[state, minimum size=1cm] (1) at (5, -1) {};
                                \node[state, minimum size=1cm] (2) at (6, -3) {};
                                \node[state, minimum size=1cm] (3) at (7, 0) {};
                                \node[state, minimum size=1cm] (4) at (8, -2) {};
                                \node[state, minimum size=1cm] (5) at (8, 1) {};
                                \draw[violet] (2, -1) -- (0) -- (3) -- (2) -- (4) -- (10, -1);
                                \draw
                                (0) -- (1)
                                (0) -- (5)
                                (1) -- (3)
                                (1) -- (4)
                                (4) -- (5);
                            \end{tikzpicture}
                        \end{center}
                    \item \textbf{data link layer}
                        \medskip

                        Our devices are linked to the network on the \textbf{data link layer}, via network interface controllers (NICs).
                        Examples of this include Ethernet, fiber optic network cards, as well as wireless devices such as WiFi access points, and USB dongles for 4G.
                        A communication link is any connection between packet switches and / or end systems.
                    \item \textbf{physical layer}
                        \medskip

                        Finally, on the \textbf{physical layer}, there are various forms of communication media, including fiber-optic cables, twisted-pair copper wire, coaxial cables, and wireless local-area links (802.11, Bluetooth, etc).
                \end{itemize}
        \subsection*{16th January 2020 \hfill Week 2, Lecture 2}
            \subsubsection*{Circuit Switching}
                Old phones used circuit switching, which creates a connection between the two points, which is used for the entire communication.
                This isn't used for the internet as the failure of one node in the circuit would lead the the entire communication dropping - whereas a different route would be calculated in packet switching.
                \medskip

                Compared to packet switching, it has an expensive setup phase, but will need very little processing once the connection is established.
                However, it is inefficient for sharing resources - if a node is used as part of a circuit, it cannot be used by another connection for a different circuit.
                The resources are blocked once a connection is established (hence it is an inefficient way to use the network).
                On the other hand, packet switching has no setup cost, but has a processing cost, as well as space overhead, for every packet.
                It has a processing cost for forwarding the packets, as well as space overhead as there must be redundant data for each packet, such that it is self contained.
                It is specifically designed to share links, hence it allows for a better utilisation of network resources.
            \subsubsection*{Protocols}
                A protocol is a set of rules (an agreement between communicating parties on how communication is to proceed), run by end systems as well as packet switches.
                It must be unambiguous, complete (includes actions and / or responses for all possible situations), and also define all necessary message formats.
                The phases are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{handshake} \hfill establishes identities and / or context
                    \item \textbf{conversation} \hfill free-form exchange
                    \item \textbf{closing} \hfill terminating the conversation
                \end{itemize}
                The internet protocol stack is based on the 5 layers briefly covered in the previous lecture.
                Some examples of design issues that can be encountered are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{addressing} \hfill how to denote the intended recipient
                    \item \textbf{error control} \hfill how to detect (and possibly fix) transmission errors, e.g. checksums
                    \item \textbf{flow control} \hfill ensure data travels through communication media without issues
                    \item \textbf{multiplexing / demultiplexing} \hfill conversion of data into binary, and parallel communications
                    \item \textbf{routing} \hfill which route is chosen
                \end{itemize}
                Most network layers are either connection-oriented, where a connection is first established, data is exchanged, and the connection is finally released, or connectionless, where data is marked with its destination.
                \medskip

                The TCP/IP (4 layer) stack consists of application, transport, internet, and network access (which combines data link and physical).
                On the other hand, the OSI (7 layer) model consists of the application layer, presentation, session, transport, network, data link, and physical.
                \begin{center}
                    \hfill
                    \begin{tabular}{|c|}
                        \hline
                        \violet{application} \\
                        \hline
                        \violet{presentation} \\
                        \hline
                        \violet{session} \\
                        \hline
                        \blue{transport} \\
                        \hline
                        \red{network} \\
                        \hline
                        \teal{data link} \\
                        \hline
                        \teal{physical} \\
                        \hline
                    \end{tabular}
                    \hfill
                    \begin{tabular}{|c|}
                        \hline
                        \violet{application} \\
                        \hline
                        \blue{transport} \\
                        \hline
                        \red{network / internet} \\
                        \hline
                        \teal{data link} \\
                        \hline
                        \teal{physical} \\
                        \hline
                    \end{tabular}
                    \hfill
                    \begin{tabular}{|c|}
                        \hline
                        \violet{application} \\
                        \hline
                        \blue{transport} \\
                        \hline
                        \red{internet} \\
                        \hline
                        \teal{network access} \\
                        \hline
                    \end{tabular}
                    \hfill \phantom{}
                \end{center}
                A \textbf{service} is a set of primitives that a layer provides to the layer above it, whereas a \textbf{protocol} is a set of rules that prescribe the layout and meaning of packets.
                In a protocol stack, layer $k$ puts its entire packet as data into a layer $k - 1$ packet, the latter may add a header and / or a trailer.
                This may have to be split across several lower level packets (\textbf{fragmentation}).
                An example of protocol layering is as follows;
                \begin{center}
                    \begin{tikzpicture}[x=0.75cm, y=0.75cm]
                        \begin{scope}[shift={(0, 0)}]
                            \node at (1, 0.5) {source machine};
                            \node at (1, -0.5) {$M$};
                            \node at (0, -2.5) {\teal{$H_4$}};
                            \node at (1.5, -2.5) {\violet{$M$}};
                            \node at (-3, -4.5) {\teal{$H_3$}};
                            \node at (-2, -4.5) {\violet{$H_4$}};
                            \node at (-1, -4.5) {\violet{$M_1$}};
                            \node at (3, -4.5) {\teal{$H_3$}};
                            \node at (4.5, -4.5) {\violet{$M_2$}};
                            \node at (-4, -6.5) {\teal{$H_2$}};
                            \node at (-3, -6.5) {\violet{$H_3$}};
                            \node at (-2, -6.5) {\violet{$H_4$}};
                            \node at (-1, -6.5) {\violet{$M_1$}};
                            \node at (0, -6.5) {\teal{$T_2$}};
                            \node at (2, -6.5) {\teal{$H_2$}};
                            \node at (3, -6.5) {\violet{$H_3$}};
                            \node at (4.5, -6.5) {\violet{$M_2$}};
                            \node at (6, -6.5) {\teal{$T_2$}};
                            \draw (0, 0) -- (2, 0) -- (2, -1) -- (0, -1) -- cycle;
                            \draw[teal] (-0.5, -2) -- (2.5, -2) -- (2.5, -3) -- (-0.5, -3) -- cycle
                            (0.5, -2) -- (0.5, -3);
                            \draw[teal] (-3.5, -4) -- (-0.5, -4) -- (-0.5, -5) -- (-3.5, -5) -- cycle
                            (-2.5, -4) -- (-2.5, -5)
                            (-1.5, -4) -- (-1.5, -5);
                            \draw[teal] (2.5, -4) -- (5.5, -4) -- (5.5, -5) -- (2.5, -5) -- cycle
                            (3.5, -4) -- (3.5, -5);
                            \draw[teal] (-4.5, -6) -- (0.5, -6) -- (0.5, -7) -- (-4.5, -7) -- cycle
                            (-3.5, -6) -- (-3.5, -7)
                            (-2.5, -6) -- (-2.5, -7)
                            (-1.5, -6) -- (-1.5, -7)
                            (-0.5, -6) -- (-0.5, -7);
                            \draw[teal] (1.5, -6) -- (6.5, -6) -- (6.5, -7) -- (1.5, -7) -- cycle
                            (2.5, -6) -- (2.5, -7)
                            (3.5, -6) -- (3.5, -7)
                            (5.5, -6) -- (5.5, -7);
                            \draw
                            (1, -1) edge[->] (1, -2)
                            (1, -3) edge[->] (-2, -4)
                            (1, -3) edge[->] (4, -4)
                            (-2, -5) edge[->] (-2, -6)
                            (4, -5) edge[->] (4, -6);
                        \end{scope}
                        \draw[dashed]
                        (2, -0.5) edge[<->, above] node{\tiny\shortstack{layer 5\\protocol}} (13, -0.5)
                        (2.5, -2.5) edge[<->, above] node{\tiny\shortstack{layer 4\\protocol}} (12.5, -2.5)
                        (5.5, -4.5) edge[<->, above] node{\tiny\shortstack{layer 3\\protocol}} (9.5, -4.5)
                        (6.5, -6.5) edge[<->, above] node{\tiny\shortstack{layer 2\\protocol}} (8.5, -6.5);
                        \draw
                        (1, -7) -- (1, -8) -- (14, -8) edge[->] (14, -7);
                        \begin{scope}[shift={(13, 0)}]
                            \node at (1, 0.5) {destination machine};
                            \node at (1, -0.5) {$M$};
                            \node at (0, -2.5) {$H_4$};
                            \node at (1.5, -2.5) {$M$};
                            \node at (-3, -4.5) {$H_3$};
                            \node at (-2, -4.5) {$H_4$};
                            \node at (-1, -4.5) {$M_1$};
                            \node at (3, -4.5) {$H_3$};
                            \node at (4.5, -4.5) {$M_2$};
                            \node at (-4, -6.5) {$H_2$};
                            \node at (-3, -6.5) {$H_3$};
                            \node at (-2, -6.5) {$H_4$};
                            \node at (-1, -6.5) {$M_1$};
                            \node at (0, -6.5) {$T_2$};
                            \node at (2, -6.5) {$H_2$};
                            \node at (3, -6.5) {$H_3$};
                            \node at (4.5, -6.5) {$M_2$};
                            \node at (6, -6.5) {$T_2$};
                            \draw (0, 0) -- (2, 0) -- (2, -1) -- (0, -1) -- cycle;
                            \draw (-0.5, -2) -- (2.5, -2) -- (2.5, -3) -- (-0.5, -3) -- cycle
                            (0.5, -2) -- (0.5, -3);
                            \draw (-3.5, -4) -- (-0.5, -4) -- (-0.5, -5) -- (-3.5, -5) -- cycle
                            (-2.5, -4) -- (-2.5, -5)
                            (-1.5, -4) -- (-1.5, -5);
                            \draw (2.5, -4) -- (5.5, -4) -- (5.5, -5) -- (2.5, -5) -- cycle
                            (3.5, -4) -- (3.5, -5);
                            \draw (-4.5, -6) -- (0.5, -6) -- (0.5, -7) -- (-4.5, -7) -- cycle
                            (-3.5, -6) -- (-3.5, -7)
                            (-2.5, -6) -- (-2.5, -7)
                            (-1.5, -6) -- (-1.5, -7)
                            (-0.5, -6) -- (-0.5, -7);
                            \draw (1.5, -6) -- (6.5, -6) -- (6.5, -7) -- (1.5, -7) -- cycle
                            (2.5, -6) -- (2.5, -7)
                            (3.5, -6) -- (3.5, -7)
                            (5.5, -6) -- (5.5, -7);
                            \draw
                            (1, -1) edge[<-] (1, -2)
                            (1, -3) edge[<-] (-2, -4)
                            (1, -3) edge[<-] (4, -4)
                            (-2, -5) edge[<-] (-2, -6)
                            (4, -5) edge[<-] (4, -6);
                        \end{scope}
                    \end{tikzpicture}
                \end{center}
                Note that the connection between the two machines can have multiple nodes in between, that can read up to a different physical layer.
                For example, if there was a link-layer switch after the source machine, it can read up to the link layer (layer 2), remove and add headers / trailers, and then send it on to the next device.
                The next device may be a router for example, which can read up to the network layer (layer 3), and do the same.
                \medskip

                The data from the layer above is known as the \violet{SDU (service data unit)}, and the SDU combined with a header, added by the current layer, is known as the \teal{PDU (protocol data unit)}.
        \subsection*{16th January 2020 \hfill Week 2, Lecture 3}
            \subsubsection*{Protocol Layers}
                The types of protocols on each layer are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{application layer}
                        \medskip

                        Protocols on the application layer defines functionality and message formats.
                        Some examples are as follows;
                        \begin{itemize}
                            \itemsep0em
                            \item \textbf{traditional} \hfill name services (DNS), sending email (SMTP), file transfer (FTP), web (HTTP(S))
                            \item \textbf{modern}
                                \subitem includes middleware protocols to support distributed systems with special protocols to handle replication, fault tolerance, caching, etc.
                            \item \textbf{high-level} \hfill special application-level protocols for e-commerce, banking etc.
                            \item \textbf{peer-to-peer} \hfill BitTorrent, old-Skype (awful API)
                        \end{itemize}
                    \item \textbf{transport layer}
                        \medskip

                        These protocols generally offer connection-oriented (TCP) as well as connectionless (UDP) services, which have varying degrees of reliability.
                        These often provide a network interface to application via sockets.
                        It's also important to note there is a difference between reliability and security; the former guarantees that the data is sent, whereas the latter ensures that it is encrypted in some form.
                        This layer also provides flow control; mechanisms to ensure fast senders don't overwhelm slow receivers.
                    \item \textbf{network layer}
                        \medskip

                        In this layer, the protocols generally describe how routing is performed, such as determining which computers / routers are in the network, the best route between two points, how to handle faults (such as a device going down), as well as handling congestion (when a router is overloaded and packets are dropped).
                    \item \textbf{data link layer}
                        \medskip

                        In this layer, we need to detect bit transmission errors.
                        This can be done by adding redundancy bits in frames to detect errors - for example adding a parity bit to every 7 bits, where a 1 indicates an odd number of 1s, and a 0 indicates an even number of 1s, or adding a checksum (cyclic redundancy check) which should match the bits before it.
                        \medskip

                        It also specifies how many computers can share a common channel, with the medium access control sub-layer (MAC).
                        A well known protocol is the Ethernet protocol.
                    \item \textbf{physical layer}
                        \medskip

                        This describes the transmission of raw bits, in terms of the physical mechanical and electrical issues.
                        For example, when two computers are connected with a wire, -3V may indicate to a binary 1, and +4V may correspond to a binary 0.
                        It may also specify the number of times the voltage can be changed per second.
                        \medskip

                        For example if the voltage can be changed 20,000 times per second, it indicates that the maximum transfer rate is 20,000 bits per second, which is 20 Kbps (20 kilobits per second).
                \end{itemize}
            \subsubsection*{Units}
                \begin{itemize}
                    \itemsep0em
                    \item 1 Byte = 8 bits \hfill note that a byte has an uppercase B, whereas a bit has lowercase b
                    \item 1000 Bytes = 1 KB \hfill (Kilobyte)
                    \item 1024 Bytes = 1 KiB \hfill (Kibibyte)
                \end{itemize}
                Typically we use powers of 10 for networks, but as long as we are consistent in what we use it is fine.
            \subsubsection*{Quantifying Data Transfer}
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{bandwidth}
                        \subitem the amount of information that \textbf{can} get into the connection in a time unit
                    \item \textbf{throughput}
                        \subitem the amount of information that \textbf{actually} get into the connection in a time unit - at steady-state, we assume zero accumulation of traffic therefore the input and output throughputs are equal
                    \item \textbf{latency}
                        \subitem the time it takes for one bit to go through the connection
                \end{itemize}
                Note that for the following formula, we use these values;
                \begin{itemize}
                    \itemsep0em
                    \item $t_0$ \hfill the time the first packet leaves the source
                    \item $t_1$ \hfill the time the first packet reaches the destination
                    \item $t_2$ \hfill the time all the packets reach the destination
                    \item $L$ \hfill the size of the packet in bits
                    \item latency (propagation delay) \hfill $d = t_1 - t_0$ (generally $\frac{\text{distance}}{\text{wave propagation speed}}$)
                        \subitem note that this is half the RTT (round-trip time)
                    \item throughput (link bandwidth) \hfill $R = \frac{L}{t_2 - t_1}$ (generally $\frac{\text{transferred bits}}{\text{duration}}$)
                    \item packetization (transmission delay / store-and-forward delay) \hfill $\frac{L}{R}$
                        \subitem time it takes for the entire packet to be received after the first bit is received
                    \item transfer time (propagation delay + transmission delay) \hfill $\Delta = d + \frac{L}{R}$
                \end{itemize}
                However, it's important to note that the connections are (almost) never direct, and therefore will have additional delays at each router.
                Note that our bandwidth is also bottlenecked by the lowest bandwidth.
                \begin{center}
                    \begin{tikzpicture}
                        \node at (1, -1) {\shortstack{source\\host}};
                        \node at (6, 0.5) {$d_x$};
                        \node at (6, -1) {router};
                        \node at (11, -1) {\shortstack{destination\\host}};
                        \draw (0, 0) -- (2, 0) -- (2, -2) -- (0, -2) -- cycle;
                        \draw (5, 0) -- (7, 0) -- (7, -2) -- (5, -2) -- cycle;
                        \draw (10, 0) -- (12, 0) -- (12, -2) -- (10, -2) -- cycle;
                        \draw
                        (2, -1) edge[->, above] node{$d_1, R_1$} (5, -1)
                        (7, -1) edge[->, above] node{$d_2, R_2$} (10, -1);
                    \end{tikzpicture}
                \end{center}
                \begin{align*}
                    d_\text{end-end} & = \begin{cases}
                        d_1 + \frac{L}{R_1} + d_x + d_2 & R_1 < R_2 \\
                        d_1 + d_x + \frac{L}{R_2} + d_2 & R_1 \geq R_2
                    \end{cases} \\
                    & = d_1 + d_x + d_2 + \frac{L}{\min (R_1, R_2)}
                \end{align*}
                The router delay, $d_x$ has two components; the processing delay $d_\text{proc}$ which is the processing time (checking for bit errors and determining the output link), as well as $d_q$, which is the queueing delay - the time waiting at the output link for transmission, which depends on how congested the router is.
                We can quantify the \textbf{traffic intensity} as follows;
                \begin{align*}
                    R & = \text{link bandwidth} \\
                    L & = \text{packet length (bits)} \\
                    a & = \text{average packet arrival rate} \\
                    \frac{La}{R} & = \text{traffic intensity} \\
                    \frac{La}{R} & \approx 0 & \text{small average queueing delay} \\
                    \frac{La}{R} & \to 1 & \text{large average queueing delay} \\
                    \frac{La}{R} & > 1 & \text{more working arriving than can be serviced, infinite delay}
                \end{align*}
        \subsection*{21st January 2020 \hfill Week 3, Lecture 1}
            \subsubsection*{Clients and Servers}
                We can distinguish between the two roles in a pair of communicating processes, in a connection-oriented model;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{client} \hfill initiates communication
                    \item \textbf{server} \hfill waits to be contacted
                \end{itemize}
                On the other hand, some applications have processes that act as both the client and the server, which is referred to P2P (or peer-to-peer) architecture.
            \subsubsection*{End System Applications}
                Internet applications are processes on the end systems.
                They must have a way of addressing each other, either via the internet (such as chat servers), or they can directly communicate (such as FTP) - but this depends on the protocol in use.
                Note that a single end system (or host) can run multiple programs, which run multiple processes, all of which connect through a network API provided by the operating system.
                Each process is addressed within its host by a \textbf{port number}.
                When an application wants to communicate with another application, the OS opens a socket, which allows data to be transferred between the two machines.
                \begin{center}
                    \begin{minipage}[t]{0.485\textwidth}
                        client application
                        \begin{enumerate}[1.]
                            \itemsep0em
                            \item create a socket $C$ by connecting to server application (connecting to host $H$ on port $P$)
                            \item read and write data to socket $C$
                            \item disconnect and destroy $C$
                        \end{enumerate}
                    \end{minipage}
                    \hfill
                    \begin{minipage}[t]{0.485\textwidth}
                        server application (on host $H$)
                        \begin{enumerate}[1.]
                            \itemsep0em
                            \item create a socket $S$ by accepting connection on part $P$ (port is often called a server socket)
                            \item read and write data to socket $S$
                            \item disconnect and destroy $S$
                        \end{enumerate}
                    \end{minipage}
                \end{center}
                The server application can open more sockets to server multiple clients at a time.
                A DDoS (distributed denial of service) attack works by opening many sockets, preventing the server from serving legitimate requests.
            \subsubsection*{The World Wide Web}
                Invented in 1989 (formally defined in 1991) by Sir Tim Berners-Lee.
                Based on the idea of hypertext and hyperlinks (based on a proposal by William Tunnicliffe in late 1960s).
                Commonly used terminology is as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{document} \hfill a webpage is called a document
                    \item \textbf{object} \hfill any called within a document (images, stylesheets, etc.)
                    \item \textbf{Uniform Resource Locator (URL)} \hfill specifies the address of an object
                    \item \textbf{browser} \hfill also called user agent - client used to access documents
                    \item \textbf{web server} \hfill application that makes documents and objects available through HTTP
                \end{itemize}
            \subsubsection*{Protocol}
                In general, the request and reply would include the following;
                \begin{center}
                    \begin{minipage}[t]{0.485\textwidth}
                        request
                        \begin{itemize}
                            \itemsep0em
                            \item protocol version
                            \item URL specification
                            \item connection attributes
                            \item content / feature negotiation
                        \end{itemize}
                    \end{minipage}
                    \hfill
                    \begin{minipage}[t]{0.485\textwidth}
                        reply
                        \begin{itemize}
                            \itemsep0em
                            \item protocol version
                            \item reply status / value
                            \item connection attributes
                            \item object attributes
                            \item content specification
                            \item content
                        \end{itemize}
                    \end{minipage}
                \end{center}
                A protocol should always include a version number, as it allows the protocol design to change.
                HTTP/2 will replace HTTP/1.x in the next few years (hopefully), as the former is able to fully multiplex a connection since all content is binary, and can use a single TCP connection for parallelism.
                \medskip

                The URL contains the host name, which determines where the requests goes, by mapping to a network address.
                The request consists of a request line, such as ~GET /path/to/index.html HTTP/1.1~, zero or more header lines, an empty line, followed by the object body (which can be empty).
                The request line contains a method, such as;
                \begin{itemize}
                    \itemsep0em
                    \item ~GET~ \hfill retrieve the object identified by the URL
                    \item ~POST~ \hfill allows for submission of data to the server
                    \item ~HEAD~ \hfill similar to ~GET~ but only receives headers
                    \item ~PUT~ \hfill requests the enclosed object to be stored under the given URL
                    \item ~DELETE~ \hfill deletes the given object
                    \item ~OPTIONS~ \hfill requests the available communication options for the given object
                \end{itemize}
                The status code in a server response is generally as follows;
                \begin{itemize}
                    \itemsep0em
                    \item ~1xx~ \hfill informational
                    \item ~2xx~ \hfill successful
                    \item ~3xx~ \hfill redirection (e.g. object has temporarily or permanently moved)
                    \item ~4xx~ \hfill client error (e.g. malformed request, unauthorised, object not found, method not allowed)
                    \item ~5xx~ \hfill server error (e.g. internal server error, service overloaded)
                \end{itemize}
        \subsection*{23rd January 2020 \hfill Week 3, Lecture 2}
            \subsubsection*{How HTTP uses TCP}
                HTTP uses TCP as it is essentially a file transfer protocol, which needs to be connection-oriented.
                The first version of HTTP uses a TCP connection for each object, which was an inefficient use of both the network and the operating system.
                HTTP/1.1 introduced persistent connection, which allows for an existing connection to be used to issue multiple requests (either sending a request, waiting for a response, sending the next request and so on, or through pipelining) - which will eventually close with a timeout.
                Pipelining allows the client to send all its requests without waiting for a response, and the server delivers them in response.
            \subsubsection*{Web Caching}
                A proxy is a server which acts as an intermediate between the client and the destination server.
                This can be used for caching by storing a copy of the content, which reduces load on the origin server, and also allows for lower latency.
                Data isn't cached for an extended period of time as it can lead to stale data (where old content is served to a user, even after the content is changed on the origin server).
                Proxies can also protect the clients by providing anonymity, as well blocking malicious content through the use of a single firewall on the proxy.
                However, this also acts as a single point of failure - if the proxy fails then the clients may not be able to connect.
                \medskip

                A ~HEAD~ request could be used to see if an object has been updated, which is less expensive than retrieving the entire object with a ~GET~ request.
                The request can also include ~Cache-Control: no-cache~, which indicates it does not want cached objects, thus requiring proxies to go to the origin server, or ~Cache-Control: max-age=20~, which only gets a cached object if the cache is less than 20 seconds old.
                \medskip

                On the other hand, the reply can also include ~Cache-Control: no-cache~, which informs the proxy not to cache the object, or ~Cache-Control: maxage=100; must-revalidate~, which specifies to the proxy that it must revalidate the object after 100 seconds.
            \subsubsection*{Sessions}
                Note that HTTP is a \textbf{stateless} protocol, which means that responses have no memory of past requests.
                However, HTTP allows higher-level applications to maintain \textbf{stateful} sessions, via the use of cookies.
                The ~Set-Cookie~ header is sent from a server, informing the client to store the cookie as a session identifier for that site.
                On the other hand, the client sends a ~Cookie~ header, which tells the server which session the request belongs to.
                This can be useful for storing identifying a user on a page (allowing for personalised pages).
                However, this can be also be used to track users for profiling and targeted advertising - leading to privacy issues.
            \subsubsection*{Dynamic Web Pages}
                Servers often generate pages on-the-fly, instead of only serving statically stored pages.
                CGI (common gateway interface) allows you to identify a program and its parameters in a URL, which then starts a process to execute the program and return any results as a regular web page.
                On the other hand, servelets in Java maintain state (whereas CGI is stateless), and the webserver contains an instance of the JVM.
                \medskip

                Another approach is for the web page to incorporate interpretable code, which is executed when the page is being processed on the client-side (via JavaScript).
                It's important to distinguish this from server-side processing in something such as PHP, which the user should not see.
            \subsubsection*{IP and Hosts}
                Each end system is identified and addressed by its IP address, which is 32 bits in IPv4, or 128 bits in IPv6.
                This is easy to process by a computer, as it can easily work in powers of two, but not practical for people to use.
                \medskip

                Host names are used to create human-readable "aliases" for IP addresses.
                Originally, before 1983, all mappings were in the ~hosts~ file, since there weren't many different hosts.
                However, as more hosts became present, DNS (Domain Name System) was developed, which provides a distributed lookup facility.
                \medskip

                There are 13 root DNS servers, which know where the top-level servers are located.
                The top-level domain servers are each associated with a top-level domain.
                However, knowing where to connect to requires a large amount of communication between servers.
                This can therefore be a bottleneck for applications, and also be a critical point of failure.
                To circumvent this, we can also cache DNS lookups.
                This improves performance as we do not have to do as much communication, and it also reduces the overall load on the DNS infrastructure.
                \medskip

                However, this can be an issue if enough DNS servers advertise an incorrect lookup, causing subsequent requests to point to an incorrect IP (DNS cache poisoning).
                \medskip

                DNS query types are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item ~A~ \hfill maps a host name to its address, \textbf{name} is a host name, and \textbf{value} is its IP address
                    \item ~NS~
                        \subitem a query for a name server, \textbf{name} is a domain name, and \textbf{value} is the authoritative name server for that domain
                    \item ~CNAME~
                        \subitem a query for a canonical name, \textbf{name} is a host name alias, \textbf{value} is the primary host name
                    \item ~MX~
                        \subitem a query for the mail exchange server \textbf{name} is a host or domain name, and \textbf{value} is the name of the mail server handling incoming mail
                \end{itemize}
                The DNS protocol is connectionless, and runs on UDP port 53.
                UDP (best effort) is used since it only involves two network packets (request and response), setting up and closing a TCP (reliable) connection every time would be wasteful.
                If it fails, it can just try again.
                \medskip

                \textbf{Round Robin DNS} is a load balancing technique, as it responds to DNS requests with a list of IP addresses instead of a single IP address.
                The IP at the top of list is returned a set number of times before it is moved to the bottom of the list (the IP that was previously second in the list is now at the top).
                If load balancing is used, the TTL should be small, as we want this to constantly change depending on server load.
        \subsection*{23rd January 2020 \hfill Week 3, Lecture 3}
            \subsubsection*{Content Distribution Networks (CDNs)}
                We have the following options when we want to provide a streaming service from millions of videos to many simultaneous users;
                \begin{enumerate}[1.]
                    \itemsep0em
                    \item single, large "mega-server"
                        \begin{itemize}
                            \itemsep0em
                            \item single point of failure, and point of network congestion
                            \item long path to distant clients (slow)
                            \item multiple copies of video sent over outgoing link
                        \end{itemize}
                        This solution does not scale to a large amount of users.
                    \item store multiple copies of videos at multiple geographically distributed sites
                        \begin{itemize}
                            \itemsep0em
                            \item \textbf{enter deep} \hfill push CDN servers into many access networks (close to users)
                                \subitem used by Akamai (216000+ servers, 120+ countries, 1500+ networks)
                            \item \textbf{bring home} \hfill smaller number of large clusters in PoPs near (not within) access networks
                                \subitem used by Limelight (80+ PoPs - Points of Presence)
                        \end{itemize}
                \end{enumerate}
                A CDN DNS can select a good CDN node by picking the CDN node closest to  the client, or a CDN node with the shortest delay to the client.
                However, it's important to note that the CDN doesn't know the IP address of the client, only the address of the local DNS which may not be fully accurate.
                An alternative is to let the client decide by giving a list of CDN servers.
                The client can then select the "best" based on the lowest RTT.
            \subsubsection*{Electronic Mail}
                While email was able to achieve asynchronous communication, one-to-many communication, as well as multimedia content it had a number of limitations.
                Privacy and security was an issue, as there was initially no authentication - hence messages could be modified or forged, and messages could be read by others.
                Additionally, it was unreliable as there were no delivery guarantees, and had no reliable acknowledgement system.
                \begin{center}
                    \begin{tikzpicture}
                        \node at (1, -1) {\shortstack{A's\\agent}};
                        \node at (5, -1) {\shortstack{A's\\mail\\server}};
                        \node at (9, -1) {\shortstack{B's\\mail\\server}};
                        \node at (13, -1) {\shortstack{B's\\agent}};
                        \draw (0, 0) -- (2, 0) -- (2, -2) -- (0, -2) -- cycle;
                        \draw (4, 1) -- (6, 1) -- (6, -3) -- (4, -3) -- cycle;
                        \draw (8, 1) -- (10, 1) -- (10, -3) -- (8, -3) -- cycle;
                        \draw (12, 0) -- (14, 0) -- (14, -2) -- (12, -2) -- cycle;
                        \draw
                        (2, -1) edge[->, above] node{~SMTP~} (4, -1)
                        (6, -1) edge[->, above] node{~SMTP~} (8, -1)
                        (10, -1) edge[->, above] node{\shortstack{~POP3/~\\~IMAP/~\\~HTTP~}} (12, -1);
                    \end{tikzpicture}
                \end{center}
                The user agent is the client the user uses to read, compose, reply, send and forward messages.
                The mail server can do the following;
                \begin{itemize}
                    \itemsep0em
                    \item accept messages for remote delivery (delivers message to remote destination server with transport protocol)
                    \item accept messages for local delivery (saves messages in local persistent mailbox)
                    \item allows user agents to access local mailboxes (to allow for retrieval and / or deletion of messages)
                \end{itemize}
            \subsubsection*{Simple Mail Transfer Protocol}
                It's important to note that the 'S' in SMTP does not stand for secure (no authentication).
                This is a connection-oriented protocol (TCP), on port 25.
                As it is a very simple protocol, it can be left unsecured - this is often targeted by spammers and phishers who use unsecured mail servers to send mail without using their own resources.
                \medskip

                The general format of using SMTP is headers, followed by an empty line, and then content.
                A single dot is used to end the email, and ~QUIT~ is used to exit.
                SMTP is completely oblivious to the contents of a message, other than the \textbf{received} header, which is added by each receiving SMTP server.
                This can be used to trace the origins of an email.
                \medskip

                The initial message format had many limitations - it only supported 7-bit text content, and was essentially only usable for the English language.
                The MIME (multipurpose internet mail extensions) format defined useful extensions on top of SMTP, which includes the following types;
                \begin{itemize}
                    \itemsep0em
                    \item ~text/plain~ \hfill normal ASCII message
                    \item ~text/html~ \hfill HTML-formatted message
                    \item ~image/jpeg~ \hfill contains only an image file
                    \item ~multipart/mixed~ \hfill consists of multiple parts
                \end{itemize}
            \subsubsection*{Post Office Protocol (POP3) and IMAP}
                The user's mailbox is often stored on a different machine than the user agent, but we need remote access to incoming (and outgoing) messages.
                However, POP3 is insecure (at least on port 110), due to the transmission of credentials in plain text.
                It also implicitly assumes the retrieved mail is deleted at the server, which isn't useful if people wanted to access mail from different clients.
                \medskip

                The internet message access protocol (IMAP) solves this, by storing messages on a server, and requiring the client to be online to read mail.
            \subsubsection*{Dark Web}
                TOR (The Onion Router) hides the user behind a series of machines (proxies), and also allows for access to ~.onion~ sites (as well as regular ones).
                This can be used for privacy purposes, as well as for circumventing censorship.
                The exit nodes of TOR can be owned by law enforcement agencies, allowing for a user to be compromised if they were to subpoena all intermediate proxies.
                \medskip

                Not that this shouldn't be confused with the \textbf{deep web}, which is typically just not indexed on the surface web.
        \subsection*{27th January 2020 \hfill Week 4, Lecture 1}
            \subsubsection*{Transport Layer}
                The transport layer provides both reliable connection-oriented services (TCP - transmission control protocol), as well as unreliable connection-less services (UDP - user datagram protocol).
                This provides for logical communication between application processes, and only runs on end hosts (not routers / switches).
                TCP data are called segments, whereas UDP data are called datagrams.
                \medskip

                We also assume that the underlying layer is working, with every host having a unique IP address, and that IP is a "best-effort" delivery service.
                This means that it has no guarantees on the integrity of data (or packet) transmission, nor does it guarantee the order of delivery of packets or segments.
            \subsubsection*{Data Encapsulation}
                For each layer, we have the following terminology - we can't refer to everything as packets;
                \begin{itemize}
                    \itemsep0em
                    \item application layer \hfill data
                    \item transport layer \hfill TCP segments or UDP datagrams
                        \subitem (TCP only) segmentation can be done when the segments are too large - if the UDP datagrams are too large, it cannot be sent
                    \item network / internet layer \hfill IP datagrams (or packets)
                        \subitem similarly, fragmentation can be done when the packets are too large
                    \item data link layer \hfill frames
                    \item physical layer \hfill bits
                \end{itemize}
            \subsubsection*{Ports}
                Note that it's possible for a client (one IP) to communicate with the same host (one IP) via multiple applications, such as HTTP and SMTP.
                Each application on ta host is identified with a unique port number - they can be thought of as cross-platform process identifiers.
                A socket consists of two pairs of ~ip\_address~ + ~port\_number~ + ~TCP/UDP~;
                such as
                \begin{center}
                    ~146.179.40.24:80 TCP~ $\Leftrightarrow$ ~192.168.1.1:7155 TCP~
                \end{center}
                The first 1024 ports (0 - 1023) are reserved, and cannot be used to form a connection as a client (unless it is done as a superuser).
            \subsubsection*{Transmission Control Protocol}
                TCP is the Internet's primary transport protocol.
                It is a connection-oriented service, and endpoints initially perform a handshake to establish a connection.
                This is a full-duplex service, thus both endpoints can send a receive at the same time.
                Some definitions for TCP are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{TCP segment} \hfill "envelope" for TCP data
                    \item \textbf{maximum segment size (MSS)}
                        \subitem maximum amount of application data transmitted in a single segment (does not include headers) - typically related to MTU to avoid network-level fragmentation
                    \item \textbf{maximum transmission unit (MTU)} \hfill largest link-layer frame available to the sender host
                        \subitem path MTU discovery (PMTUD) is used to determine the largest link-layer frame that can be sent on all links from the sender to the receiver
                \end{itemize}
                The TCP header consists of the following fields;
                \begin{itemize}
                    \itemsep0em
                    \item \violet{source and destination ports} \hfill 16-bit each (identifies applications)
                    \item \violet{sequence number} \hfill 32-bit (used to implement reliable data transfer)
                        \medskip

                        These numbers are not associated with the segments, but instead are associated with the bytes in the data stream.
                        It indicates the sequence number (the place) of the first byte carried by the TCP segment.
                        When the connection is initialised, a random ISN (initial sequence number) is decided upon to avoid accidentally receiving leftover segments.
                    \item \violet{acknowledgement number} \hfill 32-bit (used to implement reliable data transfer)
                        \medskip

                        Represents the first number not yet seen by the receiver (one higher than the sequence number of the last bit received).
                        These can be cumulative, and typically TCP implementations acknowledge every other packet;
                        \begin{center}
                            \begin{tikzpicture}[x=1.5cm, y=0.55cm]
                                \node at (4, -6) {$\vdots$};
                                \node at (0, 0.5) {~A~};
                                \node at (8, 0.5) {~B~};
                                \draw (0, 0) edge[->] (0, -7);
                                \draw (8, 0) edge[->] (8, -7);
                                \draw
                                (0, -1) edge[->, above] node{~[seq\#=1200,...], size(data) = 1000~} (8, -1)
                                (0, -3) edge[->, above] node{~[seq\#=2200,...], size(data) = 500~} (8, -3)
                                (8, -5) edge[->, above] node{~[seq\#=...,ack\#=2700]~} (0, -5);
                            \end{tikzpicture}
                        \end{center}
                        Note that because a TCP connection consists of a full-duplex link, there are two streams, hence two different sequence numbers (see the example below, of an "echo" application).
                        Acknowledgements are "piggybacked" on data segments.
                        \begin{center}
                            \begin{tikzpicture}[x=1.5cm, y=0.55cm]
                                \node at (4, -6) {$\vdots$};
                                \node at (0, 0.5) {~A~};
                                \node at (8, 0.5) {~B~};
                                \draw (0, 0) edge[->] (0, -8);
                                \draw (8, 0) edge[->] (8, -8);
                                \draw
                                (0, -1) edge[->, above] node{~[seq\#=100,data="C"]~} (8, -1)
                                (8, -3) edge[->, above] node{~[ack\#=101,seq\#=200,data="C"]~} (0, -3)
                                (0, -5) edge[->, above] node{~[seq\#=101,ack\#=201,data="i"]~} (8, -5)
                                (8, -7) edge[->, above] node{~[ack\#=201,seq\#=102,data="i"]~} (0, -7);
                            \end{tikzpicture}
                        \end{center}
                    \item receive window \hfill 16-bit (size of window on receiver end)
                    \item header length / offset \hfill 4-bit (size of TCP header in 32-bit words)
                    \item optional fields \hfill variable length (may be used to negotiate protocol parameters)
                    \item ~URG~ flag \hfill 1-bit (informs receiver some data is marked as urgent)
                    \item \violet{~ACK~ flag} \hfill 1-bit (value contained in the acknowledge number is a valid acknowledgement)
                        \medskip

                        See \textbf{acknowledgement number} above, and the \textbf{three-way handshake} section.
                    \item ~PSH~ flag \hfill 1-bit (solicit receiver to pass data to application immediately)
                    \item ~RST~ flag \hfill 1-bit (used during connection setup and shutdown)
                    \item \violet{~SYN~ flag} \hfill 1-bit (used during connection setup and shutdown)
                        \medskip

                        See the \textbf{three-way handshake} section below.
                    \item \violet{~FIN~ flag} \hfill 1-bit (used during connection shutdown)
                        \medskip

                        A client sends a TCP segment with ~FIN~ set, and the server responds with ~ACK~, and then the server sends a ~FIN~ TCP segment, client then responds with ~ACK~.
                        Closing a connection is simpler than initialising one.
                    \item \violet{checksum} \hfill 16-bit (used to detect transmission errors)
                \end{itemize}
            \subsubsection*{Three-Way Handshake}
                The three steps are as follows;
                \begin{enumerate}[1.]
                    \itemsep0em
                    \item \textbf{client} sends a TCP segment with ~SYN~ set, and an initial sequence number
                    \item \textbf{server} responds with another TCP segment with ~SYN~ set, as well as ~ACK~, the first unseen client sequence number, and the ISN for the server
                    \item \textbf{client} reserved with a TCP segment with ~ACK~ set, the first unseen server sequence number, and the client's new sequence number
                \end{enumerate}
                \begin{center}
                    \begin{tikzpicture}[x=1.5cm, y=0.55cm]
                        \node at (4, -6) {$\vdots$};
                        \node at (0, 0.5) {client};
                        \node at (8, 0.5) {server};
                        \draw (0, 0) edge[->] (0, -7);
                        \draw (8, 0) edge[->] (8, -7);
                        \draw
                        (0, -1) edge[->, above] node{~[SYN,seq\#=cli\_init\_seq]~} (8, -1)
                        (8, -3) edge[->, above] node{~[SYN,ACK,ack\#=cli\_init\_seq+1,seq\#=srv\_init\_seq]~} (0, -3)
                        (0, -5) edge[->, above] node{~[ACK,seq\#=cli\_init\_seq+1,ack\#=srv\_init\_seq+1]~} (8, -5);
                    \end{tikzpicture}
                \end{center}
            \subsubsection*{User Datagram Protocol}
                UDP only provides the two most basic functions of a transport protocol, which are application identification (multiplexing and demultiplexing), and an integrity check via a CRC-type checksum.
                There is no flow control, no error control, nor any retransmissions.
                The datagrams cannot be larger than 65K, there is no segmentation, and the router will just drop it.
                The 65K consists of 20B IP header, 8B UDP header, 65507B of data, coming to a total of 65535 bytes.
                In practice, only 500 to 1000 bytes are used (the smaller the datagram, the more likely it will arrive intact).
                \medskip

                Instead of just using IP, it adds port numbers on top of it, allowing us to differentiate between applications.
                This is a connection-less protocol, therefore there is no need to connect (just send the data) but each datagram packet must carry the full address and port of the recipient.
                The UDP header consists of the following fields;
                \begin{itemize}
                    \itemsep0em
                    \item source and destination ports \hfill 16-bit each
                    \item length of data \hfill 16-bit
                    \item checksum \hfill 16-bit
                \end{itemize}
                Any application where we care more about speed, we can use UDP, since it is generally faster (due to the lack of connection establishment), and also has a smaller packet overhead.
            \subsubsection*{Berkeley Socket Interface}
                The \textbf{Berkeley} socket interface is as follows;
                \begin{itemize}
                    \itemsep0em
                    \item ~SOCKET~ \hfill create a new communication endpoint
                    \item ~BIND~ \hfill attach a local address to a socket
                        \subitem the client and server each bind a transport-level address and a name to the locally created socket
                    \item ~LISTEN~ \hfill announce willingness to accept ~N~ connections
                        \subitem server starts listening on this socket, thus telling the kernel it will wait for connections from clients
                    \item ~ACCEPT~ \hfill block until a remote client wishes to establish a connection
                        \subitem this blocks the current thread, thus it is a synchronous operation
                        \subitem from here the server can accept or select connections from clients
                    \item ~CONNECT~ \hfill attempt to establish a connection
                        \subitem a client connects to the socket, it needs to provide the full transport-level address to locate the socket
                    \item ~SEND~ \hfill send data over a connection
                    \item ~RECEIVE~ \hfill receive data over a connection
                        \subitem now the client and server communicate through these operations on their respective sockets
                    \item ~CLOSE~ \hfill release the connection
                        \subitem end the communication, must be closed otherwise connections may be continued, and may run out of ports
                \end{itemize}
                \begin{center}
                    \begin{tikzpicture}[x=1.25cm, y=0.66cm]
                        \begin{scope}[shift={(0, 0)}]
                            \node at (1.5, 0.5) {server};
                            \node at (1.5, -0.5) {~SOCKET~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(0, -1.5)}]
                            \node at (1.5, -0.5) {~BIND~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(0, -3)}]
                            \node[violet] at (1.5, -0.5) {~LISTEN~};
                            \draw[violet] (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(0, -4.5)}]
                            \node[violet] at (1.5, -0.5) {~ACCEPT~};
                            \draw[violet] (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(0, -6)}]
                            \node at (1.5, -0.5) {~READ~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(0, -7.5)}]
                            \node at (1.5, -0.5) {~WRITE~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(0, -9)}]
                            \node at (1.5, -0.5) {~CLOSE~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \draw
                        (1.5, -1) -- (1.5, -1.5)
                        (1.5, -2.5) -- (1.5, -3)
                        (1.5, -4) -- (1.5, -4.5)
                        (1.5, -5.5) -- (1.5, -6)
                        (1.5, -7) -- (1.5, -7.5)
                        (1.5, -8.5) -- (1.5, -9)
                        (6.5, -1) -- (6.5, -4.5)
                        (6.5, -5.5) -- (6.5, -6)
                        (6.5, -7) -- (6.5, -7.5)
                        (6.5, -8.5) -- (6.5, -9)
                        (3, -5) edge[<->, dashed, violet] (5, -5)
                        (5, -6.5) edge[->] (3, -6.5)
                        (3, -8) edge[->] (5, -8)
                        (0, -8) edge[->, bend left=45] (0, -6.5)
                        (8, -8) edge[->, bend right=45] (8, -6.5);
                        \begin{scope}[shift={(5, 0)}]
                            \node at (1.5, 0.5) {client};
                            \node at (1.5, -0.5) {~SOCKET~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(5, -4.5)}]
                            \node[violet] at (1.5, -0.5) {~CONNECT~};
                            \draw[violet] (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(5, -6)}]
                            \node at (1.5, -0.5) {~WRITE~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(5, -7.5)}]
                            \node at (1.5, -0.5) {~READ~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(5, -9)}]
                            \node at (1.5, -0.5) {~CLOSE~};
                            \draw (0, 0) -- (3, 0) -- (3, -1) -- (0, -1) -- cycle;
                        \end{scope}
                    \end{tikzpicture}
                \end{center}
                Note that the part in \violet{violet} would not be present for UDP.
\end{document}