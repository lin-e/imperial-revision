\documentclass[a4paper, 12pt]{article}

% packages
\usepackage{amssymb}
\usepackage[fleqn]{mathtools}
\usepackage{tikz}
\usepackage{enumerate}
\usepackage{bussproofs}
\usepackage{xcolor}
\usepackage[margin=1.3cm]{geometry}
\usepackage{logicproof}
\usepackage{diagbox}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{lstautogobble}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{tipa}
\usepackage{pgfplots}

% tikz libraries
\usetikzlibrary{
    decorations.pathreplacing,
    arrows,
    shapes.gates.logic.US,
    circuits.logic.US,
    calc,
    automata,
    positioning,
    intersections
}

\pgfplotsset{compat=1.16}

\pgfmathdeclarefunction{gauss}{2}{%
  \pgfmathparse{1/(#2*sqrt(2*pi))*exp(-((x-#1)^2)/(2*#2^2))}%
}

\allowdisplaybreaks % allow environments to break
\setlength\parindent{0pt} % no indent

% shorthand for verbatim
% this clashes with logicproof, so maybe fix this at some point?
\catcode`~=\active
\def~#1~{\texttt{#1}}

% code listing
\lstdefinestyle{main}{
    numberstyle=\tiny,
    breaklines=true,
    showspaces=false,
    showstringspaces=false,
    tabsize=2,
    numbers=left,
    basicstyle=\ttfamily,
    columns=fixed,
    fontadjust=true,
    basewidth=0.5em,
    autogobble,
    xleftmargin=3.0ex,
    mathescape=true
}
\newcommand{\dollar}{\mbox{\textdollar}} %
\lstset{style=main}

% augmented matrix
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
\hskip -\arraycolsep
\let\@ifnextchar\new@ifnextchar
\array{#1}}
\makeatother

% ceiling / floor
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

% custom commands
\newcommand{\indefint}[2]{\int #1 \, \mathrm{d}#2}
\newcommand{\defint}[4]{\int_{#1}^{#2} #3 \, \mathrm{d}#4}
\newcommand{\pdif}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\dif}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}}
\newcommand{\limit}[2]{\raisebox{0.5ex}{\scalebox{0.8}{$\displaystyle{\lim_{#1 \to #2}}$}}}
\newcommand{\limitsup}[2]{\raisebox{0.5ex}{\scalebox{0.8}{$\displaystyle{\limsup_{#1 \to #2}}$}}}
\newcommand{\summation}[2]{\sum\limits_{#1}^{#2}}
\newcommand{\product}[2]{\prod\limits_{#1}^{#2}}
\newcommand{\intbracket}[3]{\left[#3\right]_{#1}^{#2}}
\newcommand{\laplace}{\mathcal{L}}
\newcommand{\fourier}{\mathcal{F}}
\newcommand{\mat}[1]{\boldsymbol{#1}}
\renewcommand{\vec}[1]{\boldsymbol{#1}}
\newcommand{\rowt}[1]{\begin{bmatrix}
    #1
\end{bmatrix}^\top}
\DeclareMathOperator*{\argmax}{argmax}
\DeclareMathOperator*{\argmin}{argmin}

\newcommand{\lto}[0]{\leadsto\ }

\newcommand{\ulsmash}[1]{\underline{\smash{#1}}}

\newcommand{\powerset}[0]{\wp}
\renewcommand{\emptyset}[0]{\varnothing}

\makeatletter
\newsavebox{\@brx}
\newcommand{\llangle}[1][]{\savebox{\@brx}{\(\m@th{#1\langle}\)}%
  \mathopen{\copy\@brx\kern-0.5\wd\@brx\usebox{\@brx}}}
\newcommand{\rrangle}[1][]{\savebox{\@brx}{\(\m@th{#1\rangle}\)}%
  \mathclose{\copy\@brx\kern-0.5\wd\@brx\usebox{\@brx}}}
\makeatother
\newcommand{\lla}{\llangle}
\newcommand{\rra}{\rrangle}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\crnr}[1]{\text{\textopencorner} #1 \text{\textcorner}}
\newcommand{\bnfsep}[0]{\ |\ }
\newcommand{\concsep}[0]{\ ||\ }

\newcommand{\axiom}[1]{\AxiomC{#1}}
\newcommand{\unary}[1]{\UnaryInfC{#1}}
\newcommand{\binary}[1]{\BinaryInfC{#1}}
\newcommand{\trinary}[1]{\TrinaryInfC{#1}}
\newcommand{\quaternary}[1]{\QuaternaryInfC{#1}}
\newcommand{\quinary}[1]{\QuinaryInfC{#1}}
\newcommand{\dproof}[0]{\DisplayProof}

\newcommand{\ttbs}{\char`\\}
\newcommand{\lrbt}[0]{\ \bullet\ }

% colours
\newcommand{\violet}[1]{\textcolor{violet}{#1}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\teal}[1]{\textcolor{teal}{#1}}

% reasoning proofs
\usepackage{ltablex}
\usepackage{environ}
\keepXColumns
\NewEnviron{reasoning}{
    \begin{tabularx}{\textwidth}{rlX}
        \BODY
    \end{tabularx}
}
\newcommand{\proofline}[3]{$(#1)$ & $#2$ & \hfill #3 \smallskip \\}
\newcommand{\proofarbitrary}[1]{& take arbitrary $#1$ \smallskip \\}
\newcommand{\prooftext}[1]{\multicolumn{3}{l}{#1} \smallskip \\}
\newcommand{\proofmath}[3]{$#1$ & = $#2$ & \hfill #3 \smallskip \\}
\newcommand{\prooftherefore}[1]{& $\therefore #1$ \smallskip \\}
\newcommand{\proofbc}[0]{\prooftext{\textbf{Base Case}}}
\newcommand{\proofis}[0]{\prooftext{\textbf{Inductive Step}}}

% ER diagrams
\newcommand{\nattribute}[4]{
    \node[draw, state, inner sep=0cm, minimum size=0.2cm, label=#3:{#4}] (#1) at (#2) {};
}
\newcommand{\mattribute}[4]{
    \node[draw, state, accepting, inner sep=0cm, minimum size=0.2cm, label=#3:{#4}] (#1) at (#2) {};
}
\newcommand{\dattribute}[4]{
    \node[draw, state, dashed, inner sep=0cm, minimum size=0.2cm, label=#3:{#4}] (#1) at (#2) {};
}
\newcommand{\entity}[3]{
    \node[] (#1-c) at (#2) {#3};
    \node[inner sep=0cm] (#1-l) at ($(#1-c) + (-1, 0)$) {};
    \node[inner sep=0cm] (#1-r) at ($(#1-c) + (1, 0)$) {};
    \node[inner sep=0cm] (#1-u) at ($(#1-c) + (0, 0.5)$) {};
    \node[inner sep=0cm] (#1-d) at ($(#1-c) + (0, -0.5)$) {};
    \draw
    ($(#1-c) + (-1, 0.5)$) -- ($(#1-c) + (1, 0.5)$) -- ($(#1-c) + (1, -0.5)$) -- ($(#1-c) + (-1, -0.5)$) -- cycle;
}
\newcommand{\relationship}[3]{
    \node[] (#1-c) at (#2) {#3};
    \node[inner sep=0cm] (#1-l) at ($(#1-c) + (-1, 0)$) {};
    \node[inner sep=0cm] (#1-r) at ($(#1-c) + (1, 0)$) {};
    \node[inner sep=0cm] (#1-u) at ($(#1-c) + (0, 1)$) {};
    \node[inner sep=0cm] (#1-d) at ($(#1-c) + (0, -1)$) {};
    \draw
    ($(#1-c) + (-1, 0)$) -- ($(#1-c) + (0, 1)$) -- ($(#1-c) + (1, 0)$) -- ($(#1-c) + (0, -1)$) -- cycle;
}

% AVL Trees
\newcommand{\avltri}[4]{
    \draw ($(#1)$) -- ($(#1) + #4*(0.5, -1)$) -- ($(#1) + #4*(-0.5, -1)$) -- cycle;
    \node at ($(#1) + #4*(0, -1) + (0, 0.5)$) {#3};
    \node at ($(#1) + #4*(0, -1) + (0, -0.5)$) {#2};
}

% RB Trees
\tikzset{rbtr/.style={inner sep=2pt, circle, draw=black, fill=red}}
\tikzset{rbtb/.style={inner sep=2pt, circle, draw=black, fill=black}}

% actual document
\begin{document}
    \section*{CO220 - Software Engineering Design}
        \subsection*{8th October 2019}
            \subsubsection*{Cost of Change}
                \begin{center}
                    \begin{tikzpicture}
                        \begin{axis}[
                            axis on top=true,
                            axis line style=thick,
                            no markers, domain=0:10, samples=50,
                            axis lines*=left, xlabel={time}, ylabel={cost of new features},
                            height=5cm, width=5cm,
                            enlargelimits=false,
                            xticklabels={,,},
                            yticklabels={,,}
                        ]
                            \addplot[mark=none, black, very thick, dotted] coordinates {(9, 0) (9, 729)};
                            \addplot[thick] {\x^3};
                            \addplot[violet, thick, ->] {250+\x^1.75*ln(\x)};
                        \end{axis}
                        \node[anchor=west] at (3.5, 3.5) {"ball of mud"};
                        \node[anchor=west] at (3.5, 1.4) {\violet{simple design}};
                    \end{tikzpicture}
                \end{center}
                The "project heat death", denoted by the dotted line, is where the cost of adding new features outweighs the value gained by adding those features.
                Note that the initial cost of doing a simple design can be more expensive (since it requires more planning).
            \subsubsection*{Elements of Simple Design}
                This is arranged in a pyramid on the slides (since they "build up on each other") but I will write it as a list, starting from the bottom;
                \begin{enumerate}[1.]
                    \itemsep0em
                    \item \textbf{behaves correctly}
                        \medskip

                        It doesn't matter if the codebase is well structured, or the code is elegant if it doesn't do the right thing (is buggy, or isn't what the customer wanted).
                        \begin{itemize}
                            \itemsep0em
                            \item automated testing
                            \item test-driven development
                            \item mock objects
                        \end{itemize}
                    \item \textbf{minimises duplication}
                        \medskip

                        If something needs to be changed in the future, and it's in multiple places, it will have to be changed in all of those places which will take longer.
                        Additionally, it's also easy to miss, causing bugs.
                    \item \textbf{maximises clarity}
                        \medskip

                        Code should be easy to modify, such that the parts that need to be changed can be easily located.
                        Important especially if working with others.
                    \item \textbf{has fewer elements}
                        \medskip

                        Less important - we want to focus on the previous levels first, and don't want to lose the benefits by combining elements.
                \end{enumerate}
            \subsubsection*{Test-Driven Development / Behaviour Driven Development}
                Having a test suite provides confidence that the codebase still works, even after major changes.
                \begin{center}
                    \begin{tikzpicture}[x=3cm]
                        \node (w) at (0, 0) {\shortstack{write a\\failing  test}};
                        \node (c) at (2, 0) {\shortstack{code to\\pass test}};
                        \node (r) at (1, -2) {refactor};
                        \draw
                        (w) edge[red, ->, bend left=20] (c)
                        (c) edge[green, ->, bend left=20] (r)
                        (r) edge[green, ->, bend left=20] (w);
                    \end{tikzpicture}
                \end{center}
                We start by writing failing tests, which seems counterintuitive, as there is no code to test.
                However, these tests are written as if the code was working - which gives us a specification on how the code \textbf{should} behave.
                We want to write code as quickly as possible that gets us from the \red{red} state (failing tests), to a \textcolor{green}{green} state (passing tests).
                This code is likely untidy - we can then tidy it up (which shouldn't break the tests).
                \medskip

                Additionally, it's not only about testing; we can replace the stages as follows;
                \begin{itemize}
                    \itemsep0em
                    \item API design \hfill (write a failing test)
                        \subitem "I wish there was a method that would take these parameters and do this"
                    \item internals design \hfill (code to pass test)
                        \subitem "Just making it work"
                    \item structural design \hfill (refactor)
                        \subitem "How can we improve the design?" (pyramid layers)
                \end{itemize}
                We focus more on what it should do (how it should behave), and not how it does it.
                For example, ~CustomerLookup~ should do the following;
                \begin{itemize}
                    \itemsep0em
                    \item finds customer by ID
                    \item fails for duplicate customers
                \end{itemize}
                The test is named as the expected result, and if it is true, then it behaves correctly.
                \begin{lstlisting}
                    public class CustomerLookupTest {
                      @Test
                      findsCustomerById() {
                        ...
                      }
                      @Test
                      failsForDuplicateCustomers() {
                        ...
                      }
                    }
                \end{lstlisting}
            \subsubsection*{Example of TDD}
                The object ~FibonacciSequence~ should do the following;
                \begin{itemize}
                    \itemsep0em
                    \item defines the first two terms to be one
                    \item has each term equal to the sum of the previous two
                    \item is not defined for negative terms
                \end{itemize}
                \begin{lstlisting}
                    ... // (FibonacciSequenceTest.java)

                    import static org.hamcrst.CoreMatchers.is;
                    import static org,junit.Assert.assertThat;

                    import org.junit.Test;

                    public class FibonacciSequenceTest {

                      @Test
                      public void definesFirstTwoTermsToBeOne() {
                        assertThat(new FibonacciSeqeunce().term(0), is(1));
                        assertThat(new FibonacciSeqeunce().term(1), is(1));
                      }
                    }
                \end{lstlisting}
                Obviously, none of this will work yet, as the code doesn't exist.
                However, we can use this to create the code as follows (this is incorrect, but our tests now pass);
                \begin{lstlisting}
                    ... // (FibonacciSequence.java)

                    public class FibonacciSequence {

                      public int term(int i) {
                        return 1;
                      }
                    }
                \end{lstlisting}
                We can then add more tests, which should now fail;
                \begin{lstlisting}
                    ... // (FibonacciSequenceTest.java)

                    public class FibonacciSequenceTest {
                      ...

                      @Test
                      public void hasEachTermTheSumOfPreviousTwo() {
                        assert(new FibonacciSeqeunce().term(2), is(2));
                        assert(new FibonacciSeqeunce().term(3), is(3));
                        assert(new FibonacciSeqeunce().term(4), is(5));
                      }
                    }
                \end{lstlisting}
                Similarly, we can modify the code again to add a naive implementation which performs it recursively;
                \begin{lstlisting}
                    ... // (FibonacciSequence.java)

                    public class FibonacciSequence {

                      public int term(int i) {
                        if (i < 2) {
                          return 1;
                        }
                        return term(i - 1) + term(i - 2);
                      }
                    }
                \end{lstlisting}
                Adding the last bullet point as a test;
                \begin{lstlisting}
                    ... // (FibonacciSequenceTest.java)

                    public class FibonacciSequenceTest {
                      ...

                      @Test
                      public void isNotDefinedForNegativeIndices() {
                        try {
                          new FibonacciSeqeunce().term(-1);
                          fail("should have thrown exception")
                        } catch (IllegalArgumentException iae) {
                          assertThat(iae.getMessage(), containsString("negative index"))
                        }
                      }
                    }
                \end{lstlisting}
                Fixing this, we add the following;
                \begin{lstlisting}
                    ... // (FibonacciSequence.java)

                    public class FibonacciSequence {

                      public int term(int i) {
                        if (i < 0) {
                          throw new IllegalArgumentException("negative index not supported");
                        }

                        ...
                      }
                    }
                \end{lstlisting}
                This is the only time I will actually write out every step, since that's the focus of TDD.
        \subsection*{11th October 2019}
            \subsubsection*{Feedback}
                Note that the names of the test files should be ~SomeObjectTest~, for ~SomeObject~.
                This convention allows the IDE to link the files, as well as having them in alphabetical order.
                Also always use a \textit{jUnit} library function;
                \begin{center}
                    ~assertThat(rul.size(), is(0))~ or ~assertEquals(0, rul.size())~

                    instead of

                    ~assert rul.size() == 0~
                \end{center}
                Generally make the LHS of fields the interface ~List~ instead of ~ArrayList~, and attempt to make it ~private~ and ~final~ (if possible).
                Additionally, any fields are reinitialised automatically by \textit{jUnit}, hence it doesn't need to be reset at the end of each test.
            \subsubsection*{Refactoring}
                This starts with multiple examples on handouts.
                As we're writing new code, we should look out for small changes that can improve the structure of our code.
                \medskip

                We can accumulate "technical debt" by writing code quickly to get a feature working, but we must fix it soon, otherwise it builds up leading to unhygienic code.
                \medskip

                Note that refactoring should be done with tools when possible (such as renaming identifiers), since the tool will be able to analyse the entire codebase to detect where changes need to be made.
                Behaviour should not be changed.
                \medskip

                The example after this is mostly using \textit{IntelliJ} tools wherever possible.
                One note to make is that sometimes it is helpful to get code into a state where it becomes similar enough to other parts of the code, to allow for the tool to do the work.
        \subsection*{15th October 2019}
            \subsubsection*{Sending Messages}
                Instead of considering how objects call methods, it may be beneficial to design how modules communicate with each other ("send messages").
                \medskip

                The idea is that when one object "sends a message", we don't really care how it does it, just that it performs the expected action.
            \subsubsection*{OOP}
                Typically, larger systems are built up of smaller units that work together.
                Some of these will be from the standard library, some of those will be written by us, and some others may be written by third parties.
                \begin{center}
                    \begin{tikzpicture}[x=2cm, y=2cm]
                        \draw[violet, dotted, very thick] (-0.375, 0.375) -- (1.375, 0.375) -- (1.375, -0.375) -- (-0.375, -0.375) -- cycle;
                        \draw[teal, dotted, very thick] (0.675, 0.375) -- (2.375, 0.375) -- (2.375, -0.375) -- (0.675, -0.375) -- cycle;
                        \draw[red, dotted, very thick] (-1.375, -0.625) -- (-0.625, -0.625) -- (-0.625, -1.375) -- (-1.375, -1.375) -- cycle;
                        \draw[blue, dotted, very thick] (0.5, 0.5) -- (1.5, 0.5) -- (1.5, -0.5) -- (0.5, -0.5) -- cycle;
                        \node[state, minimum size=1cm] (a) at (0, 0) {};
                        \node[state, minimum size=1cm] (b) at (1, 0) {};
                        \node[state, minimum size=1cm] (c) at (2, 0) {};
                        \node[state, minimum size=1cm] (d) at (-1, -1) {};
                        \node[state, minimum size=1cm] (e) at (1, -1.5) {};
                        \node[state, minimum size=1cm] (f) at (2, -1) {};
                        \draw
                        (-1, 0) edge[->, dashed] (a)
                        (a) edge[->] (b)
                        (a) edge[->] (d)
                        (b) edge[->, bend left=20] (c)
                        (b) edge[->] (f)
                        (c) edge[->, bend left=20] (b)
                        (e) edge[->, dashed] (0, -1.5)
                        (e) edge[->, dashed] (0.5, -2.1)
                        (f) edge[->] (e)
                        (f) edge[->, dashed, bend left=20] (3.1, -1.9)
                        (2.9, -2.1) edge[->, dashed, bend left=20] (f);
                    \end{tikzpicture}
                \end{center}
                However, these components should be reusable, and they can be combined in a different way if needed (we can't really modify code in the standard library, etc).
                We want to have the possibility to swap out parts of the project without affecting other objects.
                The system shouldn't care how the object does a job, just that it does it.
                \begin{itemize}
                    \itemsep0em
                    \item \violet{\textbf{commands}} \hfill "please do $X$"
                        \medskip

                        This doesn't wait for a response, or a even a return value.
                    \item \teal{\textbf{queries}} \hfill "please tell me $Y$"
                        \medskip

                        Requests a bit of data, and then processes it.
                        If too many queries are used, we tend to have a central part of the process that deals with all the information which isn't flexible.
                        Ideally jobs are delegated to different components.
                    \item \red{\textbf{value objects}}
                        \medskip

                        These don't typically interact with other objects, and just holds some data and performs some computations.
                        These components can easily be tested.
                    \item \blue{\textbf{tell don't ask}}
                        \medskip

                        The role of this object is to coordinate other objects in the system.
                        Focusing on commands tends to give us more flexibility, but leads to different testing approaches.
                \end{itemize}
                Typically, asking looks like the following (can be characterised by a higher number of ~getX()~s);
                \begin{lstlisting}
                    table.getGrid().getColumnModel().getColumn(index).setPreferredWidth(newWidth);
                \end{lstlisting}
                Visually, the graph becomes something similar to this;
                \begin{center}
                    \begin{tikzpicture}[x=2cm, y=2cm]
                        \node[red, state, minimum size=1cm] (a) at (0, 0) {};
                        \node[red, state, minimum size=1cm] (b) at (1, 0) {};
                        \node[state, minimum size=1cm] (c) at (2, 0) {};
                        \node[state, minimum size=1cm] (d) at (-1, -1) {};
                        \node[state, minimum size=1cm] (e) at (1, -1.5) {};
                        \node[red, state, minimum size=1cm] (f) at (2, -1) {};
                        \draw
                        (-1, 0) edge[red, ->, dashed] (a)
                        (-1, 0) edge[red, ->, dashed, bend right=30] (b)
                        (-1, 0) edge[red, ->, dashed, bend right=20] (f)
                        (a) edge[->] (b)
                        (a) edge[->] (d)
                        (b) edge[->, bend left=20] (c)
                        (b) edge[->] (f)
                        (c) edge[->, bend left=20] (b)
                        (e) edge[->, dashed] (0, -1.5)
                        (e) edge[->, dashed] (0.5, -2.1)
                        (f) edge[->] (e)
                        (f) edge[->, dashed, bend left=20] (3.1, -1.9)
                        (2.9, -2.1) edge[->, dashed, bend left=20] (f);
                    \end{tikzpicture}
                \end{center}
            \subsubsection*{Testing Objects and Roles}
                When we want to test a given object, let it be $O$, we shouldn't have to implement the objects it depends on first.
                To do this, we use interfaces in Java to represent roles - which specifies what $O$ expects the other objects to do.
                An object may play different roles (hence implement multiple interfaces).
                \begin{center}
                    \begin{tikzpicture}
                        \node[state, minimum size=1cm] (a) at (0, 0.5) {$O$};
                        \node[state, minimum size=1cm] at (4, 1) {};
                        \node[state, minimum size=1cm] at (4, -1) {};
                        \draw[black, domain=180:270] plot ({4 + 0.6*cos(\x)}, {1 + 0.6*sin(\x)});
                        \draw[black, domain=90:180] plot ({4 + 0.6*cos(\x)}, {-1 + 0.6*sin(\x)});
                        \draw (a) edge[->, bend left=15] (3.5, -0.5);
                        \draw (a) edge[->] (3.5, 0.5);
                    \end{tikzpicture}
                \end{center}
                The object $O$ is the one we wish to test, and should be triggered by a call in the test suite.
            \subsubsection*{Mock Objects}
                To test objects that rely on stuff other objects that haven't been implemented yet (only an interface exists), we can use mock objects.
                \begin{center}
                    \begin{tikzpicture}
                        \node[state, minimum size=1cm] (a) at (0, 0.5) {$O$};
                        \node[violet, dashed, state, minimum size=1cm] (b) at (4, 1) {};
                        \node[violet, dashed, state, minimum size=1cm] (c) at (4, -1) {};
                        \draw[black, domain=180:270] plot ({4 + 0.6*cos(\x)}, {1 + 0.6*sin(\x)});
                        \draw[black, domain=90:180] plot ({4 + 0.6*cos(\x)}, {-1 + 0.6*sin(\x)});
                        \draw (a) edge[->, bend left=15] (3.5, -0.5);
                        \draw (a) edge[->] (3.5, 0.5);

                        \node[violet] at (2, -2.5) {test};
                        \draw[violet] (1, -2) -- (3, -2) -- (3, -3) -- (1, -3) -- cycle;
                        \draw[violet]
                        (1, -2.5) edge[->, bend left=30] (a)
                        (3, -2.5) edge[->, bend right=15] (7, -1.5)
                        (6, -1) edge[<->, bend right=10] (c)
                        (7, -0.5) edge[<->, bend right=10] (b);
                        \node[violet] at (7, -1) {mockery};
                        \draw[violet] (6, -0.5) -- (8, -0.5) -- (8, -1.5) -- (6, -1.5) -- cycle;
                    \end{tikzpicture}
                \end{center}
                When a test is run, we can test if $O$ sends messages to the mock objects.
                Instead of writing assertions about the state of $O$, we can write expectations for what should be called.
                \medskip

                An example is as follows (this is syntax from \textit{WebSequenceDiagrams}, because I don't want to draw it out);
                \begin{lstlisting}
                    Waiter->HeadChef: order(CHICKEN, APPLE)
                    HeadChef->PastryChef: order(APPLE)

                    Waiter->HeadChef: customerReadyFor(APPLE)
                    HeadChef->PastryChef: isCooked(APPLE)
                    PastryChef-->HeadChef: True
                    HeadChef->Waiter: serve(APPLE)

                    Waiter->HeadChef: customerReadyFor(APPLE)
                    HeadChef->PastryChef: isCooked(APPLE)
                    PastryChef-->HeadChef: False
                \end{lstlisting}
                In Java, we have the following for the tests;
                \begin{lstlisting}
                    ... // (HeadChefTest.java)

                    public class HeadChefTest {

                      @Rule
                      public JUnitRuleMockery context = new JUnitRuleMockery();

                      public final Order APPLE_TART = new Order("apple");
                      public final Order ROAST_CHICKEN = new Order("chicken");

                      Chef pastryChef = context.mock(Chef.class);
                      RestaurantWaiter waiter = context.mock(RestaurantWaiter.class);

                      @Test
                      public void delegatesDessertToPastryChef() {

                        HeadChef headChef = new HeadChef(pastryChef, waiter);

                        context.checking(new Expectations() {{
                          exactly(1).of(pastryChef).order(APPLE_TART);
                        }});

                        headChef.order(ROAST_CHICKEN, APPLE_TART);
                      }

                      @Test
                      public void asksWaiterToServeDessertIfCooked() {

                        HeadChef headChef = new HeadChef(pastryChef, waiter);

                        context.checking(new Expectations() {{
                          exactly(1).of(pastryChef).isCooked(APPLE_TART); will(returnValue(true));
                          exactly(1).of(waiter).serve(APPLE_TART);
                        }});

                        headChef.customerReadyFor(APPLE_TART);
                      }

                      @Test
                      public void doesNotAskWaiterToServeDessertIfNotCooked() {

                        HeadChef headChef = new HeadChef(pastryChef, waiter);

                        context.checking(new Expectations() {{
                          exactly(1).of(pastryChef).isCooked(APPLE_TART); will(returnValue(false));
                          never(waiter).serve(APPLE_TART);
                        }});

                        headChef.customerReadyFor(APPLE_TART);
                      }
                    }
                \end{lstlisting}
                Similarly for the ~HeadChef~;
                \begin{lstlisting}
                    ... // (HeadChef.java)

                    public class HeadChef {

                      private final Chef pastryChef;
                      private final RestaurantWaiter waiter;

                      public HeadChef(Chef pastryChef, RestaurantWaiter waiter) {
                        this.pastryChef = pastryChef;
                        this.waiter = waiter;
                      }

                      public void order(Order main, Order dessert) {
                        pastryChef.order(dessert);
                      }

                      public void customerReadyFor(Order dessert) {
                        if (pastryChef.isCooked(dessert)) {
                          waiter.serve(dessert);
                        }
                      }
                    }
                \end{lstlisting}
                Note that we have \textbf{interfaces} for ~Chef~ and ~RestaurantWaiter~, as they aren't implemented;
                \begin{lstlisting}
                    ... // (Chef.java)

                    public interface Chef {
                      void order(Order order);

                      bool isCooked(Order order);
                    }
                \end{lstlisting}
                \begin{lstlisting}
                    ... // (RestaurantWaiter.java)

                    public interface RestaurantWaiter {
                        void serve(Order order);
                    }
                \end{lstlisting}
        \subsection*{18th October 2019}
            \subsubsection*{Feedback}
                We only want to test each behaviour once, to avoid breaking tests elsewhere.
                Note that \textit{jMock} is more strict than \textit{Mockito}.
                Additionally, if we are expecting the same value in the behaviour, we don't have to make a new mock object if it won't be tested (hence we can just create a constant field).
                \begin{lstlisting}
                    ... // (CameraTest.java)

                    public class CameraTest {
                      ...

                      private static final byte[] PHOTO = new byte[8];
                      ...

                      @Test
                      public void switchingTheCameraOffPowersDownTheSensor() {

                        context.checking(new Expectations() {{
                          ignoring(sensor).powerUp();
                          exactly(1).of(sensor).powerDown();
                        }});

                        camera.powerOn();
                        camera.powerOff();
                      }

                      @Test
                      public void pressingTheShutterCopiesData() {

                        context.checking(new Expectations() {{
                          ignoring(sensor).powerUp();
                          exactly(1).of(sensor).readData(); will(returnValue(PHOTO));
                          exactly(1).of(memoryCard).write(PHOTO);
                        }});

                        camera.powerOn();
                        camera.pressShutter();
                      }
                    }
                \end{lstlisting}
            \subsubsection*{Designing for Flexibility}
                Bad design consists of the following properties;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{rigidity} \hfill difficult to change, possibly due to complex code (long methods, deep conditions etc.)
                    \item \textbf{fragility} \hfill making a change in one place could break another part of the code
                    \item \textbf{immobility} \hfill difficult to reuse code in another context
                \end{itemize}
            \subsubsection*{Law of Demeter}
                Recall the graph that had many ~getX()~s, the red lines reached across the graph, but the law of Demeter states that access should generally be to an object that is one "hop" away.
                This preserves flexibility.
                Violating this can cause fragility, as changing one part of the code could affect another part of the code that is far away.
                \medskip

                We can perform the following steps to extract a "trainwreck" into a method, which is then put into the next object down the "chain" of ~getX()~s.
                \begin{center}
                    \begin{tikzpicture}
                        \draw
                        (4, -0.5) edge[->, dashed] (7, -0.5)
                        (4, -2.5) edge[->, dashed] (7, -2.5)
                        (9, -1) edge[->] (9, -2)
                        (9, -3) edge[->] (9, -4)
                        (9, -5) edge[->] (9, -6)
                        (9, -7) edge[->] (9, -8);
                        \begin{scope}[shift={(0, 0)}]
                            \node at (2, -0.5) {\shortstack{trainwreck assigned\\to variable}};
                            \draw[dashed] (0, 0) -- (4, 0) -- (4, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(0, -2)}]
                            \node at (2, -0.5) {\shortstack{free trainwreck\\expression}};
                            \draw[dashed] (0, 0) -- (4, 0) -- (4, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(7, 0)}]
                            \node at (2, -0.5) {inline variable};
                            \draw (0, 0) -- (4, 0) -- (4, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(7, -2)}]
                            \node at (2, -0.5) {\shortstack{extract method for\\affect statements}};
                            \draw (0, 0) -- (4, 0) -- (4, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(7, -4)}]
                            \node at (2, -0.5) {\shortstack{introduce parameters\\for members}};
                            \draw (0, 0) -- (4, 0) -- (4, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(7, -6)}]
                            \node at (2, -0.5) {\shortstack{move method onto\\target object}};
                            \draw (0, 0) -- (4, 0) -- (4, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(7, -8)}]
                            \node at (2, -0.5) {rename new method};
                            \draw (0, 0) -- (4, 0) -- (4, -1) -- (0, -1) -- cycle;
                        \end{scope}
                    \end{tikzpicture}
                \end{center}
            \subsubsection*{Defending against Null Pointer Exceptions}
                The following snippet of code has lines 3 and 5 added to protect against NPEs - however if this is needed frequently it could lead to code duplication;
                \begin{lstlisting}
                    void playTrack(String name) {
                      Track track = library.getTrack(name);
                      if (track != null) {
                        track.play();
                      }
                    }
                \end{lstlisting}
                Another approach is to have the \textbf{null object pattern}, which is an empty implementation;
                \begin{lstlisting}
                    interface Track {
                      public void play();
                    }

                    class NullTrack implements Track {
                      public void play() {
                        // do nothing
                      }
                    }
                \end{lstlisting}
                As a development team, it makes sense to agree on what will be done, whether it be using the null object pattern, or using Java's ~Optional~s.
            \subsubsection*{Coupling and Cohesion}
                \begin{itemize}
                    \itemsep0em
                    \item aim for \textbf{low coupling} between classes \hfill changing one part requires a change in the other
                    \item aim for \textbf{high cohesion} within each class \hfill a class should be specialised (less changes needed)
                \end{itemize}
                Ideally, we want to limit the "blast radius" of our changes, which is the amount of code we affect to just parts managed by us.
            \subsubsection*{Approaches}
                One extreme is to store all of the code in a single repository, allowing changes to be made when needed (given approval), which is done by Google.
                This has the benefit that a part can be changed in part of the code, and can also be fixed in another.
                However, due to the ability to affect other unrelated parts of the codebase, it can also lead to issues when updating a core object.
                \medskip

                The other extreme is to have modular code, which is individually versioned.
                That way, if something is updated, other modules can use older versions and update when needed (which doesn't break functionality straight away).
                However, updates will need to be done quite frequently, otherwise other modules will be behind.
                It's also difficult to make changes in other parts.
        \subsection*{22nd October 2019}
            \subsubsection*{Motivation}
                This focuses mostly on the middle two layers in the pyramid mentioned in the first lecture.
                We assume that the code is working correctly, and we can check that the code is working correctly with the test suite.
            \subsubsection*{Example}
                ~ReverseEncoder~ is an encoder for encryption, which reverses each word in the input (such that ~"abc 123"~ becomes ~"cba 321"~).
                This will be done in Python;
                \begin{lstlisting}
                    class ReverseEncoder:
                      def encode(self, line):
                        words = line.split(" ")
                        results = []
                        for word in words:
                          results.append(word[::-1])
                        return " ".join(results)
                \end{lstlisting}
                Now suppose we have another encoder, ~DoublingEncoder~, that repeats each word in the input (such that ~"abc 123"~ becomes ~"abcabc 123123"~).
                This can easily be implemented as follows;
                \begin{lstlisting}
                    class DoublingEncoder:
                      def encode(self, line):
                        words = line.split(" ")
                        results = []
                        for word in words:
                          results.append(word + word)
                        return " ".join(results)
                \end{lstlisting}
                However, notice that there is a significant amount of duplication, as essentially all lines are the same, other than line 6.
                To remedy this, we can add an ~Encoder~ class which they both extend;
                \begin{lstlisting}
                    from abc import abstractmethod

                    class Encoder:
                      def encode(self, line):
                        words = line.split(" ")
                        results = []
                        for word in words:
                          results.append(self.encode_word(word))
                        return " ".join(results)

                      @abstractmethod
                      def encode_word(self, word):
                        pass

                    class ReverseEncoder(Encoder):
                      def encode_word(self, word):
                        return word[::-1]

                    class DoublingEncoder(Encoder):
                      def encode_word(self, word):
                        return word + word
                \end{lstlisting}
                Now, everything that is common to the two algorithms is in the superclass, and only the part that is specialised is each individual class.
            \subsubsection*{Template Method Pattern}
                The template method pattern is used when requirements change over time, and we need to vary a small part of an algorithm.
                A skeleton should be defined (our ~Encoder~ in the example above), and the vary steps should be deferred to subclasses (~ReverseEncoder~, and ~DoublingEncoder~).
                \begin{center}
                    Separate things that change from things that stay the same.
                \end{center}
                Generally, this has the following pattern, where the specialised \teal{hook methods} are overwritten by the \blue{inheriting} classes, and the \violet{template method} contains the shared behaviour;
                \begin{center}
                    \begin{tikzpicture}[x=1.5cm, y=0.75cm]
                        \begin{scope}[shift={(0, 0)}]
                            \node at (2, -0.5) {~AbstractClass~};
                            \node[anchor=west] at (0.5, -2) {\shortstack[l]{\violet{~templateMethod()~}\\\teal{~operation1()~}\\\teal{~operation2()~}}};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(-3, -5)}]
                            \node at (2, -0.5) {~ConcreteClass1~};
                            \node[anchor=west] at (0.5, -2) {\shortstack[l]{~operation1()~\\~operation2()~}};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(3, -5)}]
                            \node at (2, -0.5) {~ConcreteClass2~};
                            \node[anchor=west] at (0.5, -2) {\shortstack[l]{~operation1()~\\~operation2()~}};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \draw
                        (-1, -5) -- (-1, -4) -- (5, -4) -- (5, -5)
                        (2, -4) edge[->, blue] (2, -3);
                    \end{tikzpicture}
                \end{center}
                This follows the \textbf{open-closed principle}, where we can extend the class' behaviour without modifying it, as we can just add a new subclass.
                We therefore don't have to edit code, which may have lead to bugs, as we are safer by just adding code.
                Modules should be open for extension, but closed to modification.
                Change behaviour by adding new code, not by changing existing code.
            \subsubsection*{Coupling Metrics}
                Afferent coupling (Ca) - remember this as how many arrows \textbf{a}rrive - a class' afferent couplings is a measure of it's responsibility (how many other classes use it).
                Efferent coupling (Ce) - remember this as how many arrows \textbf{e}xit - it's a measure of how many different classes are used by this specific class (measures independence).
                \medskip

                For example, the ~ReverseEncoder~ cannot really be used elsewhere, as it has a strong coupling with the ~Encoder~ superclass.
                In general, we may want to avoid this coupling.
            \subsubsection*{Strategy Pattern}
                An alternative is the template method (still done for the same reason) is to delegate to a collaborator (instead of a subclass) - the algorithm should be pulled into a separate object.
                This favours object composition over class inheritance.
                \begin{center}
                    \begin{tikzpicture}[x=1.5cm, y=0.75cm]
                        \begin{scope}[shift={(-5, 0)}]
                            \node at (2, -0.5) {~Context~};
                            \node[anchor=west] at (0.5, -2) {~strategy~};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(0, 0)}]
                            \node at (2, -0.5) {~Strategy~};
                            \node[anchor=west] at (0.5, -2) {~operation()~};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(-3, -5)}]
                            \node at (2, -0.5) {~Strategy1~};
                            \node[anchor=west] at (0.5, -2) {~operation()~};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(3, -5)}]
                            \node at (2, -0.5) {~Strategy2~};
                            \node[anchor=west] at (0.5, -2) {~operation()~};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \node[violet] at (6, -2) (i) {interface};
                        \draw
                        (i) edge[->, violet, bend right=20] (4, -0.5)
                        (-1, -2) edge[->] (0, -2)
                        (-1, -5) -- (-1, -4) -- (5, -4) -- (5, -5)
                        (2, -4) edge[->, blue] (2, -3);
                    \end{tikzpicture}
                \end{center}
                It's important to note that ~Strategy~ is an interface, hence ~Strategy1~ and ~Strategy2~ implement it.
                The example can be modified as follows;
                \begin{lstlisting}
                    from abc import abstractmethod

                    class Encoder:
                      def __init__(self, encryptor):
                        self.encryptor = encryptor

                      def encode(self, line):
                        words = line.split(" ")
                        results = []
                        for word in words:
                          results.append(self.encryptor.encode_word(word))
                        return " ".join(results)

                    class Reverser:
                      def encode_word(self, word):
                        return word[::-1]

                    class Doubler:
                      def encode_word(self, word):
                        return word + word
                \end{lstlisting}
                The main sign is that the strategy is passed in to the context; hence we would have;
                \begin{center}
                    ~Encoder(Reverser()).encode("...")~
                \end{center}
                As the ~Reverser~ and ~Doubler~ no longer have a relationship with ~Encoder~, we have must less coupling, hence we have better mobility and flexibility.
                Generally, composition should be preferred over inheritance.
        \subsection*{25th October 2019}
            \subsubsection*{Stability}
                If a core object, such as a ~Customer~ class, has many things depending on it, such that it has a high afferent coupling, it can be a benefit since it can be heavily reused.
                However, it needs to be very stable, and require little to no changing, as changing it can break other parts of the codebase if done incorrectly.
                It should rely on very few other objects (if any).
                These are represented by the \teal{\textbf{teal}} nodes below.
                \medskip

                On other hand, the components at the edges (the ones in \textbf{\violet{violet}}), can include UI components, such as a dashboard.
                It makes sense for the dashboard to depend on the ~Customer~ class, but not the other way around.
                These can be changed fairly easily, as not many things depend on it.
                \begin{center}
                    \begin{tikzpicture}[y=0.75cm]
                        \node[inner sep=10pt, circle, draw=black, fill=teal] (t1) at (0, 0) {};
                        \node[inner sep=6pt, circle, draw=black, fill=teal] (t2) at (-2, -1) {};
                        \node[inner sep=6pt, circle, draw=black, fill=violet] (p1) at (-3, 0) {};
                        \node[inner sep=6pt, circle, draw=black, fill=violet] (p2) at (-2, 1) {};
                        \node[inner sep=6pt, circle, draw=black, fill=violet] (p3) at (-3, -2) {};
                        \node[inner sep=6pt, circle, draw=black, fill=violet] (p4) at (1, -2) {};
                        \node[inner sep=6pt, circle, draw=black, fill=violet] (p5) at (3, 0) {};
                        \node[inner sep=6pt, circle, draw=black, fill=violet] (p6) at (2, 1) {};
                        \node[inner sep=6pt, circle, draw=black, fill=violet] (p7) at (2, -1) {};
                        \draw
                        (t2) edge[->] (t1)
                        (p2) edge[->] (t1) (p2) edge[->] (t2) (p2) edge[->] (p1)
                        (p3) edge[->] (t2)
                        (p4) edge[->] (t1) (p4) edge[->] (t2) (p4) edge[->] (p3)
                        (p5) edge[->] (t1)
                        (p6) edge[->] (t1)
                        (p7) edge[->] (t1);
                    \end{tikzpicture}
                \end{center}
            \subsubsection*{Complexity Metrics}
                Some methods for quantifying the complexity of a program are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{cyclomatric (McCabe)}
                        \medskip

                        Described in McCabe's paper, it counts the possible different executions that could happen, and gives a lower bound on the number of tests required for a particular unit.
                    \item \textbf{WILT (Whitespace Integrated over Lines of Text)}
                        \medskip

                        Integrates over the indented area of a given piece of code - this has a correlation with the McCabe complexity, but is much easier to calculate.
                    \item \textbf{ABC (Assignments, Branches, and Conditions)}
                        \medskip

                        Every time it encounters each of the following constructs, it increments a counter by some number.
                        This isn't as accurate as McCabe, but gives an approximation.
                        For example, \textit{Flog} is an ABC metric with specialist knowledge of Ruby;
                        \begin{lstlisting}
                            def blah         # 11.2 total
                              a = eval "1+1" # 1.2 (a=) + 6.0 (eval) +

                              if a == 2      # 1.2 (if) + 1.2 (==) + 0.4 (fixnum) +
                                puts "yay"   # 1.2 (puts)
                              end
                            end
                        \end{lstlisting}
                \end{itemize}
                I honestly have no idea what this lecture is supposed to be going through.
                Generally, we should look at the trends for the complexity of code, rather than ensuring it is monotonically improving.
            \subsubsection*{Turbulence}
                If we plot complexity against commits (number of changes), we can divide it into 4 general quadrants.
                Something that is high complexity, but has low commits, probably doesn't need to be refactored as we aren't modifying it often.
                This could be an algorithm copied from an academic paper, or a third party library being imported.
                The quadrant with low complexity and high commits could include configuration files, which are modified frequently.
                \medskip

                The top right quadrant, which has high complexity and high commits should be a cause for concern.
                This is likely to introduce bugs as it is being changed often, and has high complexity.
        \subsection*{29th October 2019}
            \subsubsection*{Factory Method Pattern}
                Factory methods (along with objects) allow for more flexibility and clarity with regards to object creation.
                Factory methods can have names unlike constructors.
                Note that the example on line 5 should be motivation to use factory methods, as it has less clarity, compared to the line above.
                By doing this, we can also close off some options by not exposing the constructor.
                \begin{lstlisting}
                    List<Object> l = Collections.emptyList();
                    Boolean b = Boolean.valueOf("true");
                    ExecutorService es = Executors.newFixedThreadPool(4);
                    VirtualMachine vm1 = VirtualMachine.withHardDiskGigabytes(128);
                    // VirtualMachine vm2 = new VirtualMachine(2, 512, 128);
                \end{lstlisting}
                The ~VirtualMachine~ example can be done as follows;
                \begin{lstlisting}
                    class VirtualMachine {

                      private final int cores;
                      private final int ram;
                      private final int disk;
                      private final int costPerMin;
                      ...

                      // factory methods are static
                      public static VirtualMachine withHardDiskGigabytes(int size) {
                        return new VirtualMachine(4, 128, size);
                      }

                      // private constructors force callers to use the factory methods
                      private VirtualMachine(int cores, int ram, int disk) {
                        this.cores = cores;
                        this.ram = ram;
                        this.disk = disk;
                        this.costPerMin = (cores * ram + disk) / 50;
                        ...
                      }
                    }
                \end{lstlisting}
            \subsubsection*{Factory Objects}
                Sometimes, we don't know what we want to display until run-time (and therefore can't put it in directly) - as such, factory objects can decide what to return at run-time (example for some UI);
                \begin{lstlisting}
                    class LogoFactory {

                      // can return any sub-type of Logo
                      static Logo createLogo() {
                        if (config.country().equals(Country.UK)) {
                          return new FlagLogo("UK");
                        }
                        if (config.country().equals(Country.USA)) {
                          return new FlagLogo("US");
                        }
                        return new DefaultLogo();
                      }

                      class FlagLogo implements Logo { ... }
                      class DefaultLogo implements Logo { ... }
                    }
                \end{lstlisting}
                Therefore, when we need the logo, we can call ~LogoFactory.createLogo()~ to obtain the appropriate one.
                Additionally, if we want to add a new logo, it only needs to be modified in one place.
            \subsubsection*{Abstract Factory Pattern}
                This is less frequently used.
                It's an interface of a factory, thus all implementations of it are factories.
                \begin{lstlisting}
                    interface WidgetFactory {
                      Widget createScrollBar();
                      Widget createMenu();
                      ...
                    }

                    class MobileWidgetFactory implements WidgetFactory {

                      @Override
                      public Widget createScrollBar() {
                        return new MobileScrollBar(Color.GREEN);
                      }

                      @Override
                      public Widget createMenu() {
                        return new MobileMenu(5);
                      }
                      ...
                    }

                    class DesktopWidgetFactory implements WidgetFactory {

                      @Override
                      public Widget createScrollBar() {
                        ...
                      }
                      ...
                    }
                \end{lstlisting}
                This can help maintain consistency (such that we don't get a ~MobileScrollBar~ when building a desktop UI, etc).
            \subsubsection*{Builder Pattern}
                Separate the construction of a complex object, likely with many parameters, from its representation.
                We also want the object to be in a "usable state" once it is first constructed, such that we don't have a transitionary state.
                An example is as follows;
                \begin{lstlisting}
                    public class BananaBuilder {

                      private double ripeness = 0.0;
                      private double curve = 0.5;

                      // ensures the builder itself is created with factory method
                      private BananaBuilder() { }

                      public static BananaBuilder aBanana() {
                        return new BananaBuilder();
                      }

                      public Banana build() {
                        Banana banana = new Banana(curve);
                        banana.ripen(ripeness);
                        return banana;
                      }

                      public BananaBuilder withRipeness(double ripeness) {
                        this.ripeness = ripeness;
                        return this;
                      }

                      public BananaBuilder withCurve(double curve) {
                        this.curve = curve;
                        return this;
                      }
                    }
                \end{lstlisting}
                Note that the configuration methods return ~this~ (and is mutable), which gives a fluent interface allowing for method chaining.
                The builder can be used as follows;
                \begin{lstlisting}
                    import static BananaBuilder.*

                    public class FruitBasket {
                      ...

                      public FruitBasket() {
                        Banana banana = aBanana().withRipeness(2.0).withCurve(0.9).build();
                        ...
                      }
                    }
                \end{lstlisting}
                The ~build()~ method also allows us to validate the parameters (which can also have default values).
            \subsubsection*{Singleton Pattern}
                We often do not need this pattern, and it can be troublesome when misused.
                The singleton pattern ensures a class only has one instance, and there is a global point of access - this is typically when instantiating the object has a high cost (high memory cost, actual fee, etc).
                An example of this is as follows;
                \begin{lstlisting}
                    public class BankAccountStore {

                      // static initialisation runs when class loaded
                      private static BankAccountStore instance = new BankAccountStore();

                      private Collection<BankAccount> accounts;

                      // private constructor ensures no-one can create a new instance
                      private BankAccountStore() {
                        ...
                      }

                      // getInstance() is called to gain access to the global instance
                      public static BankAccountStore getInstance() {
                        return instance;
                      }

                      public BankAccount lookupAccountById(int id) {
                        ...
                      }
                      ...
                    }
                \end{lstlisting}
                The example above is an eager initialisation, which could be wasteful if it has a high cost to initialise, but no one actually needs it;
                \begin{lstlisting}
                    public class BankAccountStore {

                      // no initialisation when class loaded
                      private static BankAccountStore instance;

                      private Collection<BankAccount> accounts;

                      // private constructor ensures no-one can create a new instance (expensive)
                      private BankAccountStore() {
                          ...
                      }

                      // getInstance() is called to gain access to the global instance
                      public static synchronized BankAccountStore getInstance() {
                        if (instance == null) {
                          instance = new BankAccountStore();
                        }
                        return instance;
                      }

                      public BankAccount lookupAccountById(int id) {
                        ...
                      }
                      ...
                    }
                \end{lstlisting}
                Note that we have made the method thread-safe to avoid the race condition where multiple threads attempt to create instances simultaneously.
            \subsubsection*{Dependencies}
                Note that in the example below, we have a strong coupling between a ~PushSwitch~ and a ~Light~.
                This means that we cannot really test the switch independently of the light - which we want to avoid.
                Additionally, we cannot use this switch for another device, if required.
                \begin{lstlisting}
                    class Light:
                      def on(self):
                        print("Shining")

                      def off(self):
                        print("Dark")

                    class PushSwitch:
                      def __init__(self):
                        self.light = Light();
                        self.on = False

                      def press(self):
                        self.on = not self.on
                        if self.on:
                          self.light.on()
                        else
                          self.light.off()

                    switch = PushSwitch()
                \end{lstlisting}
                The fix for this is following the \textbf{dependency-inversion principle} - we want to depend upwards on an abstraction, rather than downwards on a concrete class.
                \begin{lstlisting}
                    class PushSwitch:
                      def __init__(self, device):
                        self.device = device
                        self.on = False

                      def press(self):
                        self.on = not self.on
                        if self.on:
                          self.device.on()
                        else
                          self.device.off()

                      switch = PushSwitch(Light())
                \end{lstlisting}
                However, singleton creates dependency, and if we wanted to run unit tests, we would need the actual singleton instance in production (which may be sensitive, and cannot be tested on).
                It doesn't allow us to create mock objects.
        \subsection*{1st November 2019}
            \subsubsection*{Legacy System}
                A legacy system is something that has been passed on, \textbf{and is of value}.
                While the examples covered assume good test coverage, this is rarely the case in actual systems, and we need techniques to apply our rules to existing codebases.
                \medskip

                Additionally, code may be messy, or difficult to understand.
                As the codebase grows, it becomes infeasible to read every line of code to understand what it all does, and we need strategies to pick out what is useful, and what is dangerous to change.
                It's also important not to change code to "clean it up" when unnecessary, as it can be quite risky to completely rewrite working code.
                \medskip

                We'd like to find out the connections between modules, how data flows in the system, and what changes could affect other modules.
                Sometimes, this can be done by having scripts visualise some diagrams, which displays how modules are connected.
            \subsubsection*{Preserving Working Code}
                We want to avoid changing code that may look "broken" if we don't need to change it.
                A bug may be counteracted by another bug somewhere else in the system, and therefore "fixing" a bug in one place, may cause other parts of the system to break.
                Furthermore, this "incorrect" behaviour may be used by the customer, or the end user, and they may rely on it working in the same way.
            \subsubsection*{Confidence and Testing}
                In some code bases, it may be difficult to make changes, or it may be higher-risk in an environment which deals with finances.
                \medskip

                To build confidence on modifying code, we want to have some form of guidance that our changes haven't broken any functionality.
                We can split tests into two types;
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{unit test} \hfill micro level
                        \medskip

                        This can give a lot of information about a small bit of code - it's not feasible to write this for all of a legacy system.
                    \item \textbf{system test} \hfill macro level
                        \medskip

                        At a system level test, we run an expected action all the way through, and track what is called.
                        If something fails, it doesn't tell us where, just that the functionality is incorrect.
                \end{itemize}
                Generally, we start by adding unit tests for the small region of code we are changing.
                \medskip

                Examples of code that may be difficult to test are generally environment dependent - if a piece of code in production relies on making requests to a (protected) server, or a database, accessing this may be difficult or give inconsistent results, whereas we'd ideally want to test in isolation.
            \subsubsection*{Seams and Sensing}
                The idea of a \textbf{seam} is a place where behaviour can be altered without editing in that particular place.
                For example, if we wanted to test something that has a web endpoint, we wouldn't want to change it, test it, change it back, and then commit it (since we shouldn't change code after testing).
                A seam allows us to inject different behaviour.
                Every seam has an enabling point, were we can make the decision to use one behaviour or another.
                \medskip

                We break dependencies to \textbf{sense} when we can't access values our code computes.
            \subsubsection*{Live Example}
                See Panopto timestamp 34:50 for this.
                Notes will be added here, in bullet points;
                \begin{itemize}
                    \itemsep0em
                    \item we don't want to change too much, as we can't test if it works in the same way as before, but we do have to change a bit to test it
                    \item we want to simulate the behaviour when a website is broken, but this generally isn't the case
                    \item we extract the behaviour of ~WebPageProbe~ to implement the interface ~Probe~, which we can make always fail
                    \item we can then create a \textbf{new} constructor (don't modify existing constructor), which takes in the failing ~Probe~
                    \item this has the expected behaviour, but we are now notifying on every test
                    \item we then spot a use of ~getInstance()~, suggesting a singleton pattern; we can try taking this out into a field, and adding it to the constructor
                    \item we now have the \textbf{enabling point} in the test suite, allowing us to swap out the ~Alerter~ (interface for ~Emailer~)
                    \item this behaviour can either be tested by manually implementing fields in our implementation of ~Alerter~, or with a mock object library
                    \item we have a dependency on the system clock, which we can try to control in a similar way to allow for testing time based behaviour
                \end{itemize}
        \subsection*{5th November 2019}
            \subsubsection*{Threads}
                Note that when we create new threads, they should implement ~Runnable~, and override ~run()~ (since we aren't really specialising the thread's behaviour);
                \begin{lstlisting}
                    public class ThreadExample {
                      public static void main(String[] args) {
                        new Thread(new Task("A")).start();
                        new Thread(new Task("B")).start();
                      }
                    }

                    class Task implements Runnable {

                      private final String name;

                      public Task(String name) {
                        this.name = name;
                      }

                      @Override
                      public void run() {
                        print("starting thread " + name);
                        ... // some code with possible delays
                        print("completed thread " + name);
                      }
                    }
                \end{lstlisting}
                Note that extending ~Thread~ is a use of the template pattern, whereas implementing ~Runnable~ is a use of the strategy pattern, thus avoiding the coupling.
                By doing this, we can also run ~Task~ synchronously, with ~run()~, without needing it to be in a ~Thread~.
            \subsubsection*{Callables}
                Note that a ~Runnable~ has no return value, whereas a ~Callable~ does.
                This can be used if we want to perform some computation asynchronously;
                \begin{lstlisting}
                    class CountingTask implements Callable<Integer> {

                      private final String name;

                      public CountingTask(String name) {
                        this.name = name;
                      }

                      @Override
                      public Integer call() {

                        print("starting callable " + name);
                        ... // some code with possible delays
                        print("completed thread " + name);
                        return 42;
                      }
                    }
                \end{lstlisting}
            \subsubsection*{Command Pattern}
                This pattern wraps up a piece of behaviour in an object, which we can be done now, later, or repeatedly.
                These operations can be queued or undone.
                A command is an instruction to do something.
                It can be thought of passing around a function (which is the operation), and a state (containing options).
                \begin{center}
                    \begin{tikzpicture}[x=1.5cm, y=0.75cm]
                        \begin{scope}[shift={(0, 0)}]
                            \node at (2, -0.5) {~Queue~};
                            \node[anchor=west] at (0.5, -2) {\shortstack[l]{~List<Command>~\\~executeAll()~}};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(5, 0)}]
                            \node at (2, -0.5) {~Command~};
                            \node[anchor=west] at (0.5, -2) {~execute()~};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(5, -5)}]
                            \node at (2, -0.5) {~ConcreteCommand~};
                            \node[anchor=west] at (0.5, -2) {~execute()~};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(-2, -5)}]
                            \node at (2, -0.5) {~Client~};
                            \node[anchor=west] at (0.5, -2) {\shortstack[l]{~queue:Queue~\\~execute()~}};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \draw
                        (2, -6.5) -- (3, -6.5) -- (3, -4) -- (-1, -4) -- (-1, -2)
                        (-1, -2) edge[->] (0, -2)
                        (4, -2) edge[->] (5, -2)
                        (2, -7.5) edge[->] (5, -7.5)
                        (7, -5) edge[->, blue] (7, -3);
                    \end{tikzpicture}
                \end{center}
                For example, we can have the following;
                \begin{lstlisting}
                    public class QueuingExample {
                      public static void main(String[] args) {

                        CommandQueue queue = new CommandQueue();
                        queue.add(new Command("A"));
                        queue.add(new Command("B"));

                        queue.runAllCommands();
                      }
                    }

                    class CommandQueue {

                      private Queue<Runnable> queue = new LinkedList<Runnable>();

                      public void add(Command command) {
                        queue.add(command);
                      }

                      public void runAllCommands() {
                        for (Runnable command : queue) {
                          command.run();
                        }
                      }
                    }

                    class Command implements Runnable {

                      private final String name;

                      public Command(String name) {
                        this.name = name;
                      }

                      @Override
                      public void run() {
                        System.out.println("Starting command " + name);
                        ...
                        System.out.println("Finishing command " + name);
                      }
                    }
                \end{lstlisting}
                However, all of this is currently running in a single thread.
                We can think of an ~Executor~ as a command queue which has a set of threads (a pool), which can each perform a task.
                \medskip

                We can think of a function that adds tasks to the queue as \textbf{producers}, and the threads as \textbf{consumers}, who "compete" for tasks.
                Queues are also load balancers, as it can deal with different lengths of jobs naturally, as a job is picked up by a thread as soon as one is free.
                Therefore producers can enqueue in bursts, and consumers can work steadily.
                \begin{lstlisting}
                    public class CommandExample {

                      public void run() {
                        // gives us a pool of 3 threads
                        Executor queue = Executors.newFixedThreadPool(3);

                        for (int i = 1; i <= 10; i++) {
                          // note that Command implements Runnable
                          queue.execute(new Command(i));
                        }
                      }
                    }
                \end{lstlisting}
            \subsubsection*{Futures}
                However, we might want to to obtain a calculated response from our tasks.
                By using ~Future~s, we can get the result once it is finished.
                \begin{lstlisting}
                    public static void main(String[] args) throws Exception {

                      MyCallable task = new MyCallable("A");

                      ExecutorService executor = Executors.newFixedThreadPool(2);

                      Future<Double> future = executor.submit(task);

                      // do something whilst calculating

                      // the following line blocks until the result is available
                      Double result = future.get();
                    }
                \end{lstlisting}
                By using this ~Future~, that's returned after submitting the task to the ~ExecutorService~, we can do the following;
                \begin{itemize}
                    \itemsep0em
                    \item ~get()~ \hfill blocks until ready
                    \item ~get(timeout)~ \hfill throws exception if it doesn't complete in time
                    \item ~cancel(mayInteruptIfRunning)~ \hfill the parameter allows a running task to be cancelled
                    \item ~isDone()~ \hfill is it done
                    \item ~isCancelled~ \hfill is it cancelled
                \end{itemize}
                \begin{lstlisting}
                    public static void main(String[] args) {

                      ExecutorService executorService = Executors.newFixedThreadPool(2);

                      executorService.submit(new MyTask("A"));
                      executorService.submit(new MyTask("B"));
                      executorService.submit(new MyTask("C"));
                      executorService.submit(new MyTask("D"));

                      // do not accept more tasks
                      executorService.shutdown();

                      try {
                        // wait a maximum of 2 minutes for everything to terminate
                        executorService.awaitTermination(120, TimeUnit.SECONDS);
                      } catch (InterruptedException e) {
                        // handle the case where it times out
                      }
                    }
                \end{lstlisting}
            \subsubsection*{Latch}
                We don't want to shut down the ~ExecutorService~ once all the jobs are completed, but we want to cluster jobs together, such that the main thread can continue once a part of it is done.
                For this, a ~Latch~ can be used, which is set with an initial value, and then decremented by the tasks.
                \begin{center}
                    \begin{tikzpicture}[x=1.25cm, y=1.25cm]
                        \begin{scope}[shift={(3.25, 1.75)}]
                            \node at (0.75, -0.375) {~Task~};
                            \draw (0, 0) -- (1.5, 0) -- (1.5, -0.75) -- (0, -0.75) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(3.25, 0.75)}]
                            \node at (0.75, -0.375) {~Task~};
                            \draw (0, 0) -- (1.5, 0) -- (1.5, -0.75) -- (0, -0.75) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(6, -1)}]
                            \node at (0.75, -0.375) {~Latch~};
                            \draw (0, 0) -- (1.5, 0) -- (1.5, -0.75) -- (0, -0.75) -- cycle;
                        \end{scope}
                        \node at (1, -2.5) {~MainThread~};
                        \node at (4, -0.5) {~Exec.Serv.~};
                        \draw (0, 0) -- (2, 0) -- (2, -3) -- (0, -3) -- cycle;
                        \draw (3, 2) -- (5, 2) -- (5, -1) -- (3, -1) -- cycle;
                        \draw (2.25, -2.5) edge[->, bend right=10, below] node{~await()~} (6.75, -2);
                        \draw (5.25, 1.375) edge[->, bend left=10, right] node{~countDown()~} (6.75, -0.75);
                        \draw (5.25, 0.375) edge[->, bend left=10] (6.75, -0.75);
                    \end{tikzpicture}
                \end{center}
                A simple example is as follows;
                \begin{lstlisting}
                    public class LatchExample {
                      public static void main(String[] args) throws Exception {

                        ExecutorService executor = Executors.newFixedThreadPool(2);
                        CountDownLatch latch = new CountDownLatch(4);

                        executor.submit(new LatchedTask("A", latch));
                        executor.submit(new LatchedTask("B", latch));
                        executor.submit(new LatchedTask("C", latch));
                        executor.submit(new LatchedTask("D", latch));

                        latch.await();
                      }
                    }

                    class LatchedTask implements Runnable {

                      private final String name;
                      private final CountDownLatch latch;

                      public LatchedTask(String name, CountDownLatch latch) {
                        this.name = name;
                        this.latch = latch;
                      }

                      @Override
                      public void run() {
                        System.out.println("Starting " + name);
                        // do something
                        System.out.println("Finished " + name);

                        latch.countDown();
                      }
                    }
                \end{lstlisting}
                Note that the ~latch~ is shared by each batch of tasks.
                At the end of running, each task must ~countDown()~.
                Generally, we should use executors instead of creating our own threads.
        \subsection*{12th November 2019}
            \subsubsection*{Graphical User Interfaces}
                Typically, for whatever platform we're working on, there should be a library with components that we are able to use for our interface.
                This reduces the work we have to do significantly, as we don't have to write all the UI components from scratch.
            \subsubsection*{Example}
                This lecture uses \textit{Swing}, which is a fairly simple library, and is quite outdated.
                \begin{lstlisting}
                    package interactive;

                    import ...;

                    public GuiApp {

                      public class GuiApp {
                        new GuiApp.display();
                      }

                      private void display() {
                        JFrame window = new JFrame("Example App");
                        window.setSize(400, 300);

                        JPanel panel = new JPanel();

                        // 10 character limit
                        JTextField textField = new JTextField(10);
                        JButton button = new JButton();

                        // this can be replaced with a lambda
                        button.addActionListener(new ActionListener() {
                          @Override
                          public void actionPerformed(ActionEvent e) {
                            textField.setText("clicked");
                          }
                        });

                        panel.add(textField);
                        panel.add(button);

                        window.add(panel);

                        window.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

                        // do this at the end, once everything is set up
                        window.setVisible(true);
                      }
                    }
                \end{lstlisting}
            \subsubsection*{Observer Pattern}
                In a non-interactive application, the flow is fairly simple - it read from the top down, branching or looping if needed.
                However, in an interactive application, we need to react to \textbf{events} from the user.
                When something happens, something else may happen (triggered by the first event).
                \medskip

                The observer pattern has objects that know when another object's state is changed - by being told, not by continuously querying whether the event is complete.
                This is also known as registering a callback, or publish-subscribe.
                \begin{center}
                    \begin{tikzpicture}[x=1.5cm, y=0.75cm]
                        \begin{scope}[shift={(0, 0)}]
                            \node at (2, -0.5) {~Subject~};
                            \node[anchor=west] at (0.5, -2.5) {\shortstack[l]{~observers:List~\\~addObserver(o)~\\~removeObserver(o)~\\~notifyObservers()~}};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -4) -- (0, -4) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(5, 0)}]
                            \node at (2, -0.5) {~Observer~};
                            \node[anchor=west] at (0.5, -2) {~update(subject)~};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \draw (4, -2) edge[->] (5, -2);
                    \end{tikzpicture}
                \end{center}
                When the state of the ~Subject~ has changed, all of its ~Observer~s can be notified via ~update~ with its state.
                Note that an observer must first register to be notified;
                \begin{center}
                    \begin{tikzpicture}
                        \draw
                        (5, 0) edge[->, above] node{2 - trigger} (1, 0)
                        (-6, 2) edge[->, below] node{1 - register} (-1.5, 0)
                        (-6, -2) edge[->] (-1.5, 0)
                        (0, 0) edge[->, above] node{3 - notify} (-4.5, 2)
                        (0, 0) edge[->, below] node{3 - notify} (-4.5, -2);
                        \begin{scope}[shift={(0, 0)}]
                            \draw[fill=white] (0, 0) circle (1);
                            \node at (0, 0) {~subj~};
                            \draw
                            (-1, 0) -- (-1.5,  0)
                            (-1.5, 0.5) -- (-1.5, -0.5);
                        \end{scope}
                        \begin{scope}[shift={(6, 0)}]
                            \draw[fill=white] (0, 0) circle (1);
                            \node at (0, 0) {~stim~};
                        \end{scope}
                        \begin{scope}[shift={(-6, 2)}]
                            \draw[fill=white] (0, 0) circle (1);
                            \node at (0, 0) {~obs1~};
                            \draw
                            (1, 0) -- (1.5,  0)
                            (1.5, 0.5) -- (1.5, -0.5);
                        \end{scope}
                        \begin{scope}[shift={(-6, -2)}]
                            \draw[fill=white] (0, 0) circle (1);
                            \node at (0, 0) {~obs2~};
                            \draw
                            (1, 0) -- (1.5,  0)
                            (1.5, 0.5) -- (1.5, -0.5);
                        \end{scope}
                    \end{tikzpicture}
                \end{center}
            \subsubsection*{Model-View-Controller (MVC)}
                MVC splits interactive apps into 3 parts - data, display, and user input.
                The \textbf{view} is concerned with drawing on the screen (anything presentational or to do with formatting).
                Front-end specialists can work on this part.
                This separation allows for different views, without changing the model.
                \medskip

                \textbf{Model} is to do with the logic of the application, and modelling the domain.
                Finally, the \textbf{controller} is concerned with events - it should be kept simple, as it is a translation from the world of events.
                Typically, all the logic should be in the model, and not in the controller.
                \medskip

                An example of code that doesn't follow this \textbf{architectural pattern} is as follows;
                \begin{lstlisting}
                    public class GuiApp {

                      private final JButton button = new JButton("Press me!");
                      private final JTextField textField = new JTextField(10);

                      private final PressCounter pressCounter = new PressCounter();

                      class PressCounter {

                        private int count;

                        public void increment() {
                          count++;
                          if (count < 5) {
                            textField.setText(String.valueOf(count));
                          } else {
                            textField.setText("Too many!");
                            button.setEnabled(false);
                          }
                        }
                      }

                      private void display() {
                        ... // standard setup

                        button.addActionListener(new ActionListener() {
                          public void actionPerformed(ActionEvent actionEvent) {
                            pressCounter.increment();
                          }
                        });
                        ...
                      }
                    }
                \end{lstlisting}
                We can separate this into the following classes.
                Note that we are using the \textbf{observer pattern}, as we then query the ~Model~ passed in.
                \begin{lstlisting}
                    class View implements Updatable {

                      private final JButton button = new JButton("Press me!");
                      private final JTextField textField = new JTextField(10);

                      public View(ActionListener controller) {
                        JFrame frame = new JFrame("Example App");
                        frame.setSize(400, 300);

                        button.addActionListener(controller);

                        JPanel panel = new JPanel();
                        panel.add(textField);
                        panel.add(button);
                        frame.add(panel);
                        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
                        frame.setVisible(true);
                      }

                      public void update(Model model) {
                        if (model.morePressesAllowed()) {
                          textField.setText(String.valueOf(model.count()));
                        } else {
                          textField.setText("Too many!");
                          button.setEnabled(false);
                        }
                      }
                    }
                \end{lstlisting}
                This contains all the logic, and also contains functions that can easily be called from the ~View~.
                Since this isn't specific to the display, it can be reused in other applications easily.
                We can also add more observers (~View~s) to the model - by having any number of observers, we can also have none, which allows for unit tests to be easily written.
                \begin{lstlisting}
                    class Model {

                      private final Updatable view;

                      private int count;
                      private boolean morePressesAllowed = true;

                      public Model(Updatable view) {
                        this.view = view;
                      }

                      public void increment() {
                        count++;
                        if (count >= 5) {
                          morePressesAllowed = false;
                        }
                        view.update(this);
                      }

                      public boolean morePressesAllowed() {
                        return morePressesAllowed;
                      }

                      public int count() {
                        return count;
                      }
                    }
                \end{lstlisting}
                Finally, the controller (and wiring) is as follows;
                \begin{lstlisting}
                    public class GuiApp {

                      private View view = new View(new Controller());
                      private Model pressCounter = new Model(view);

                      class Controller implements ActionListener {
                        public void actionPerformed(ActionEvent actionEvent) {
                          pressCounter.increment();
                        }
                      }

                      public static void main(String[] args) {
                        new GuiApp();
                      }
                    }
                \end{lstlisting}
        \subsection*{15th November 2019}
            \subsubsection*{Presentation-Abstraction-Control}
                This is used by \textit{React}.
                This has multiple MVCs, each group of which is called an \textbf{agent} - which is useful for hierarchical, widget-based UIs.
                Each agent handles one part of the UI, and they are organised in a tree, with the root agent handling the largest part.
                \medskip

                The rule is that the controllers can communicate with the controller of its direct parent, or any of its own children.
                For example - if the entire window is changed, then the highest-level agent will inform its children, and so on.
                However, if only a small bit is changed (such as changing tabs), only that portion will need to be informed of a change.
            \subsubsection*{Event Bus}
                However, PAC has a drawback when we are trying to notify something else in the tree, that isn't directly related as it would have to go all the way up the tree, and then back down.
                The event bus has a broadcast channel which allows an agent to inform all others of a change.
                \begin{center}
                    \begin{tikzpicture}
                        \node at (-6.5, -1) {\shortstack{broadcast\\channel}};
                        \draw
                        (-2.5, -1) edge[->] (-4.5, -1)
                        (-4.5, -1.5) edge[->] (-2.5, -1.5)
                        (-2.5, -6) edge[->] (-4.5, -6)
                        (-4.5, -6.5) edge[->] (-2.5, -6.5);
                        \draw (-8, 0) -- (-5, 0) -- (-5, -7.5) -- (-8, -7.5) -- cycle;
                        \begin{scope}[shift={(0, 0)}]
                            \node[anchor=north west] at (-1.75, 0.25) {agent};
                            \draw (-2, 0.5) -- (4, 0.5) -- (4, -3) -- (-2, -3) -- cycle;
                            \begin{scope}[shift={(0, 0)}]
                                \node at (1, -0.5) {controller};
                                \draw (0, 0) -- (2, 0) -- (2, -1) -- (0, -1) -- cycle;
                            \end{scope}
                            \begin{scope}[shift={(-1.5, -1.5)}]
                                \node at (1, -0.5) {controller};
                                \draw (0, 0) -- (2, 0) -- (2, -1) -- (0, -1) -- cycle;
                            \end{scope}
                            \begin{scope}[shift={(1.5, -1.5)}]
                                \node at (1, -0.5) {controller};
                                \draw (0, 0) -- (2, 0) -- (2, -1) -- (0, -1) -- cycle;
                            \end{scope}
                            \draw
                            (0.5, -1) edge[->] (-0.5, -1.5)
                            (1.5, -1) edge[->] (2.5, -1.5);
                        \end{scope}
                        \begin{scope}[shift={(0, -5)}]
                            \node[anchor=north west] at (-1.75, 0.25) {agent};
                            \draw (-2, 0.5) -- (4, 0.5) -- (4, -3) -- (-2, -3) -- cycle;
                            \begin{scope}[shift={(0, 0)}]
                                \node at (1, -0.5) {controller};
                                \draw (0, 0) -- (2, 0) -- (2, -1) -- (0, -1) -- cycle;
                            \end{scope}
                            \begin{scope}[shift={(-1.5, -1.5)}]
                                \node at (1, -0.5) {controller};
                                \draw (0, 0) -- (2, 0) -- (2, -1) -- (0, -1) -- cycle;
                            \end{scope}
                            \begin{scope}[shift={(1.5, -1.5)}]
                                \node at (1, -0.5) {controller};
                                \draw (0, 0) -- (2, 0) -- (2, -1) -- (0, -1) -- cycle;
                            \end{scope}
                            \draw
                            (0.5, -1) edge[->] (-0.5, -1.5)
                            (1.5, -1) edge[->] (2.5, -1.5);
                        \end{scope}
                    \end{tikzpicture}
                \end{center}
            \subsubsection*{Testing Interactive Applications}
                We need to ensure that the entire system works together, with full system tests.
                The system test should call a driver, which then interacts with the interactive application.
                \begin{lstlisting}
                    public class CalculatorGuiTest {

                      CalculatorDriver calculatorUI;

                      @Before
                      public void runTheApplication() {
                        new Calculator();
                        calculatorUI = new CalculatorDriver();
                      }

                      @After
                      public void stopTheApplication() {
                        calculatorUI.dispose();
                      }

                      @Test
                      public void canAddTwoNumbers() {
                        calculatorUI.clickDigitButton(1);
                        calculatorUI.clickDigitButton(2);
                        calculatorUI.clickAddButton();
                        calculatorUI.shouldDisplay("3");
                      }

                      @Test
                      public void canSubtractTwoNumbers() {
                        calculatorUI.clickDigitButton(4);
                        calculatorUI.clickDigitButton(3);
                        calculatorUI.clickMinusButton();
                        calculatorUI.shouldDisplay("1");
                      }
                    }
                \end{lstlisting}
                For the driver to work, names need to be added to the UI components, which do not show up, but allow for us to differentiate between them.
                This is done with ~button.setName("button" + i)~, for example.
                The driver is implemented as follows;
                \begin{lstlisting}
                    public class CalculatorDriver extends JFrameDriver {

                      public CalculatorDriver() {
                        ... // a very long super(...)
                      }

                      public void shouldDisplay(String expectedResult) {
                        display().hasText(equalTo(expectedResult));
                      }

                      public void clickDigitButton(int digit) {
                        button(String.valueOf(digit)).click();
                      }

                      public void clickAddButton() {
                        button("+").click();
                      }

                      public void clickMinusButton() {
                        button("-").click();
                      }

                      private JTextFieldDriver display() {
                        return new JTextFieldDriver(this, JTextField.class, ComponentDriver.named(CalculatorGui.DISPLAY));
                      }

                      private JButtonDriver button(String name) {
                        return new JButtonDriver(this, JButton.class, ComponentDriver.named("button" + name));
                      }
                    }
                \end{lstlisting}
            \subsubsection*{Web Application}
                The model can be used directly, without any modification (MVC).
                The controller also has to handles parameters from the request (such as ~?q=foobar~), and so on.
                However, the view also has to give a HTTP response back to the browser, with the content rendered.
                \begin{lstlisting}
                    ...

                    public class WebServer {

                      public WebServer() throws Exception {

                        Server server = new Server(serverPort());

                        ServletHandler handler = new ServletHandler();
                        handler.addServletWithMapping(new ServletHolder(new CalculatorPageController()), "/*");
                        server.sendHandler(handler);

                        server.start();
                      }

                      private int ServerPort() {
                        String port = System.getenv("PORT");
                        return port == null ? 5000 : Integer.parseInt(port);
                      }

                      public static void main(String[] args) throws Exception {
                        new WebServer();
                      }
                    }
                \end{lstlisting}
                The ~CalculatorPageController~ has the following code;
                \begin{lstlisting}
                    ...

                    public class CalculatorPageController extends HttpServlet {

                      private final RpnQueryProcessor queryProcessor = new RpnQueryProcessor();

                      @Override
                      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
                        if (req.getParameter("q") == null) {
                          new IndexPage().writeTo(resp);
                        } else {
                          new ResultsPage(queryProcessor.process(req.getParamter("q"))).writeTo(resp);
                        }
                      }
                    }
                \end{lstlisting}
                The view in this case is just the ~ResultsPage~, which takes the response and puts it into a HTML template, which is sent back to the browser.
                The model can be tested in the same way.
                \medskip

                This can be tested by another driver, such as \textit{Selenium WebDriver}, which acts as a user interacting with the page.
                \begin{lstlisting}
                    public class SeleniumTest {

                      @Test
                      public void canSubmitCalculationAndSeeResults() throws Exception {

                        System.setProperty(...);
                        WebDriver driver = new ChromeDriver();

                        WebElement inputBox = driver.findElement(By.name("q"));

                        inputBox.sendKeys("5 7 +");
                        inputBox.submit();

                        String resultsText = driver.findElement(By.id("results")).getText();
                        assertThat(resultsText, is("12"));

                        driver.quit();
                      }
                    }
                \end{lstlisting}
            \subsubsection*{Deploying to Heroku}
                This is basically free for small scale projects, and allows the application to be deployed.
                \begin{lstlisting}
                    $\dollar$ heroku login
                    $\dollar$ cd /path/to/root/directory/
                    $\dollar$ heroku create
                \end{lstlisting}
                Doing this gives a URL, and a repository - when it is pushed, it is built.
                A ~Procfile~ is added, which tells the service how to initialise the application.
                This allows for the \textit{Selenium} tests to be run on a production server.
        \subsection*{19th November 2019}
            \subsubsection*{Integrating Existing Components}
                While we can use external libraries, and connect them, it's not purely sticking them together, as we still need to write logic to drive them.
                However, we still have third party, and open source libraries that are available for us to use, such as UI frameworks, reducing the amount of work we have to do.
                \medskip

                We may also have components that need to be integrated from other organisations, or within the same organisation (written by other teams).
                For this to work well, we need a few design patterns.
            \subsubsection*{Adapter Pattern}
                \begin{center}
                    \textit{"I have an $X$, but I need a $Y$"}
                \end{center}
                It does the right thing (has the right functionality), but doesn't the right interface to plug into our application.
                We don't want to rewrite this, as it works, and we don't want to change our interface.
                Changing our interface can lead to polluting our codebase with methods from other libraries.
                \medskip

                This converts the interface of a class into another interface clients expect - if it cannot be changed, we create a wrapper.
                Delegate as much as possible to the working component.
                \begin{center}
                    \begin{tikzpicture}[x=1.25cm, y=0.75cm]
                        \begin{scope}[shift={(0, 4)}]
                            \node at (2, -0.5) {~Service~};
                            \node at (2, -2) {~request()~};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(0, 0)}]
                            \node at (2, -0.5) {~Adapter~};
                            \node at (2, -2) {\shortstack[l]{~service:Adaptee~\\~request()~}};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(-5, 0)}]
                            \node at (2, -0.5) {~Client~};
                            \node at (2, -2) {\shortstack[l]{~service:Service~\\~doSomething()~}};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(5, 0)}]
                            \node at (2, -0.5) {~Adaptee~};
                            \node at (2, -2) {~performAction()~};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \draw
                        (-1, -1.5) edge[->] (0, -1.5)
                        (4, -1.5) edge[->] (5, -1.5)
                        (2, 0) edge[->, blue] (2, 1);
                    \end{tikzpicture}
                \end{center}
                The ~Adaptee~ has the correct behaviour, but does not have the correct interface.
                The ~Adapter~ implements the ~Service~ interface, which the ~Client~ has a field for.
                \medskip

                An example is as follows (~ThirdPartyFileLogger~ is the ~Adaptee~, ~FileLogger~ is the ~Adapter~, and ~Logger~ is the ~Service~);
                \begin{lstlisting}
                    ...

                    import third.party.ThirdPartyFileLogger;

                    public class FileLogger implements Logger {

                      private final ThirdPartyFileLogger logger;

                      public FileLogger(String filename) {
                        this.logger = new ThirdPartyFileLogger(filename);
                      }

                      @Override
                      public void log(String message) {
                        logger.info(new LogMessage(message));
                      }
                    }
                \end{lstlisting}
            \subsubsection*{Decorator Pattern}
                \begin{center}
                    \textit{"I have an $X$, but I want a better $X$"}
                \end{center}
                This is the case where we have something we want, and has the correct behaviour, but we want it to do more.
                This adds functionality or responsibility to an object dynamically, by wrapping an existing object.
                \begin{center}
                    \begin{tikzpicture}[x=1.25cm, y=0.75cm]
                        \begin{scope}[shift={(2.5, 5)}]
                            \node at (2, -0.5) {~Service~};
                            \node at (2, -2) {~request()~};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(0, 0)}]
                            \node at (2, -0.5) {~Decorator~};
                            \node at (2, -2) {\shortstack[l]{~service:Service~\\~request()~}};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(-5, 0)}]
                            \node at (2, -0.5) {~Client~};
                            \node at (2, -2) {\shortstack[l]{~service:Service~\\~doSomething()~}};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(5, 0)}]
                            \node at (2, -0.5) {~BasicService~};
                            \node at (2, -2) {~request()~};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \draw
                        (-1, -1.5) edge[->] (0, -1.5)
                        (4, -1.5) edge[->] (5, -1.5)
                        (2, 0) -- (2, 1) -- (7, 1) -- (7, 0)
                        (4.5, 1) edge[->, blue] (4.5, 2);
                    \end{tikzpicture}
                \end{center}
                Note that the ~Decorator~ and ~BasicService~ both have the same interface ~Service~.
                For example, using the same example as above, we want to add timestamps before each message;
                \begin{lstlisting}
                    ...

                    import java.time.LocalTime;

                    public class TimeStampedLogger implements Logger {

                      private final Logger logger;

                      public TimeStampedLogger(Logger logger) {
                        this.logger = logger;
                      }

                      @Override
                      public void log(String message) {
                        logger.log(LocalTime.now().toString() + " : " + message);
                      }
                    }
                \end{lstlisting}
                This gives us additional flexibility, as we can choose not to use the decorator if we don't need it, since they implement the same interface.
            \subsubsection*{Facade Pattern}
                \begin{center}
                    \textit{"I have an $X$, but I want a simpler $X$"}
                \end{center}
                This is the case where we have working code, but it has complexity we want to hide away.
                A lesser-known variation is the \textbf{simplicator pattern} which allows our application to interact with the complicated system through the simplicator.
            \subsubsection*{Proxy Pattern}
                \begin{center}
                    \textit{"I have an $X$, but it's too slow"}
                \end{center}
                I have something that does the correct thing, but it takes too long to do it.
                We want a way to speed up access to this resource - by delegation (and sometimes preventing delegation).
                This controls access to an object by providing a placeholder or surrogate object.
                \begin{center}
                    \begin{tikzpicture}[x=1.25cm, y=0.75cm]
                        \begin{scope}[shift={(2.5, 5)}]
                            \node at (2, -0.5) {~Service~};
                            \node at (2, -2) {~request()~};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(0, 0)}]
                            \node at (2, -0.5) {~ProxyService~};
                            \node at (2, -2) {\shortstack[l]{~service:Service~\\~request()~}};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(-5, 0)}]
                            \node at (2, -0.5) {~Client~};
                            \node at (2, -2) {\shortstack[l]{~service:Service~\\~doSomething()~}};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \begin{scope}[shift={(5, 0)}]
                            \node at (2, -0.5) {~RealService~};
                            \node at (2, -2) {~request()~};
                            \draw
                            (0, 0) -- (4, 0) -- (4, -3) -- (0, -3) -- cycle
                            (0, -1) -- (4, -1);
                        \end{scope}
                        \draw
                        (-1, -1.5) edge[->] (0, -1.5)
                        (4, -1.5) edge[dashed, ->] (5, -1.5)
                        (2, 0) -- (2, 1) -- (7, 1) -- (7, 0)
                        (4.5, 1) edge[->, blue] (4.5, 2);
                    \end{tikzpicture}
                \end{center}
                The ~ProxyService~ can control access (preventing some users from using it), as well as caching it (a caching proxy).
                The proxy can store a ~Map~, containing queries and their recorded results, thus reducing the number of calls needed to the expensive (time, or actual cost) service (which may be an external web API).
                If we are caching, we should ensure that this data does not become stale or outdated.
                \medskip

                This design pattern is useful especially in the case of using a remote service, as we want to hide away the complexity of performing network requests from the client.
            \subsubsection*{Hexagonal Architectures}
                We typically think about the structure of a system as a series of layers, with a UI at the top, and a database at the bottom.
                We should think of it similar to an onion.
                The modules in the core should not depend on any particular external objects.
                This also allows us to test much quicker, as we can purely run unit tests within the core.
                \medskip

                The hexagonal (ports and adapters) architecture adds a layer (the adapter layer) in between the core and any external sources.
                For example, changing a database should be easily done, without changing the core code, by just changing the adapter.
                This also helps to reduce pollution from one codebase to another.
                For example, if an external service gave results back in an XML format, and that was used throughout, then a coupling is formed with the service.
                \medskip

                Pure unit tests can be done for the core (which should be as large as possible), using mock objects for the external objects.
                An integration test generally tests code that is written by you, with code that isn't written by you.
                For example, testing an adapter with an external service.
                Finally, full system tests are used to ensure the entire system works together.
                Typically these are the slowest tests (unit tests are the fastest), hence there should be fewer of these.
                \medskip

                Testing more in the middle (unit tests) allows for faster feedback.
        \subsection*{22nd November 2019}
            \subsubsection*{Splitting an Application}
                When an application grows, it may make sense to split it into smaller components.
                For example, if some part of the system is computationally intensive, it may make sense to use a different language for just that part, or if the team grows too large, separating components allows for more independence.
                Similarly, some parts may need to be scaled across multiple systems, without scaling the entire application.
            \subsubsection*{Remote Services}
                We can consider this as client applications using remote services, which may use other services to do their jobs.
                Each service has a bounded job.
                These can be run on the same machine, but can also be run on other systems to distribute work.
                \begin{center}
                    \begin{tikzpicture}
                        \begin{scope}[shift={(0, 0)}]
                            \node at (1, -0.5) {client};
                            \draw (0, 0) -- (2, 0) -- (2, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(4, 1)}]
                            \node at (1, -0.5) {service};
                            \draw (0, 0) -- (2, 0) -- (2, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \begin{scope}[shift={(4, -1)}]
                            \node at (1, -0.5) {service};
                            \draw (0, 0) -- (2, 0) -- (2, -1) -- (0, -1) -- cycle;
                        \end{scope}
                        \draw
                        (2, -0.25) edge[->] (4, 0.5)
                        (2, -0.75) edge[->] (4, -1.5);
                    \end{tikzpicture}
                \end{center}
            \subsubsection*{Examples for Large Companies}
                \textit{SoundCloud} performed a migration from a single "mothership" to having microservices.
                The same microservices were used to power the public API, allowing applications previously relying on this API to continue functioning without any changes.
                \medskip

                Similarly, \textit{Amazon} migrated from a single datacenter with everything in one Java application, to thousands of fine grained services.
                Over the course of 10 years, no services have direct access with each other, and must communicate over APIs.
            \subsubsection*{Network Connections}
                While we can interact with services by directly making connections over sockets, it's often undesirable.
                Instead, we can use the Web, which has standardised protocols (and infrastructure), and applications generally follow a similar structure, thus allowing us to use existing libraries to perform these connections.
            \subsubsection*{Representational Stat Transfer (REST)}
                The idea is that this uses everything the web has to offer, which use the methods provided by HTTP, as well as the status codes.
                This means that some behaviour doesn't have to be manually written, as we have conventions for dealing with cases (such as error codes).
                \medskip

                Typically, data is transferred in formats such as \textbf{XML} (less popular), or \textbf{JSON}.
                These are fairly human-readable, but can also be quite easily parsed with standard libraries.
                JSON requires the entire string to be loaded into the document for it to be processed, whereas XML is better for larger messages since it can be read in a stream.
            \subsubsection*{Clients}
                If a page in a browser was dynamically updating from a data source, it doesn't make sense for it to redraw components that haven't changed.
                Therefore, we can pull from a feed of data which is much lighter than rendering the entire page again.
                An example of this is performing AJAX (Asynchronous JavaScript And XML), using \textit{jQuery}.
                \medskip

                On the other hand, a web request can be made from any source, not just a web client.
                This allows services to use other services.
                Typically, we'd want to wrap this functionality, to abstract away from the complexity of networking.
            \subsubsection*{Example}
                An example of this, using the \textit{Spring} framework in Java, is as follows;
                \begin{lstlisting}
                    ... // importing Spring etc

                    @RestController
                    public class GreetingController {

                      private static final String template = "Hello, %s!";
                      private final AtomicLong counter = new AtomicLong();

                      @RequestMapping("/greeting")
                      public Greeting greeting(@RequestParam(value="name", defaultValue="World") String name) {
                        return new Greeting(counter.increment.andGet(),
                                            String.format(template, name));
                      }
                    }
                \end{lstlisting}
                The Java ~Greeting~ object is then converted into JSON, when displayed to the web client.
                Instead of manually specifying the parameter, as ~?name=everyone~, we can use path variables;
                \begin{lstlisting}
                    ... // importing Spring etc

                    @RestController
                    public class GreetingController {
                      ...

                      @RequestMapping("/greeting/{name}")
                      public Greeting greeting(@PathVariable(value="name") String name) {
                        return new Greeting(counter.increment.andGet(),
                                            String.format(template, name));
                      }
                    }
                \end{lstlisting}
            \subsubsection*{Richardson Maturity Model}
                We can score how well an API uses the web, based on how well it uses what is available (Hypermedia, HTTP, URI);
                \begin{itemize}
                    \itemsep0em
                    \item \textbf{Level 0}
                        \medskip

                        This service has a single URI, and we typically encode the request in the body of the request (which is done with HTTP POST) - this doesn't use different HTTP methods, and has a single URI.
                        An example is SOAP.
                    \item \textbf{Level 1}
                        \medskip

                        This has many URIs (representing different resources), but this typically uses HTTP GET - however GET typically shouldn't have a side effect on the server.
                    \item \textbf{Level 2}
                        \medskip

                        Similarly, this has many URIs.
                        However, it uses four HTTP verbs for CRUD (Create, Read, Update, Delete), to perform different actions;
                        \begin{itemize}
                            \itemsep0em
                            \item POST \hfill create
                            \item GET \hfill read
                            \item PUT \hfill update (modify)
                            \item DELETE \hfill delete
                            This also uses HTTP status codes, which informs the user what it does.
                        \end{itemize}
                    \item \textbf{Level 3}
                        \medskip

                        Similar to the previous level, but the resource representations contain links, and the client can follow those links.
                        This is used for REST.
                \end{itemize}
\end{document}
