\documentclass[a4paper, 12pt]{article}
% packages
\usepackage{amssymb}
\usepackage[fleqn]{mathtools}
\usepackage{tikz}
\usepackage{enumerate}
\usepackage{bussproofs}
\usepackage{xcolor}
\usepackage[margin=1.3cm]{geometry}
\usepackage{logicproof}
\usepackage{diagbox}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{lstautogobble}
\usepackage{hyperref}
\usepackage{multirow}
\usetikzlibrary{arrows, shapes.gates.logic.US, circuits.logic.US, calc, automata, positioning}

% shorthand for verbatim
\catcode`~=\active
\def~#1~{\texttt{#1}}

% code listing
\lstdefinestyle{main}{
    numberstyle=\tiny,
    breaklines=true,
    showspaces=false,
    showstringspaces=false,
    tabsize=2,
    numbers=left,
    basicstyle=\ttfamily,
    columns=fixed,
    fontadjust=true,
    basewidth=0.5em,
    autogobble,
    xleftmargin=3.0ex,
    mathescape=true
}
\newcommand{\dollar}{\mbox{\textdollar}} %
\lstset{style=main}

% augmented matrix
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
\hskip -\arraycolsep
\let\@ifnextchar\new@ifnextchar
\array{#1}}
\makeatother

% ceiling / floor
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

% custom commands
\newcommand{\indefint}[2]{\int #1 \, \mathrm{d}#2}
\newcommand{\defint}[4]{\int_{#1}^{#2} #3 \, \mathrm{d}#4}
\newcommand{\dif}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}}
\newcommand{\limit}[2]{\displaystyle{\lim_{#1 \to #2}}}
\newcommand{\summation}[3]{\sum\limits_{#1}^{#2} #3}
\newcommand{\intbracket}[3]{\left[#3\right]_{#1}^{#2}}
\newcommand{\ulsmash}[1]{\underline{\smash{#1}}}

\newcommand{\powerset}[0]{\wp}
\renewcommand{\emptyset}[0]{\varnothing}

\newcommand{\unaryproof}[2]{\AxiomC{#1} \UnaryInfC{#2} \DisplayProof}
\newcommand{\binaryproof}[3]{\AxiomC{#1} \AxiomC{#2} \BinaryInfC{#3} \DisplayProof}
\newcommand{\trinaryproof}[4]{\AxiomC{#1} \AxiomC{#2} \AxiomC{#3} \TrinaryInfC{#4} \DisplayProof}

% no indent
\setlength\parindent{0pt}
\setlength\itemsep{0em}

% reasoning proofs
\usepackage{ltablex}
\usepackage{environ}
\keepXColumns
\NewEnviron{reasoning}{
    \begin{tabularx}{\textwidth}{rlX}
        \BODY
    \end{tabularx}
}
\newcommand{\proofline}[3]{$(#1)$ & $#2$ & \hfill #3 \smallskip \\}
\newcommand{\proofarbitrary}[1]{& take arbitrary $#1$ \smallskip \\}
\newcommand{\prooftext}[1]{\multicolumn{3}{l}{#1} \smallskip \\}
\newcommand{\proofmath}[3]{$#1$ & = $#2$ & \hfill #3 \smallskip \\}
\newcommand{\prooftherefore}[1]{& $\therefore #1$ \smallskip \\}
\newcommand{\proofbc}[0]{\prooftext{\textbf{Base Case}}}
\newcommand{\proofis}[0]{\prooftext{\textbf{Inductive Step}}}

% reasoning er diagrams
\newcommand{\nattribute}[4]{
    \node[draw, state, inner sep=0cm, minimum size=0.2cm, label=#3:{#4}] (#1) at (#2) {};
}
\newcommand{\mattribute}[4]{
    \node[draw, state, accepting, inner sep=0cm, minimum size=0.2cm, label=#3:{#4}] (#1) at (#2) {};
}
\newcommand{\dattribute}[4]{
    \node[draw, state, dashed, inner sep=0cm, minimum size=0.2cm, label=#3:{#4}] (#1) at (#2) {};
}
\newcommand{\entity}[3]{
    \node[] (#1-c) at (#2) {#3};
    \node[inner sep=0cm] (#1-l) at ($(#1-c) + (-1, 0)$) {};
    \node[inner sep=0cm] (#1-r) at ($(#1-c) + (1, 0)$) {};
    \node[inner sep=0cm] (#1-u) at ($(#1-c) + (0, 0.5)$) {};
    \node[inner sep=0cm] (#1-d) at ($(#1-c) + (0, -0.5)$) {};
    \draw
    ($(#1-c) + (-1, 0.5)$) -- ($(#1-c) + (1, 0.5)$) -- ($(#1-c) + (1, -0.5)$) -- ($(#1-c) + (-1, -0.5)$) -- cycle;
}
\newcommand{\relationship}[3]{
    \node[] (#1-c) at (#2) {#3};
    \node[inner sep=0cm] (#1-l) at ($(#1-c) + (-1, 0)$) {};
    \node[inner sep=0cm] (#1-r) at ($(#1-c) + (1, 0)$) {};
    \node[inner sep=0cm] (#1-u) at ($(#1-c) + (0, 1)$) {};
    \node[inner sep=0cm] (#1-d) at ($(#1-c) + (0, -1)$) {};
    \draw
    ($(#1-c) + (-1, 0)$) -- ($(#1-c) + (0, 1)$) -- ($(#1-c) + (1, 0)$) -- ($(#1-c) + (0, -1)$) -- cycle;
}

% actual document
\begin{document}
    \section*{CO142 - Discrete Structures}
        \subsection*{Prelude}
            The content discussed here is part of CO142 - Discrete Structures (Computing MEng); taught by Steffen van Bakel, in Imperial College London during the academic year 2018/19. The notes are written for my personal use, and have no guarantee of being correct (although I hope it is, for my own sake). This should be used in conjunction with the (extremely detailed) notes.
        \subsection*{9th October 2018}
            \subsubsection*{Recommended Books}
                \begin{itemize}
                    \itemsep0em
                    \item K.H. Rosen. \textit{Discrete Mathematics and its Applications}
                    \item J.L. Gersting. \textit{Mathematical Structures for Computer Science}
                    \item J.K. Truss. \textit{Discrete Mathematics for Computer Science}
                    \item R. Johsonbaugh. \textit{Discrete Mathematics}
                    \item C. Schumacher. \textit{Fundamental Notions of Abstract Mathematics}
                \end{itemize}
                However, these books don't cover the same content. Learn his notation.
            \subsubsection*{Logical Formula, and Notation}
                This notation will be shared with \textbf{CO140}.
                \begin{itemize}
                    \itemsep0em
                    \item $A \land B$ \hfill $A$ and $B$ both hold
                    \item $A \lor B$ \hfill $A$ or $B$ holds (or both)
                    \item $\neg A$ \hfill $A$ does not hold
                    \item $A \Rightarrow B$ \hfill if $A$ holds, then so does $B$
                    \item $A \Leftrightarrow B$ \hfill $A$ holds if and only if $B$ holds
                    \item $\forall x (A)$ \hfill the predicate $A$ holds for all $x$
                    \item $\exists x (A)$ \hfill the predicate $A$ holds for some $x$
                    \item $a \in A$ \hfill the object $a$ is in the set $A$ ($a$ is an element of     \item $A$)
                    \item $a \notin A$ \hfill the object $a$ is not in the set $A$
                    \item $=_A$ \hfill tests whether two elements of $A$ are the same
                \end{itemize}
            \subsubsection*{Sets}
                Sets are like data types in Haskell: Haskell data type declaration;
                \begin{itemize}
                    \itemsep0em
                    \item \texttt{data Bool = False | True}
                    \item \texttt{\{false, true\}} \hfill set of boolean values
                    \item \texttt{[true, false, true, false]} \hfill list of boolean values
                    \item \texttt{\{false, true\} = \{true, false\}} \hfill set equality (note that order doesn't matter)
                \end{itemize}
                A set is a collection of objects from a pool of objects. Each object is an \textit{element}, or a \textit{member} of the set. A set \textit{contains} its elements. Sets can be defined in the following ways;
                \begin{itemize}
                    \itemsep0em
                    \item $\{a_1, ..., a_2\}$ \hfill as a collection of $n$ distinct elements
                    \item $\{x \in A\ |\ P(x)\}$ \hfill for all the elements in $A$, where $P$ holds
                    \item $\{x\ |\ P(x)\}$ \hfill for all elements, where $P$ holds (dangerous - Russel's paradox)
                \end{itemize}
            \subsubsection*{Use of "triangleq"}
                The use of $\triangleq$ is for "is defined by". Hence the empty set, $\varnothing \triangleq \{\}$. The difference between $\triangleq$ and $=$, is that the former cannot be proven, it is fact, whereas the latter takes work to prove.
            \subsubsection*{Russel's paradox}
                Not everything we write as $\{x\ |\ P(x)\}$ is automatically a set. Assume $R = \{X\ |\ X \notin X\}$ is a set, the set of all sets which don't contain themselves. As $R$ is a set, then $R \in R$, or $R \notin R$ (law of excluded middle), and thus we can do a case by case analysis.
                \begin{itemize}
                    \itemsep0em
                    \item Assume $R \in R$. By the definition of $R$, it then follows that $R \notin R$ (if $R \in R$, then it doesn't satisfy the definition of $R$) - which is a contradiction.
                    \item Assume $R \notin R$. It then follows that $R \in R$, as it follows the definition of $R$, hence it is another contradiction.
                \end{itemize}
                As both assumptions lead to contradictions, it's possible to write sets which aren't defined. We should only select from a set that we know is defined; $\{x \in A\ |\ P(x)\}$ - where $A$ is a well-defined set.
        \subsection*{12th October 2018}
\end{document}