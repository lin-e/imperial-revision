\documentclass[a4paper, 12pt]{article}
    % packages
    \usepackage{amssymb}
    \usepackage[fleqn]{mathtools}
    \usepackage{tikz}
    \usepackage{enumerate}
    \usepackage{bussproofs}
    \usepackage{xcolor}
    \usepackage[margin=1.3cm]{geometry}
    \usepackage{logicproof}

    % augmented matrix
    \makeatletter
    \renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
    \hskip -\arraycolsep
    \let\@ifnextchar\new@ifnextchar
    \array{#1}}
    \makeatother

    % ceiling / floor
    \DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
    \DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

    % custom commands
    \newcommand{\indefint}[2]{\int #1 \, \mathrm{d}#2}
    \newcommand{\defint}[4]{\int_#1^#2 #3 \, \mathrm{d}#4}
    \newcommand{\dif}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}}
    \newcommand{\limit}[2]{\displaystyle{\lim_{#1 \to #2}}}
    \newcommand{\summation}[3]{\sum\limits_{#1}^#2 #3}
    \newcommand{\intbracket}[3]{\left[#3\right]_#1^#2}

    \newcommand{\powerset}[0]{\wp}
    \renewcommand{\emptyset}[0]{\varnothing}

    \newcommand{\unaryproof}[2]{\AxiomC{#1} \UnaryInfC{#2} \DisplayProof}
    \newcommand{\binaryproof}[3]{\AxiomC{#1} \AxiomC{#2} \BinaryInfC{#3} \DisplayProof}

    % no indent
    \setlength\parindent{0pt}

    % reasoning proofs
    \newcommand{\proofline}[3]{(#1)\ & #2 & \text{#3} \\}
    \allowdisplaybreaks

    % actual document
    \begin{document}
        \section*{CO140 - Logic}
        \subsection*{Introduction}
        A logic system consists of 3 things:
        \begin{enumerate}[1.]
            \item Syntax - formal language used to express concepts
            \item Semantics - meaning for the syntax
            \item Proof theory - syntactic way of identifying valid statements of language
        \end{enumerate}
        Considering the basic example in a program, we can then see the features;
        \begin{verbatim}
if count > 0 and not found then
    decrement count;
    look for next entry;
end if
        \end{verbatim}
        \begin{enumerate}[1.]
            \item basic (\textbf{atomic}) statements (\textbf{propositions}) are either $\top$ or $\bot$ depending on circumstance;
                \begin{enumerate}[i.]
                    \item \texttt{count > 0}
                    \item \texttt{found}
                \end{enumerate}
            \item \textbf{boolean operations}, such as \texttt{and}, \texttt{or}, \texttt{not}, etc. are used to build complex statements from \textbf{atomic propositions}
            \item the final statement \texttt{count > 0 and not found} evalulates to either $\top$ or $\bot$
        \end{enumerate}
        \subsection*{Syntax}
        The formal language of logic consists of three ingredients;
        \begin{enumerate}[1.]
            \item Propositional atoms (propositional variables), evaluate to a truth value of either $\top$ or $\bot$. These are represented with letters; $p, p^\prime, p_0, p_1, p_2, p_n, q, r, s, ...$
            \item Boolean connectives;
                \begin{itemize}
                    \item \texttt{and} is written as $p \land q$ \hfill $p$ and $q$ both hold
                    \item \texttt{or} is written as $p \lor q$ \hfill $p$ or $q$ holds (or both)
                    \item \texttt{not} is written as $\neg p$ \hfill $p$ does not hold
                    \item \texttt{if-then / implies} is written as $p \rightarrow q$ \hfill if $p$ holds, then so does $q$
                    \item \texttt{if-and-only-if} is written as $p \leftrightarrow q$ \hfill $p$ holds if and only if $q$ holds
                    \item \texttt{truth}, and \texttt{falsity} are written as $\top$, and $\bot$ respectively. \hfill logical constants
                \end{itemize}
            \item Punctuation. Similar to arithmetic, the lack of brackets can make an expression ambiguous. For example, $p_0 \lor p_1 \land p_2$ can be read as either $(p_0 \lor p_1) \land p_2$ or $p_0 \lor (p_1 \land p_2)$, which are different. The latter is the correct interpretation due to binding conventions.
                \subitem We can order the boolean connectives by decreasing binding strength;
                \subitem (strongest) $\neg,\ \land,\ \lor,\ \rightarrow,\ \leftrightarrow$ (weakest)
                \subitem While repeated disjunctions ($\lor$), and conjunctions ($\land$) are fine, as $p \land q \land r$ is equivalent to $p \land (q \land r)$, and the same for $\lor$, due to associativity, the same isn't true for $\rightarrow$. Due to the ambiguity, brackets should always be used.
                \subitem There are also exceptions to the rule, for example with $p \rightarrow r \land q \rightarrow r$ - this should be $p \rightarrow (r \land q) \rightarrow r$ according to our binding conventions, but brackets should be used to ensure the correct interpretation.
        \end{enumerate}
        \subsection*{Formulas}
        Something is a \textbf{well-formed formula} only if it is built from the following rules (the brackets are required);
        \begin{enumerate}[1.]
            \item a propositional atom ($p, p^\prime, p_0, p_1, p_2, p_n, q, r, s, ...$) is a propositional formula
            \item $\top$, and $\bot$ are both formulas
            \item if $A$ is a formula, then $(\neg A)$ is also a formula
            \item if $A$, and $B$ are both formulas, then $(A \land B), (A \lor B), (A \rightarrow B), (A \leftrightarrow B)$ are also formulas
        \end{enumerate}
        We can also create a tree to parse a logical formula, for example; $(\neg p \rightarrow r) \land (q \rightarrow r)$

        \begin{center}
            \begin{tikzpicture}
                \node[] (o) at (0, 0) {$\textcolor{blue}{\land}\ (\neg p \rightarrow r) \land (q \rightarrow r)$};
                \node[] (ol) at (-2, -1.5) {$\textcolor{blue}{\rightarrow}\ \neg p \rightarrow r$};
                \node[] (or) at (2, -1.5) {$\textcolor{blue}{\rightarrow}\ q \rightarrow r$};
                \node[] (oll) at (-3, -3) {$\textcolor{blue}{\neg}\ \neg p$};
                \node[] (olr) at (-1, -3) {$\textcolor{red}{r}$};
                \node[] (orl) at (1, -3) {$\textcolor{red}{q}$};
                \node[] (orr) at (3, -3) {$\textcolor{red}{r}$};
                \node[] (ollc) at (-3, -4.5) {$\textcolor{red}{p}$};
                \draw
                (o) edge[] node{} (ol)
                (o) edge[] node{} (or)
                (ol) edge[] node{} (oll)
                (ol) edge[] node{} (olr)
                (or) edge[] node{} (orl)
                (or) edge[] node{} (orr)
                (oll) edge[] node{} (ollc);
            \end{tikzpicture}
        \end{center}
        Note that this tree shows the principal connective in \textcolor{blue}{blue}, and the propositional atoms in \textcolor{red}{red}. Note that $\land$ is the principal connective in the top layer, and it therefore has the general form $A \land B$, and so on going down.
        \subsection*{Technical terms}
        \begin{itemize}
            \item A formula is a \textbf{negated formula} when it is in the form $\neg A$, negated atoms are sometimes called \textbf{negated-atomic}.
            \item $A \land B$, and $A \lor B$ are \textbf{conjunctions}, and \textbf{disjunctions}. $A$, and $B$, are \textbf{conjuncts}, and \textbf{disjuncts}, respectively.
            \item $A \rightarrow B$ is an implication. $A$ is the \textbf{antecedent}, and $B$ is the \textbf{consequent}
        \end{itemize}
        \subsection*{Semantics}
        The connectives covered above have a rough English translation. However a natural language has ambiguity, and as engineers, we need precise meanings for formulas. This is the truth table for every connective that will be used in this course (?):
        \begin{center}
            \begin{tabular}{||c|c||c|c|c|c|c|c|c||c||}
                \hline
                $p$ & $q$ & $\top$ & $\bot$ & $p \land q$ & $p \lor q$ & $\neg p$ & $p \rightarrow q$ & $p \leftrightarrow q$ & $p \uparrow q$ \\
                \hline
                0 & 0 & 1 & 0 & 0 & 0 & 1 & 1 & 1 & 1\\
                0 & 1 & 1 & 0 & 0 & 1 & 1 & 1 & 0 & 1\\
                1 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 1\\
                1 & 1 & 1 & 0 & 1 & 1 & 0 & 1 & 1 & 0\\
                \hline
            \end{tabular}
        \end{center}
        Note how we can also define new connectives (see how $A \uparrow B$ was defined in the last column); this is a NAND connective - equivalent to $\neg (A \land B)$.
        \subsection*{Translation}
        \subsubsection*{English to Logic}
        \begin{itemize}
            \item \textbf{but} means \texttt{and}
                \subitem "I will go out, but it is raining" \hfill $\texttt{(i will go out)} \land \texttt{(it is raining)}$
            \item \textbf{unless} generally means \texttt{or}
                \subitem "I will go out unless it rains" \hfill $\texttt{(i will go out)} \lor \texttt{(it will rain)}$ (note the \texttt{will})
                \subitem \hfill $\neg\texttt{(it will rain)} \rightarrow \texttt{i will go out}$
                \subitem There is also the strong form of \textbf{unless}, but in we generally use the weak form in computing
                \subitem \hfill $\texttt{(i will go out)} \leftrightarrow \neg\texttt{(it will rain)}$
            \item \textbf{or} generally refers to exclusive or (strong reading) in English, but it can also refer to inclusive or (weak reading). However, we always take the weak reading in computing.
        \end{itemize}
        \subsubsection*{Modality}
        \texttt{I don't know what this means, so I'm just ignoring it for now}
        \subsubsection*{Logic to English}
        While the others are slightly more straightforward, $\rightarrow$ is a pain to translate.

        For example, $\texttt{(i am the pope)} \rightarrow \texttt{(i am an atheist)}$ is true, as falsity implies anything, however if we were to translate it into English, "If I am the Pope, then I am an atheist" is (most likely) untrue.
    \end{document}
