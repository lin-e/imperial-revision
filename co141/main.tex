\documentclass[a4paper, 12pt]{article}
% packages
\usepackage{amssymb}
\usepackage[fleqn]{mathtools}
\usepackage{tikz}
\usepackage{enumerate}
\usepackage{bussproofs}
\usepackage{xcolor}
\usepackage[margin=1.3cm]{geometry}
\usepackage{logicproof}
\usepackage{diagbox}

% augmented matrix
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
\hskip -\arraycolsep
\let\@ifnextchar\new@ifnextchar
\array{#1}}
\makeatother

% ceiling / floor
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

% custom commands
\newcommand{\indefint}[2]{\int #1 \, \mathrm{d}#2}
\newcommand{\defint}[4]{\int_{#1}^{#2} #3 \, \mathrm{d}#4}
\newcommand{\dif}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}}
\newcommand{\limit}[2]{\displaystyle{\lim_{#1 \to #2}}}
\newcommand{\summation}[3]{\sum\limits_{#1}^{#2} #3}
\newcommand{\intbracket}[3]{\left[#3\right]_{#1}^{#2}}

\newcommand{\powerset}[0]{\wp}
\renewcommand{\emptyset}[0]{\varnothing}

\newcommand{\unaryproof}[2]{\AxiomC{#1} \UnaryInfC{#2} \DisplayProof}
\newcommand{\binaryproof}[3]{\AxiomC{#1} \AxiomC{#2} \BinaryInfC{#3} \DisplayProof}

% no indent
\setlength\parindent{0pt}

% reasoning proofs
\usepackage{ltablex}
\usepackage{environ}
\keepXColumns
\NewEnviron{reasoning}{
    \begin{tabularx}{\textwidth}{rlX}
        \BODY
    \end{tabularx}
}
\newcommand{\proofline}[3]{$(#1)$ & $#2$ & \hfill #3 \smallskip \\}
\newcommand{\proofarbitrary}[1]{& take arbitrary $#1$ \smallskip \\}
\newcommand{\prooftext}[1]{\multicolumn{3}{l}{#1} \smallskip \\}
\newcommand{\proofeq}[3]{$#1$ & = $#2$ & \hfill #3 \smallskip \\}
\newcommand{\prooftherefore}[1]{& $\therefore #1$ \smallskip \\}
\newcommand{\proofbc}[0]{\prooftext{\textbf{Base Case}}}
\newcommand{\proofis}[0]{\prooftext{\textbf{Inductive Step}}}

% actual document
\begin{document}
    \section*{CO141 - Reasoning About Programs}
        \subsection*{Prelude}
            The content discussed here is part of CO141 - Reasoning About Programs (Computing MEng); taught by Sophia Drossopoulou, and Mark Wheelhouse, in Imperial College London during the academic year 2018/19. The notes are written for my personal use, and have no guarantee of being correct (although I hope it is, for my own sake). This should be used in conjunction with the (extremely detailed) notes.
        \subsection*{Material Order}
            These notes are primarily based off the notes on CATe, as they cover the lecture slides in great detail. This is the order in which they are uploaded (and I'd assume the order in which they are taught).
            \begin{enumerate}[1.]
                \itemsep0em
                \item \textit{Introduction and Motivation (full notes).pdf}
                \item \textit{Stylised Proofs (full notes).pdf}
                \item \textit{Induction over natural numbers (full notes).pdf}
                \item \textit{Induction over Haskell data structures (full notes).pdf}
                \item \textit{Induction over recursive relations and functions (full notes).pdf}
                \item \textit{Java - Program Specifications (full notes).pdf}
                \item \textit{Java - Conditional Branches (full notes).pdf}
                \item \textit{Java - Method Calls (full notes).pdf}
                \item \textit{Java - Recursion (full notes).pdf}
                \item \textit{Java - Iteration Informal (full notes).pdf}
                \item \textit{Java Reasoning - summary.pdf}
                \item \textit{Loop case study.pdf}
                \item \textit{Java - Iteration Formal (full notes).pdf}
                \item \textit{Case Studies - overview (full notes).pdf}
                \item \textit{Case Studies - Dutch Flag Problem (full notes).pdf}
                \item \textit{Quicksort (full notes).pdf}
            \end{enumerate}
        \subsection*{Introduction}
            This module will cover Proof by Induction from first principles, and shows how a recursive definition can implicitly introduce an inductive principle, how the inductive principle introduces a proof schema, and how the schema can be used to prove a property of a inductively defined set, relation or function. This will go into more detail regarding valid uses of quantifiers, when we're able to use the induction hypothesis, how auxiliary lemmas can help, as well as what cases we will need to strengthen properties to prove weaker ones.
        \subsection*{Binding Conventions}
            The binding conventions in this module are the same as the ones used in \textbf{CO140 - Logic}; with the addition of $\forall x$, and $\exists x$ before $\neg$.
        \subsection*{Formalising a Proof}
            For this section, we'll work on one example proof, with the given facts;
            \begin{enumerate}[(1)]
                \itemsep0em
                \item a person is happy if all their children are rich
                \item someone is a supervillain if at least one of their parents is a supervillain
                \item all supervillains are rich
            \end{enumerate}
            We want to show that "all supervillains are happy".
            \subsubsection*{Proof in Natural Language}
                The given argument is that "All of a supervillain's children must therefore also be supervillains; and as all supervillains are rich, all the children of a supervillain are rich. Therefore, any supervillain is happy". However; we've made a few assumptions in this proof - we assume that a supervillain is always a person, and that a supervillain has children (as well as the fact that parent, and child aren't formally defined to be related concepts).
                \medskip

                Therefore, we need to generalise statement (1) OR add an additional assumption (4);
                \begin{enumerate}[(1)]
                    \itemsep0em
                    \item \textbf{someone} is happy if all their children are happy
                    \setcounter{enumi}{3}
                    \item a supervillain is also a person
                \end{enumerate}
            \subsubsection*{Formal Argument}
                \begin{reasoning}
                    \prooftext{Given:}
                    \proofline{1}{\forall x [\text{person}(x) \land \forall y [\text{childof}(y, x) \rightarrow \text{rich}(y)] \rightarrow \text{happy}(x)]}{}
                    \proofline{2}{\forall x [\exists y [\text{childof}(x, y) \land \text{supervillain}(y)] \rightarrow \text{supervillain}(x)]}{}
                    \proofline{3}{\forall x [\text{supervillain}(x) \rightarrow \text{rich}(x)]}{}
                    \proofline{4}{\forall x [\text{supervillain}(x) \rightarrow \text{person}(x)]}{}
                    \prooftext{To show:}
                    \proofline{\alpha}{\forall x [\text{supervillain}(x) \rightarrow \text{happy}(x)]}{}
                    \prooftext{(Stylised) Proof:}
                    \proofarbitrary{G}
                    \proofline{\text{a}1}{\text{supervillain}(G)}{}
                    \proofline{5}{\text{person}(G) \land \forall y [\text{childof}(y, G) \rightarrow \text{rich}(y)] \rightarrow \text{happy}(G)}{from (1)}
                    \proofline{6}{\text{person}(G)}{from (a1), and (4)}
                    \proofarbitrary{E}
                    \proofline{\text{a}2}{\text{childof}(E, G)}{}
                    \proofline{7}{\text{supervillain}(E)}{from (a1), (a2), and (2)}
                    \proofline{8}{\text{rich}(E)}{from (3), and (7)}
                    \proofline{9}{\forall y [\text{childof}(y, G) \rightarrow \text{rich}(y)]}{from (a2), (8), and arbitrary $E$}
                    \proofline{10}{\text{happy}(G)}{from (5), (6), and (9)}
                    \proofline{\alpha}{}{from (a1), (10), and arb. $G$}
                \end{reasoning}
                While this can be proven fairly easily, and with great confidence, via first-order natural deduction, the proof is often tedious, and the intuition might be lost. On the other hand, stylised proofs have an explicit structure, few errors (compared to free-form) - although errors are still possible.
                \medskip

                Our goal for our proofs are that they should only prove valid statements, are easy to read / check, and are able to highlight intuition behind arguments. The rules for a stylised proof are as follows;
                \begin{enumerate}[1.]
                    \itemsep0em
                    \item write out, and name each given formula
                    \item write out, and name each goal formula
                    \item plan out proof, and name intermediate results
                    \item justify each step
                    \item size of each step can vary as appropriate
                \end{enumerate}
                Planning, and justifying the the steps follow extrmeely similar rules to natural deduction - the rules for proving $P$ are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item $P = Q \land R$ \hfill prove both $Q$, and $R$ ($\land$I)
                    \item $P = Q \lor R$ \hfill prove either $Q$, or $R$ ($\lor$I)
                    \item $P = Q \rightarrow R$ \hfill prove $R$ from assuming $Q$ ($\rightarrow$I)
                    \item $P = \neg Q$ \hfill prove $\bot$ from asuming $Q$ ($\neg$I)
                    \item $P = \forall x [Q(x)]$ \hfill show $Q(c)$ from arbitrary $c$ ($\forall$I)
                    \item $P = \exists x [Q(x)]$ \hfill find some $c$, and show $Q(c)$ ($\exists$I)
                    \item $P$ \hfill prove $\bot$ from assuming $\neg P$ (PC)
                \end{itemize}
                On the other hand, if we have proven $P$, we can do the following;
                \begin{itemize}
                    \itemsep0em
                    \item $P = Q \land R$ \hfill both $Q$, and $R$ hold ($\land$E)
                    \item $P = Q \lor R$ \hfill case analysis ($\lor$I)
                    \item $P = Q \land (Q \rightarrow R)$ \hfill $R$ holds ($\rightarrow$E)
                    \item $P = \forall x [Q(x)]$ \hfill $Q(c)$ holds for any $c$ ($\forall$E)
                    \item $P = \exists x [Q(x)]$ \hfill $Q(c)$ holds for some $c$ ($\exists$E)
                    \item $P = \bot$ \hfill anything holds ($\bot$E)
                    \item $P = \neg Q$ \hfill $Q \rightarrow \bot$ holds ($\neg$E)
                    \item $P$ \hfill use a lemma, or any logical equivalence
                \end{itemize}
            \subsubsection*{Another Example}
                \begin{reasoning}
                    \prooftext{Facts in Natural Language:}
                    \proofline{\text{i}}{\text{a dragon is happy if all of its children can fly}}{}
                    \proofline{\text{ii}}{\text{all green dragons can fly}}{}
                    \proofline{\text{iii}}{\text{something is green if at least one of its parents is green}}{}
                    \proofline{\text{iv}}{\text{all the children of a dragon are also dragons}}{}
                    \proofline{\text{v}}{\text{if $y$ is a child of $x$, then $x$ is a parent of $y$}}{}
                    \prooftext{Given:}
                    \proofline{1}{\forall x [\text{dragon}(x) \land \forall y [\text{childof}(x, y) \rightarrow \text{fly}(y)] \rightarrow \text{happy(x)}]}{from (i)}
                    \proofline{2}{\forall x [\text{green}(x) \land \text{dragon}(x) \rightarrow \text{fly}(x)]}{from (ii)}
                    \proofline{3}{\forall x [\exists y [\text{parentof}(y, x) \land \text{green}(y)] \rightarrow \text{green}(y)]}{from (iii)}
                    \proofline{4}{\forall x [\forall y [\text{childof}(x, y) \land \text{dragon}(y) \rightarrow \text{dragon}(x)]]}{from (iv)}
                    \proofline{5}{\forall x [\forall y [\text{childof}(y, x) \rightarrow \text{parentof}(x, y)]]}{from (v)}
                    \prooftext{To show:}
                    \proofline{\alpha}{\forall x [\text{dragon}(x) \rightarrow (\text{green}(x) \rightarrow \text{happy}(x))]}{}
                    \proofline{\times}{\forall x [\text{dragon}(x) \land \text{green}(x) \rightarrow \text{happy}(x)]}{(note - equivalent)}
                    \prooftext{Proof:}
                    \proofarbitrary{S}
                    \proofline{\text{a}1}{\text{dragon}(S)}{}
                    \proofline{\text{a}2}{\text{green}(S)}{}
                    \proofline{6}{\forall x \forall y [\text{parentof}(y, x) \land \text{green}(y) \rightarrow \text{green}(x)]}{from (3)}
                    \proofline{7}{\forall x \forall y [\text{childof}(x, y) \land \text{green(y)} \rightarrow \text{green}(x)]}{from (5), and (6)}
                    \proofline{8}{\forall x [\text{childof}(x, S) \rightarrow \text{green}(x)]}{from (a2), and (7)}
                    \proofline{9}{\forall x [\text{childof}(x, S) \rightarrow \text{dragon}(x)]}{from (a1), and (4)}
                    \proofline{10}{\forall x [\text{childof}(x, S) \rightarrow \text{green}(x) \land \text{dragon}(x)]}{from (8), and (9)}
                    \proofline{11}{\forall x [\text{childof}(x, S) \rightarrow \text{fly}(x)]}{from (2), and (10)}
                    \proofline{12}{\text{happy}(S)}{from (a1), (1), and (11)}
                    \proofline{\alpha}{}{from (a1), (a2), (12), and arb. $S$}
                \end{reasoning}
                Steps (6), (7), and (10) in particular require more justification; the justification of (7) requires us to prove something else, which can be done trivially with ND. Therefore only (6) will be proven;
                \begin{reasoning}
                    \prooftext{Given:}
                    \proofline{1}{\forall x [\exists y [P(x, y)] \rightarrow Q(x)]}{}
                    \prooftext{To show:}
                    \proofline{\alpha}{\forall x \forall y [P(x, y) \rightarrow Q(x)]}{}
                    \prooftext{Proof:}
                    \proofarbitrary{c_1}
                    \proofarbitrary{c_2}
                    \proofline{\text{a}1}{P(c_1, c_2)}{}
                    \proofline{2}{\exists y [P(c_1, y)] \rightarrow Q(c_1)}{from (1), where $x = c_1$}
                    \proofline{3}{\exists y [P(c_1, y)]}{from (a1), where $c_2 = y$}
                    \proofline{4}{Q(c_1)}{from (2), and (3)}
                    \proofline{\alpha}{}{from (a1), (4), and arbitrary $c_1$, $c_2$}
                \end{reasoning}
                Note that (7) requires us to prove $\forall u \forall v [R(v, y) \rightarrow Q(u, v)] \land \forall w \forall z [Q(z, w) \land S(z) \rightarrow S(w)] \rightarrow \forall x \forall y [R(x, y) \land S(y)\rightarrow S(x)]$, which isn't actually as difficult as it looks (only 16 lines in steps in ND). On the other hand, the proof for (10) requires $(A \rightarrow B) \land (A \rightarrow C) \rightarrow (A \rightarrow B \land C)$ - assume $A$, and you get both $B$, and $C$ very quickly.
        \subsection*{Induction over Natural Numbers}
            The notation used here is as follows; $\forall x : S [P(x)]$, where $S$ is an \textbf{enumerable} set and $P \subseteq S$. Note that the notes use $\forall x : S.P(x)$, but I'm choosing to use the same notation as used in \textbf{CO140}, just to maintain consistency. The notation $P \subseteq S$ means that $P$ is a property of elements in the set $S$. $\text{pos} \subset \mathbb{Z}$. The natural numbers, sequences, strings, or recursively defined data structures are enumerable sets, whereas $\mathbb{R}$ is not an enumerable set. These are some examples of enumerable sets;
            \begin{itemize}
                \itemsep0em
                \item $\forall n : \mathbb{N} [7^n + 5 \text{ is divisible by 3}]$
                \item $\forall \texttt{xs}:\texttt{[a]}\forall \texttt{ys}:\texttt{[a]}[\texttt{length(xs ++ ys)} = \texttt{length(xs)} + \texttt{length(ys)}]$
            \end{itemize}
            \subsubsection*{Mathematical Induction Principle}
                For any $P \subseteq \mathbb{N}$: $P(0) \land \forall k : \mathbb{N}[P(k) \rightarrow P(k + 1)] \rightarrow \forall n : \mathbb{N}[P(n)]$
                \medskip

                This mirrors the definition in \textbf{CO142 - Discrete Structures}, by using Peano's axiom. Given a unary preducate $P$, and $P(0)$ is true, and for all natural numbers $k$, if $P(k)$ is true, then it follows that $P(\text{Succ}(k))$ is true. Then it follows that $P(n)$ is true for every natural number $n \in \mathbb{N}$.
            \subsubsection*{Example - Sum of Natural Numbers}
                We want to prove $P(n)$, where $P(n) \triangleq \summation{i = 0}{n}{i} = \frac{n(n + 1)}{2}$ - a formula which we should be used to seeing.
                \smallskip

                We need to formally write this as;
                \medskip

                $\textcolor{blue}{\summation{i = 0}{0}{i} = \frac{0(0 + 1)}{2}} \land \textcolor{red}{\forall k : \mathbb{N} [\summation{i = 0}{k}{i} = \frac{k(k + 1)}{2} \rightarrow \summation{i = 0}{k + 1}{i} = \frac{(k + 1)((k + 1) + 1)}{2}]} \rightarrow \textcolor{violet}{\forall n : \mathbb{N} [\summation{i = 0}{n}{i} = \frac{n(n + 1)}{2}]}$
                \bigskip

                Remember that our aim is to create proofs that can be checked by others. This means justifying each step; writing what we know (givens), and what we aim to prove. All the steps should be explicit, but the granularity can vary depending on the confidence of the step. Intermediate results should be named, so that they can be used later, and variables that we are applying the induction principle on should be stated.

                \begin{reasoning}
                    \proofbc
                    \prooftext{Our aim here is to show $\summation{i = 0}{0}{i} = \frac{0(0 + 1)}{2}$}
                    \proofeq{\summation{i = 0}{0}{i}}{0}{by definition of $\sum$}
                    \proofeq{}{\frac{0(1)}{2}}{by arithmetic}
                    \proofeq{}{\frac{0(0 + 1)}{2}}{by arithmetic}
                    \proofis
                    \prooftext{Take arbitrary $k : \mathbb{N}$}
                    \prooftext{Inductive hypothesis: $\summation{i = 0}{k}{i} = \frac{k(k + 1)}{2}$}
                    \prooftext{To show: $\summation{i = 0}{k+1}{i} = \frac{(k + 1)((k + 1) + 1)}{2}$}
                    \proofeq{\summation{i = 0}{k + 1}{i}}{\summation{i = 0}{k}{i} + (k + 1)}{by definition of $\sum$}
                    \proofeq{}{\frac{k(k + 1)}{2} + (k + 1)}{\textcolor{blue}{by inductive hypothesis}}
                    \proofeq{}{\frac{k^2 + 3k + 2}{2}}{by arithmetic}
                    \proofeq{}{\frac{(k + 1)(k + 2)}{2}}{by arithmetic}
                    \proofeq{}{\frac{(k + 1)((k + 1) + 1)}{2}}{by arithmetic}
                \end{reasoning}
            \subsubsection*{Example - $7^n + 5$ is divisible by 3}
                We want to prove $P(n)$, where $P(n) \triangleq 7^n + 5 \text{ is divisible by 3}$. However, this isn't exactly a very formal defined, so we will rewrite it as $P(n) \triangleq \exists m : \mathbb{N}[7^n + 5 = 3m]$
                \smallskip

                We need to formally write this as;
                \medskip

                $\textcolor{blue}{\exists m : \mathbb{N} [7^0 + 5 = 3m]} \land \textcolor{red}{\forall k : \mathbb{N} [\exists m : \mathbb{N}[7^k + 5 = 3m] \rightarrow \exists m^\prime : \mathbb{N} [7^{k + 1} + 5 = 3m^\prime]]} \rightarrow \\ \textcolor{violet}{\forall n : \mathbb{N} [\exists m : \mathbb{N} [7^n + 5 = 3m]]}$

                \begin{reasoning}
                    \proofbc
                    \prooftext{Our aim here is to show $\exists m : \mathbb{N}[7^0 + 5 = 3m]$}
                    \proofeq{7^0 + 5}{1 + 5}{by arithmetic}
                    \proofeq{}{6}{by arithmetic}
                    \proofeq{}{3 \cdot 2}{by arithmetic}
                    \prooftherefore{\exists m : \mathbb{N}[7^0 + 5 = 3m]}
                    \proofis
                    \prooftext{Take arbitrary $k : \mathbb{N}$}
                    \prooftext{Inductive hypothesis: $\exists m : \mathbb{N} [7^k + 5 = 3m]$}
                    \proofline{1}{7^k + 5 = 3 \cdot m_1}{by inductive hypothesis, for some $m_1 : \mathbb{N}$}
                    \prooftext{To show: $\exists m^\prime : \mathbb{N} [7^{k + 1} + 5 = 3m^\prime]$}
                    \proofeq{7^{k + 1} + 5}{7 \cdot 7^k + 5}{by arithmetic}
                    \proofeq{}{(6 + 1) \cdot 7^k + 5}{by arithmetic}
                    \proofeq{}{(6 \cdot 7^k + 7^k) + 5}{by arithmetic}
                    \proofeq{}{3 \cdot (2 \cdot 7^k) + (7^k + 5)}{by arithmetic}
                    \proofeq{}{3 \cdot (2 \cdot 7^k) + 3 \cdot m_1}{by (1)}
                    \proofeq{}{3 \cdot [2 \cdot 7^k + m_1]}{by arithmetic}
                    \prooftherefore{\exists m^\prime : \mathbb{N} [7^{k + 1} + 5 = 3m^\prime]}
                \end{reasoning}
            \subsubsection*{New Technique}
                Consider the Haskell program defined as;
                \begin{verbatim}
f :: Int -> Ratio Int
f 1 = 1/2
f n = 1/(n * (n + 1)) + f (n - 1)\end{verbatim}
                And, we want to prove $\forall n \geq 1 [\texttt{f } n = \frac{n}{n + 1}]$. However, we cannot directly apply the mathematic induction principle on this, since the conclusion has a different form, and it's not defined for \texttt{f} 0 - hence we have no base case. Instead, we can do one of the following approaches;
                \begin{enumerate}[1.]
                    \itemsep0em
                    \item prove $\forall n : \mathbb{N} [\textcolor{blue}{n \geq 1 \rightarrow} \texttt{ f } n = \frac{n}{n + 1}]$
                    \item prove $\forall n : \mathbb{N} [\texttt{f } (n \textcolor{blue}{+ 1}) = \frac{n \textcolor{blue}{+ 1}}{n \textcolor{blue}{+ 2}}]$
                    \item apply the mathematical induction technique
                \end{enumerate}
                For practice, we will do the first approach; first we must formally write this out as;
                \medskip

                $\textcolor{blue}{0 \geq 1 \rightarrow \texttt{ f } 0 = \frac{0}{0 + 1}} \land \textcolor{red}{\forall k : \mathbb{N} [(k \geq 1 \rightarrow \texttt{ f } k = \frac{k}{k + 1}) \rightarrow ((k + 1) \geq 1 \rightarrow \texttt{ f } (k + 1) = \frac{k + 1}{k + 2})]} \rightarrow \\ \textcolor{violet}{\forall n : \mathbb{N} [n \geq 1 \rightarrow \texttt{ f } n = \frac{n}{n + 1}]}$

                \begin{reasoning}
                    \proofbc
                    \prooftext{Our aim here is to show $0 \geq 1 \rightarrow \texttt{ f } 0 = \frac{0}{0 + 1}$}
                    \prooftext{This holds trivially, as we know $0 \geq 1$ is false, and anything follows from a falsity}
                    \proofis
                    \prooftext{Take arbitrary $k : \mathbb{N}$}
                    \prooftext{Inductive hypothesis: $k \geq 1 \rightarrow \texttt{ f } k = \frac{k}{k + 1}$}
                    \prooftext{To show: $(k + 1) \geq 1 \rightarrow \texttt{ f } (k + 1) = \frac{k + 1}{k + 2}$}
                    \proofline{1.0}{k = 0}{by case}
                    \proofline{1.1}{k + 1 = 1}{by arithmetic}
                    \proofline{1.2}{\texttt{f} (k + 1) = \frac{1}{2}}{by def. of \texttt{f}, and (1.1)}
                    \proofline{1.3}{\frac{k + 1}{k + 2} = \frac{1}{2}}{by (1.1)}
                    \prooftherefore{\texttt{f} (k + 1) = \frac{k + 1}{k + 2}$ & \hfill by (1.2), and (1.3)$ }
                    \proofline{2.0}{k > 0}{by case}
                    \proofline{2.1}{k \geq 1}{by case}
                    \proofline{2.2}{k + 1 \geq 2}{by (2.1), and arithmetic}
                    \proofline{2.3}{\texttt{f } (k + 1) = \frac{1}{(k + 1)(k + 2)} + \texttt{ f } k}{by (2.2), and def. of \texttt{f}}
                    \proofline{2.4}{\texttt{f } (k + 1) = \frac{1}{(k + 1)(k + 2)} + \frac{k}{k + 1}}{by (2.3), and inductive hypothesis}
                    \proofline{2.5}{\texttt{f } (k + 1) = \frac{1}{(k + 1)(k + 2)} + \frac{k(k + 2)}{(k + 1)(k + 2)}}{by (2.4), and arithmetic}
                    \prooftherefore{\texttt{f} (k + 1) = \frac{k + 1}{k + 2}$ & \hfill by (2.5), and arithmetic$ }
                \end{reasoning}
                The third approach follows this; for any $P \subseteq \mathbb{Z}$, and any $m : \mathbb{Z}$, we have $P(m) \land \forall k \geq m [P(k) \rightarrow P(k + 1)] \rightarrow \forall n \geq m [P(n)]$. This uses $\forall n \geq m [P(n)]$, as a shorthand for $\forall n : \mathbb{Z} [n \geq m \rightarrow P(n)]$. Note how this isn't any different from the principle; in reality, the principle is a "specific case" of the technique, where $m = 0$. % if you're at king's, and think natural numbers start at 1, you're wrong.
                \medskip

                Now, using the technique with $m = 1$, we can do the original proof inductively;
                \medskip

                $\textcolor{blue}{\texttt{f } 1 = \frac{1}{1 + 1}} \land \textcolor{red}{\forall k \geq 1 [\texttt{f } k = \frac{k}{k + 1} \rightarrow \texttt{ f } (k + 1) = \frac{k + 1}{k + 2}]} \rightarrow \textcolor{violet}{\forall n \geq 1 [\texttt{f } n = \frac{n}{n + 1}]}$

                \begin{reasoning}
                    \proofbc
                    \prooftext{Our aim here is to show $\texttt{f } 1 = \frac{1}{ 1+ 1}$}
                    \proofeq{\texttt{f } 1}{\frac{1}{2}}{by def. of \texttt{f}}
                    \proofeq{}{\frac{1}{1 + 1}}{by arithmetic}
                    \proofis
                    \prooftext{Take arbitrary $k : \mathbb{Z}$}
                    \proofline{\text{a}1}{k \geq 1}{assumption}
                    \prooftext{Inductive hypothesis: $\texttt{f } k = \frac{k}{k + 1}$}
                    \prooftext{To show: $\texttt{f } (k + 1) = \frac{k + 1}{k + 2}$}
                    \proofeq{\texttt{f } (k + 1)}{\frac{1}{(k + 1)(k + 2)} + \texttt{f } k}{by def. of \texttt{f}, and (a1)}
                    \proofeq{}{\frac{1}{(k + 1)(k + 2)} + \frac{k}{k + 1}}{by inductive hypothesis}
                    \proofeq{}{\frac{1}{(k + 1)(k + 2)} + \frac{k(k + 2)}{(k + 1)(k + 2)}}{by arithmetic}
                    \proofeq{}{\frac{k^2 + 2k + 1}{(k + 1)(k + 2)}}{by arithmetic}
                    \proofeq{}{\frac{(k + 1)^2}{(k + 1)(k + 2)}}{by arithmetic}
                    \proofeq{}{\frac{k + 1}{k + 2}}{by arithmetic}
                \end{reasoning}
            \subsubsection*{Strong Induction}
                While mathematical induction is powerful, it only allows for the inductive step ($k + 1$) to refer to the direct predecessor ($k$). On the other hand, strong induction allows the inductive step to refer to any predecessor, such as $k - 1$, $k - 2$, and so on. For example, if an algorithm was to recurse down by two units, we wouldn't be able to use the inductive hypothesis to replace \texttt{g (k - 1)} from doing the inductive step on $k + 1$. An example of this is this Haskell program, with the property $\forall n : \mathbb{N} [\texttt{g } n = 3^n - 2^n]$;
                \begin{verbatim}
g :: Int -> Int
g 0 = 0
g 1 = 1
g n = (5 * g (n - 1)) - (6 * g (n - 2))\end{verbatim}
                As such, we need the principle of strong induction; $P(0) \land \forall k : \mathbb{N} [\forall j \in [0..k] [P(j)] \rightarrow P(k + 1)] \rightarrow \forall n : \mathbb{N} [P(n)]$. Here we are using the following shorthand; $j \in [m..n]$ means $m \leq j \leq n$, and similarly $j \in [m..n)$ means $m \leq j < n$. Complete induction has the same base case, where we need to verify $P(0)$, however, the inductive step differs as we have to assume that $P(i)$ holds for all $i \leq k$, then show that $P(k + 1)$ holds. If both of those hold, then it follows that $P(n)$ follows for all $n \in \mathbb{N}$ With this, we can now write down the strong induction principle on $\texttt{g } n = 3^n - 2^n$.
                \medskip

                $\textcolor{blue}{\texttt{g } 0 = 3^0 - 2^0} \land \textcolor{red}{\forall k [\forall j \in [0..k] [\texttt{g } j = 3^j - 2^j] \rightarrow \texttt{g } (k + 1) = 3^{k + 1} - 2^{k + 1}]} \rightarrow \textcolor{violet}{\forall n : \mathbb{N} [\texttt{g }n = 3^n - 2^n]}$
                \begin{reasoning}
                    \proofbc
                    \prooftext{Our aim here is to show $\texttt{g } 0 = 3^0 - 2^0$}
                    \proofeq{\texttt{g } 0}{0}{by def. of \texttt{g}}
                    \proofeq{}{1 - 1}{by arithmetic}
                    \proofeq{}{3^0 - 2^0}{by arithmetic}
                    \proofis
                    \prooftext{Take arbitrary $k : \mathbb{N}\ (k \neq 0)$}
                    \prooftext{Case 1: $k = 0$}
                    \prooftext{To show: $\texttt{g } 1 = 3^1 - 2^1$}
                    \proofeq{\texttt{g } 1}{1}{by def. of \text{g}}
                    \proofeq{}{3 - 2}{by arithmetic}
                    \proofeq{}{3^1 - 2^1}{by arithmetic}
                    \prooftext{Case 2: $k \neq 0$}
                    \proofline{1}{k \geq 1}{because $k : \mathbb{N}$, and $k \neq 0$ by case}
                    \proofline{2}{k, k - 1 \in [0..k]}{from (1)}
                    \prooftext{Inductive hypothesis: $\forall j \in [0..k] [\texttt{g } j = 3^j - 2^j]$}
                    \prooftext{To show: $\texttt{g } (k + 1) = 3^{k + 1} - 2^{k + 1}$}
                    \proofeq{\texttt{g } (k + 1)}{5 \cdot \texttt{g } k - 6 \cdot \texttt{g } (k - 1)}{by (1), and def. of \text{g}}
                    \proofeq{}{5 \cdot (3^k - 2^k) - 6 \cdot (3^{k - 1} - 2^{k - 1})}{by (2), and inductive hypothesis}
                    \proofeq{}{5 \cdot 3 \cdot 3^{k - 1} - 5 \cdot 2 \cdot 2^{k - 1} - 6 \cdot 3^{k - 1} + 6 \cdot 2^{k - 1}}{by arithmetic}
                    \proofeq{}{9 \cdot 3^{k - 1} - 4 \cdot 2^{k - 1}}{by arithmetic}
                    \proofeq{}{3^{k + 1} - 2^{k + 1}}{by arithmetic}
                \end{reasoning}
                Once again, this principle can be applied for some $m$, and is therefore modified to be $P(m) \land \forall k : \mathbb{Z} [\forall j \in [m..k] [P(j)] \rightarrow P(k + 1)] \rightarrow \forall n \geq m [P(n)]$. The same shorthand we used before applies here.
        \subsection*{Induction over Haskell Lists}
            The example we will be working on involves the follow Haskell functions;
            \begin{verbatim}
elem :: Eq a => a -> [a] -> Bool
elem x []     = False
elem x (y:ys) = x == y || elem x ys

subList :: Eq a => [a] -> [a] -> [a]
subList [] ys = []
subList (x:xs) ys
  | elem x ys = subList xs ys
  | otherwise = x:(subList xs ys)\end{verbatim}
            As well as the specification $\forall xs : \texttt{[a]} \forall ys : \texttt{[a]} \forall z : \texttt{a} [z \in ys \rightarrow z \not\in \texttt{subList } xs\ ys]$. Note that we use $z \in ys$ as shorthand for $\texttt{elem } z\ ys$. The function \texttt{subList} $xs$ $ys$ removes all elements of $ys$ from $xs$.
            \medskip

            The goal here is to prove $\forall xs : \texttt{[a]} [Q(xs)]$, where $Q(xs) \triangleq \forall ys : \texttt{[a]} \forall z : \texttt{a} [z \in ys \rightarrow z \not\in \texttt{subList }xs\ ys]$. Induction doesn't simply work here, as $Q$ isn't defined over a set of numbers, but rather over the lists of \texttt{a}. Once again, we can take multiple approaches to this problem;
            \begin{enumerate}[1.]
                \itemsep0em
                \item map lists to numbers, by expressing $Q \subseteq \texttt{[a]}$, with an eqiuvalent $P \subseteq \mathbb{N}$
                    \subitem there's a proof of this in \textit{Induction over Haskell data structures (full notes).pdf} - the point is that it's a bad idea, and structural induction should be used instead.
                    \subitem this method of reasoning is indirect - the property \texttt{length} is unrelated to $P$
                \item use structural induction
                    \subitem in a step of mathematical induction, we need to argue a property is inherited by the \textbf{predecessor} to its \textbf{successor}, such that 4 succeeds 3
                    \subitem this concept needs to be generalised to other data structures, for example; can we say \texttt{1:2:3:[]} is a successor to \texttt{2:3:[]}?
            \end{enumerate}
            \subsubsection*{Structural Induction Principle (Lists)}
                For any type $\texttt{T}$, and $P \subseteq \texttt{[T]}$; we can say $P(\texttt{[]}) \land \forall vs : \texttt{[T]} \forall v : \texttt{T} [P(vs) \rightarrow P(v : vs)] \rightarrow \forall xs : \texttt{[T]} [P(xs)]$
                \medskip

                Now, we can apply the structural induction principle to $xs$ for \texttt{subList};

                $\phantom{\forall vs : \texttt{[a]} \forall v : \texttt{a}[(} \textcolor{red}{\forall ys : \texttt{[a]} \forall z : \texttt{a} [z \in ys \rightarrow z \not\in \texttt{subList [] } ys]} \land \\ \textcolor{blue}{\forall vs : \texttt{[a]} \forall v : \texttt{a} [(\forall ys : \texttt{[a]} \forall z : \texttt{a} [z \in ys \rightarrow z \not\in \texttt{subList }vs\ ys]) \rightarrow} \\ \phantom{\forall vs : \texttt{[a]} \forall v : \texttt{a}[} \textcolor{blue}{(\forall ys : \texttt{[a]} \forall z : \texttt{a} [z \in ys \rightarrow z \not\in \texttt{subList }(v : vs)\ ys])]} \rightarrow \\ \phantom{\forall v : \texttt{a}(} \textcolor{violet}{\forall xs : \texttt{[a]}[\forall ys : \texttt{[a]} \forall z : \texttt{a} [z \in ys \rightarrow z \not\in \texttt{subList } xs\ ys]]}$ % i should really learn how to align things properly.
                \begin{reasoning}
                    \proofbc
                    \prooftext{Our aim here is to show $\forall ys : \texttt{[a]} \forall z : \texttt{a} [z \in ys \rightarrow z \not\in \texttt{subList [] } ys]$}
                    \proofline{\text{a}1}{z \in ys}{otherwise, it's trivial to prove}
                    \proofline{1}{\texttt{subList [] } ys}{by def. of \texttt{subList}}
                    \proofline{2}{z \not\in \texttt{subList []} ys}{by (1), and def. of \texttt{elem}}
                    \proofis
                    \prooftext{Take arbitrary $v : \texttt{a}$, and $vs : \texttt{[a]}$}
                    \prooftext{Inductive hypothesis: $\forall ys : \texttt{[a]} \forall z : \texttt{a} [z \in ys \rightarrow z \not\in \texttt{subList } vs\ ys]$}
                    \prooftext{To show: $\forall ys : \texttt{[a]} \forall z : \texttt{a} [z \in ys \rightarrow z \not\in \texttt{subList } (v : vs)\ ys]$}
                    \proofline{\text{a}1}{z \in ys}{otherwise, it's trivial to prove}
                    \proofline{0.1}{z \not\in \texttt{subList } vs\ ys}{by (a1), and inductive hypothesis}
                    \proofline{1.0}{v \in ys}{by case}
                    \proofline{1.1}{\texttt{subList } (v : vs)\ ys = \texttt{subList }vs\ ys}{by (1.0), and def. of \texttt{subList}}
                    \proofline{1.2}{z \not\in \texttt{subList } (v : vs)\ ys}{by (0.1), and (1.1)}
                    \proofline{2.0}{v \not\in ys}{by case}
                    \proofline{2.1}{\texttt{subList } (v : vs)\ ys = v : (\texttt{subList }vs\ ys)}{by (2.0), and def. of \texttt{subList}}
                    \proofline{2.2}{z \neq v}{by (a1), and (2.0)}
                    \proofline{2.3}{z \not\in \texttt{subList } (v : vs)\ ys}{by (0.1), (2.2), (2.3), and def. of \texttt{elem}}
                \end{reasoning}
            \subsubsection*{Lemmas for Lists}
                The following lemmas apply for arbitrary \texttt{u:a}, and \texttt{us,vs,ws:[a]}
                \begin{enumerate}[(A)]
                    \item \texttt{us++[] = us}
                    \item \texttt{[]++us = us}
                    \item \texttt{(u:us)++vs = u:(us++vs)}
                    \item \texttt{(us++vs)++ws = us++(vs++ws)}
                \end{enumerate}
                We will be using these lemmas on to prove $\forall xs : \texttt{[a]} \forall ys : \texttt{[a]} [\texttt{rev } (xs ++ ys) = (\texttt{rev } ys) ++ (\texttt{rev } xs)]$, on the following Haskell function;
                \begin{verbatim}
rev :: [a] -> [a]
rev []     = []
rev (x:xs) = (rev xs) ++ [x]\end{verbatim}
                \medskip

                $\phantom{\forall vs : \texttt{[a]} \forall v : \texttt{a}[(} \textcolor{red}{\forall ys : \texttt{[a]} [\texttt{rev } (\texttt{[]} ++ ys) = (\texttt{rev } ys) ++ (\texttt{rev []})]} \land \\ \textcolor{blue}{\forall vs : \texttt{[a]} \forall v : \texttt{a} [(\forall ys : \texttt{[a]} [\texttt{rev } (vs ++ ys) = (\texttt{rev } ys) ++ (\texttt{rev } vs)]) \rightarrow} \\ \phantom{\forall vs : \texttt{[a]} \forall v : \texttt{a}[} \textcolor{blue}{(\forall ys : \texttt{[a]} [\texttt{rev } ((v : vs) ++ ys) = (\texttt{rev } ys) ++ (\texttt{rev } (v : vs))])]} \rightarrow \\ \phantom{\forall v : \texttt{a}(} \textcolor{violet}{\forall xs : \texttt{[a]}[\forall ys : \texttt{[a]} [\texttt{rev } (xs ++ ys) = (\texttt{rev } ys) ++ (\texttt{rev } xs)]]}$ % i should really learn how to align things properly.
                \begin{reasoning}
                    \proofbc
                    \prooftext{Our aim here is to show $\forall ys : \texttt{[a]} [\texttt{rev } (\texttt{[]} ++ ys) = (\texttt{rev } ys) ++ (\texttt{rev []})]$}
                    \proofeq{\texttt{rev }(\texttt{[]} ++ ys)}{\texttt{rev } ys}{by (B)}
                    \proofeq{}{(\texttt{rev } ys) ++ \texttt{[]}}{by (A)}
                    \proofeq{}{(\texttt{rev } ys) ++ (\texttt{rev []})}{by def. of \texttt{rev}}
                    \proofis
                    \prooftext{Take arbitrary $z : \texttt{a}$, and $zs : \texttt{[a]}$}
                    \prooftext{Inductive hypothesis: $\forall ys : \texttt{[a]} [\texttt{rev } (zs ++ ys) = (\texttt{rev } ys) ++ (\texttt{rev } zs)]$}
                    \prooftext{To show: $\forall ys : \texttt{[a]} [\texttt{rev } ((z : zs) ++ ys) = (\texttt{rev } ys) ++ (\texttt{rev } (z : zs))]$}
                    \proofeq{\texttt{rev } ((z : zs) ++ ys)}{\texttt{rev } (z : (zs ++ ys))}{by (C)}
                    \proofeq{}{\texttt{rev } (zs ++ ys) ++ [z]}{by def. of \texttt{rev}}
                    \proofeq{}{((\texttt{rev } ys) ++ (\texttt{rev } zs)) ++ [z]}{by inductive hypothesis}
                    \proofeq{}{(\texttt{rev } ys) ++ ((\texttt{rev } zs) ++ [z])}{by (D)}
                    \proofeq{}{(\texttt{rev } ys) ++ (\texttt{rev } (z : zs))}{by def. of \texttt{rev}}
                \end{reasoning}
                Unlike in induction over natural numbers, each list has an infinite number of successors (for example, both \texttt{3:[]}, and \text{877:[]} are successors of \texttt{[]}), which is why it's important for us to consider arbitrary values. Intuitively, assuming the base case of $P(\texttt{[]})$ holds, we have $P(\texttt{[]}) \rightarrow (P(\texttt{x:[]}) \rightarrow (P(\texttt{y:x:[]}) \rightarrow P(\texttt{z:y:x[]})))$, and so on, hence it holds for all lists.
        \subsection*{Induction over Haskell Data Structures}
            While we can now perform induction over the natural numbers, as well as lists of arbitrary type, we cannot yet perform induction over arbitrary data strucutres, which are recursively defined. Consider the following data structures;
            \begin{itemize}
                \itemsep0em
                \item \texttt{data Nat = Zero | Succ Nat}
                    \subitem $P(\texttt{Zero}) \land \forall n : \texttt{Nat} [P(n) \rightarrow P(\texttt{Succ } n)] \rightarrow \forall n : \texttt{Nat} [P(n)]$
                \item \texttt{data Tree a = Empty | Node (Tree a) a (Tree a)}
                    \subitem $P(\texttt{Empty}) \land \forall t_1, t_2 : \texttt{Tree T} \forall x \texttt{T} [P(t_1) \land P(t_2) \rightarrow P(\texttt{Node }t_1\ x\ t_2)] \rightarrow \forall t : \texttt{Tree T} [P(t)]$
                \item \texttt{data BExp = T | F | BNt BExp | BAnd BExp BExp}
                    \subitem $P(\texttt{T}) \land P(\texttt{F}) \land \forall b : \texttt{BExp} [P(b) \rightarrow P(\texttt{BNt } b)] \land \forall b_1, b_2 : \texttt{BExp} [P(b_1) \land P(b_2) \rightarrow P(\texttt{BAnd } b_1 b_2)] \rightarrow \forall b : \texttt{BExp} [P(b)]$
            \end{itemize}
        \subsection*{Proof Strategies}
            A situation may arise where a statement cannot be proven directly from induction; for example $\forall is \texttt{[Int]} [\texttt{sum } is = \texttt{sum\_tr } is\ 0]$, on the following functions;
            \begin{verbatim}
sum :: [Int] -> Int
sum []     = 0
sum (i:is) = i + sum is

sum_tr :: [Int] -> Int -> Int
sum_tr [] k     = k
sum_tr (i:is) k = sum_tr is (i+k)\end{verbatim}
            \begin{reasoning}
                \proofbc
                \prooftext{This is trivial to prove, also I'm tired}
                \proofis
                \prooftext{Take arbitrary $i : \texttt{Int}$, and $is : \texttt{[Int]}$}
                \prooftext{Inductive hypothesis: $\texttt{sum } is = \texttt{sum\_tr } is\ 0$}
                \prooftext{To show: $\texttt{sum } (i : is) = \texttt{sum\_tr } (i : is)\ 0$}
            \end{reasoning}
\end{document}
