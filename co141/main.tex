\documentclass[a4paper, 12pt]{article}
% packages
\usepackage{amssymb}
\usepackage[fleqn]{mathtools}
\usepackage{tikz}
\usepackage{enumerate}
\usepackage{bussproofs}
\usepackage{xcolor}
\usepackage[margin=1.3cm]{geometry}
\usepackage{logicproof}
\usepackage{diagbox}

% augmented matrix
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
\hskip -\arraycolsep
\let\@ifnextchar\new@ifnextchar
\array{#1}}
\makeatother

% ceiling / floor
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

% custom commands
\newcommand{\indefint}[2]{\int #1 \, \mathrm{d}#2}
\newcommand{\defint}[4]{\int_#1^#2 #3 \, \mathrm{d}#4}
\newcommand{\dif}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}}
\newcommand{\limit}[2]{\displaystyle{\lim_{#1 \to #2}}}
\newcommand{\summation}[3]{\sum\limits_{#1}^#2 #3}
\newcommand{\intbracket}[3]{\left[#3\right]_#1^#2}

\newcommand{\powerset}[0]{\wp}
\renewcommand{\emptyset}[0]{\varnothing}

\newcommand{\unaryproof}[2]{\AxiomC{#1} \UnaryInfC{#2} \DisplayProof}
\newcommand{\binaryproof}[3]{\AxiomC{#1} \AxiomC{#2} \BinaryInfC{#3} \DisplayProof}

% no indent
\setlength\parindent{0pt}

% reasoning proofs
\newcommand{\proofline}[3]{(#1)\ & #2 & \text{#3} \\}
\newcommand{\proofarbitrary}[1]{& \text{take arbitrary } #1 \\}
\allowdisplaybreaks
\setlength{\mathindent}{0pt}

% actual document
\begin{document}
    \setlength{\abovedisplayskip}{2pt}
    \setlength{\belowdisplayskip}{5pt}
    \setlength{\abovedisplayshortskip}{0pt}
    \setlength{\belowdisplayshortskip}{0pt}
    \section*{CO141 - Reasoning About Programs}
        \subsection*{Prelude}
            The content discussed here is part of CO141 - Reasoning About Programs (Computing MEng); taught by Sophia Drossopoulou, and Mark Wheelhouse, in Imperial College London during the academic year 2018/19. The notes are written for my personal use, and have no guarantee of being correct (although I hope it is, for my own sake). This should be used in conjunction with the (extremely detailed) notes.
        \subsection*{Material Order}
            These notes are primarily based off the notes on CATe, as they cover the lecture slides in great detail. This is the order in which they are uploaded (and I'd assume the order in which they are taught).
            \begin{enumerate}[1.]
                \itemsep0em
                \item \textit{Introduction and Motivation (full notes).pdf}
                \item \textit{Stylised Proofs (full notes).pdf}
                \item \textit{Induction over natural numbers (full notes).pdf}
                \item \textit{Induction over Haskell data structures (full notes).pdf}
                \item \textit{Induction over recursive relations and functions (full notes).pdf}
                \item \textit{Java - Program Specifications (full notes).pdf}
                \item \textit{Java - Conditional Branches (full notes).pdf}
                \item \textit{Java - Method Calls (full notes).pdf}
                \item \textit{Java - Recursion (full notes).pdf}
                \item \textit{Java - Iteration Informal (full notes).pdf}
                \item \textit{Java Reasoning - summary.pdf}
                \item \textit{Loop case study.pdf}
                \item \textit{Java - Iteration Formal (full notes).pdf}
                \item \textit{Case Studies - overview (full notes).pdf}
                \item \textit{Case Studies - Dutch Flag Problem (full notes).pdf}
                \item \textit{Quicksort (full notes).pdf}
            \end{enumerate}
        \subsection*{Introduction}
            This module will cover Proof by Induction from first principles, and shows how a recursive definition can implicitly introduce an inductive principle, how the inductive principle introduces a proof schema, and how the schema can be used to prove a property of a inductively defined set, relation or function. This will go into more detail regarding valid uses of quantifiers, when we're able to use the induction hypothesis, how auxiliary lemmas can help, as well as what cases we will need to strengthen properties to prove weaker ones.
        \subsection*{Binding Conventions}
            The binding conventions in this module are the same as the ones used in \textbf{CO140 - Logic}; with the addition of $\forall x$, and $\exists x$ before $\neg$.
        \subsection*{Formalising a Proof}
            For this section, we'll work on one example proof, with the given facts;
            \begin{enumerate}[(1)]
                \itemsep0em
                \item a person is happy if all their children are rich
                \item someone is a supervillain if at least one of their parents is a supervillain
                \item all supervillains are rich
            \end{enumerate}
            We want to show that "all supervillains are happy".
            \subsubsection*{Proof in Natural Language}
                The given argument is that "All of a supervillain's children must therefore also be supervillains; and as all supervillains are rich, all the children of a supervillain are rich. Therefore, any supervillain is happy". However; we've made a few assumptions in this proof - we assume that a supervillain is always a person, and that a supervillain has children (as well as the fact that parent, and child aren't formally defined to be related concepts).
                \medskip

                Therefore, we need to generalise statement (1) OR add an additional assumption (4);
                \begin{enumerate}[(1)]
                    \itemsep0em
                    \item \textbf{someone} is happy if all their children are happy
                    \setcounter{enumi}{3}
                    \item a supervillain is also a person
                \end{enumerate}
            \subsubsection*{Formal Argument}
                \begin{align*}
                    \intertext{Given:}
                    \proofline{1}{\forall x [\text{person}(x) \land \forall y [\text{childof}(y, x) \rightarrow \text{rich}(y)] \rightarrow \text{happy}(x)]}{}
                    \proofline{2}{\forall x [\exists y [\text{childof}(x, y) \land \text{supervillain}(y)] \rightarrow \text{supervillain}(x)]}{}
                    \proofline{3}{\forall x [\text{supervillain}(x) \rightarrow \text{rich}(x)]}{}
                    \proofline{4}{\forall x [\text{supervillain}(x) \rightarrow \text{person}(x)]}{}
                    \intertext{To show:}
                    \proofline{\alpha}{\forall x [\text{supervillain}(x) \rightarrow \text{happy}(x)]}{}
                    \intertext{(Stylised) Proof:}
                    \proofarbitrary{G}
                    \proofline{\text{a}1}{\text{supervillain}(G)}{}
                    \proofline{5}{\text{person}(G) \land \forall y [\text{childof}(y, G) \rightarrow \text{rich}(y)] \rightarrow \text{happy}(G)}{from (1)}
                    \proofline{6}{\text{person}(G)}{from (a1), and (4)}
                    \proofarbitrary{E}
                    \proofline{\text{a}2}{\text{childof}(E, G)}{}
                    \proofline{7}{\text{supervillain}(E)}{from (a1), (a2), and (2)}
                    \proofline{8}{\text{rich}(E)}{from (3), and (7)}
                    \proofline{9}{\forall y [\text{childof}(y, G) \rightarrow \text{rich}(y)]}{from (a2), (8), and arbitrary $E$}
                    \proofline{10}{\text{happy}(G)}{from (5), (6), and (9)}
                    \proofline{\alpha}{}{from (a1), (10), and arbitrary $G$}
                \end{align*}
                While this can be proven fairly easily, and with great confidence, via first-order natural deduction, the proof is often tedious, and the intuition might be lost. On the other hand, stylised proofs have an explicit structure, few errors (compared to free-form) - although errors are still possible.
                \medskip

                Our goal for our proofs are that they should only prove valid statements, are easy to read / check, and are able to highlight intuition behind arguments. The rules for a stylised proof are as follows;
                \begin{enumerate}[1.]
                    \itemsep0em
                    \item write out, and name each given formula
                    \item write out, and name each goal formula
                    \item plan out proof, and name intermediate results
                    \item justify each step
                    \item size of each step can vary as appropriate
                \end{enumerate}
                Planning, and justifying the the steps follow extrmeely similar rules to natural deduction - the rules for proving $P$ are as follows;
                \begin{itemize}
                    \itemsep0em
                    \item $P = Q \land R$ \hfill prove both $Q$, and $R$ ($\land$I)
                    \item $P = Q \lor R$ \hfill prove either $Q$, or $R$ ($\lor$I)
                    \item $P = Q \rightarrow R$ \hfill prove $R$ from assuming $Q$ ($\rightarrow$I)
                    \item $P = \neg Q$ \hfill prove $\bot$ from asuming $Q$ ($\neg$I)
                    \item $P = \forall x [Q(x)]$ \hfill show $Q(c)$ from arbitrary $c$ ($\forall$I)
                    \item $P = \exists x [Q(x)]$ \hfill find some $c$, and show $Q(c)$ ($\exists$I)
                    \item $P$ \hfill prove $\bot$ from assuming $\neg P$ (PC)
                \end{itemize}
                On the other hand, if we have proven $P$, we can do the following;
                \begin{itemize}
                    \itemsep0em
                    \item $P = Q \land R$ \hfill both $Q$, and $R$ hold ($\land$E)
                    \item $P = Q \lor R$ \hfill case analysis ($\lor$I)
                    \item $P = Q \land (Q \rightarrow R)$ \hfill $R$ holds ($\rightarrow$E)
                    \item $P = \forall x [Q(x)]$ \hfill $Q(c)$ holds for any $c$ ($\forall$E)
                    \item $P = \exists x [Q(x)]$ \hfill $Q(c)$ holds for some $c$ ($\exists$E)
                    \item $P = \bot$ \hfill anything holds ($\bot$E)
                    \item $P = \neg Q$ \hfill $Q \rightarrow \bot$ holds ($\neg$E)
                    \item $P$ \hfill use a lemma, or any logical equivalence
                \end{itemize}
            \subsubsection*{Another Example}
                \begin{align*}
                    \intertext{Facts in Natural Language:}
                    \proofline{\text{i}}{\text{a dragon is happy if all of its children can fly}}{}
                    \proofline{\text{ii}}{\text{all green dragons can fly}}{}
                    \proofline{\text{iii}}{\text{something is green if at least one of its parents is green}}{}
                    \proofline{\text{iv}}{\text{all the children of a dragon are also dragons}}{}
                    \proofline{\text{v}}{\text{if $y$ is a child of $x$, then $x$ is a parent of $y$}}{}
                    \intertext{Given:}
                    \proofline{1}{\forall x [\text{dragon}(x) \land \forall y [\text{childof}(x, y) \rightarrow \text{fly}(y)] \rightarrow \text{happy(x)}]}{from (i)}
                    \proofline{2}{\forall x [\text{green}(x) \land \text{dragon}(x) \rightarrow \text{fly}(x)]}{from (ii)}
                    \proofline{3}{\forall x [\exists y [\text{parentof}(y, x) \land \text{green}(y)] \rightarrow \text{green}(y)]}{from (iii)}
                    \proofline{4}{\forall x [\forall y [\text{childof}(x, y) \land \text{dragon}(y) \rightarrow \text{dragon}(x)]]}{from (iv)}
                    \proofline{5}{\forall x [\forall y [\text{childof}(y, x) \rightarrow \text{parentof}(x, y)]]}{from (v)}
                    \intertext{To show:}
                    \proofline{\alpha}{\forall x [\text{dragon}(x) \rightarrow (\text{green}(x) \rightarrow \text{happy}(x))]}{}
                    \proofline{\times}{\forall x [\text{dragon}(x) \land \text{green}(x) \rightarrow \text{happy}(x)]}{(note - equivalent)}
                    \intertext{Proof:}
                    \proofarbitrary{S}
                    \proofline{\text{a}1}{\text{dragon}(S)}{}
                    \proofline{\text{a}2}{\text{green}(S)}{}
                    \proofline{6}{\forall x \forall y [\text{parentof}(y, x) \land \text{green}(y) \rightarrow \text{green}(x)]}{from (3)}
                    \proofline{7}{\forall x \forall y [\text{childof}(x, y) \land \text{green(y)} \rightarrow \text{green}(x)]}{from (5), and (6)}
                    \proofline{8}{\forall x [\text{childof}(x, S) \rightarrow \text{green}(x)]}{from (a2), and (7)}
                    \proofline{9}{\forall x [\text{childof}(x, S) \rightarrow \text{dragon}(x)]}{from (a1), and (4)}
                    \proofline{10}{\forall x [\text{childof}(x, S) \rightarrow \text{green}(x) \land \text{dragon}(x)]}{from (8), and (9)}
                    \proofline{11}{\forall x [\text{childof}(x, S) \rightarrow \text{fly}(x)]}{from (2), and (10)}
                    \proofline{12}{\text{happy}(S)}{from (a1), (1), and (11)}
                    \proofline{\alpha}{}{from (a1), (a2), (12), and arbitrary $S$}
                \end{align*}
                Steps (6), (7), and (10) in particular require more justification; the justification of (7) requires us to prove something else, which can be done trivially with ND. Therefore only (6) will be proven;
                \begin{align*}
                    \intertext{Given:}
                    \proofline{1}{\forall x [\exists y [P(x, y)] \rightarrow Q(x)]}{}
                    \intertext{To show:}
                    \proofline{\alpha}{\forall x \forall y [P(x, y) \rightarrow Q(x)]}{}
                    \intertext{Proof:}
                    \proofarbitrary{c_1}
                    \proofarbitrary{c_2}
                    \proofline{\text{a}1}{P(c_1, c_2)}{}
                    \proofline{2}{\exists y [P(c_1, y)] \rightarrow Q(c_1)}{from (1), where $x = c_1$}
                    \proofline{3}{\exists y [P(c_1, y)]}{from (a1), where $c_2 = y$}
                    \proofline{4}{Q(c_1)}{from (2), and (3)}
                    \proofline{\alpha}{}{from (a1), (4), and arbitrary $c_1$, $c_2$}
                \end{align*}
                Note that (7) requires us to prove $\forall u \forall v [R(v, y) \rightarrow Q(u, v)] \land \forall w \forall z [Q(z, w) \land S(z) \rightarrow S(w)] \rightarrow \forall x \forall y [R(x, y) \land S(y)\rightarrow S(x)]$, which isn't actually as difficult as it looks (only 16 lines in steps in ND). On the other hand, the proof for (10) requires $(A \rightarrow B) \land (A \rightarrow C) \rightarrow (A \rightarrow B \land C)$ - assume $A$, and you get both $B$, and $C$ very quickly.
        \subsection*{Induction over Natural Numbers}
\end{document}
