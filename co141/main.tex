\documentclass[a4paper, 12pt]{article}
% packages
\usepackage{amssymb}
\usepackage[fleqn]{mathtools}
\usepackage{tikz}
\usepackage{enumerate}
\usepackage{bussproofs}
\usepackage{xcolor}
\usepackage[margin=1.3cm]{geometry}
\usepackage{logicproof}
\usepackage{diagbox}

% augmented matrix
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
\hskip -\arraycolsep
\let\@ifnextchar\new@ifnextchar
\array{#1}}
\makeatother

% ceiling / floor
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

% custom commands
\newcommand{\indefint}[2]{\int #1 \, \mathrm{d}#2}
\newcommand{\defint}[4]{\int_#1^#2 #3 \, \mathrm{d}#4}
\newcommand{\dif}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}}
\newcommand{\limit}[2]{\displaystyle{\lim_{#1 \to #2}}}
\newcommand{\summation}[3]{\sum\limits_{#1}^#2 #3}
\newcommand{\intbracket}[3]{\left[#3\right]_#1^#2}

\newcommand{\powerset}[0]{\wp}
\renewcommand{\emptyset}[0]{\varnothing}

\newcommand{\unaryproof}[2]{\AxiomC{#1} \UnaryInfC{#2} \DisplayProof}
\newcommand{\binaryproof}[3]{\AxiomC{#1} \AxiomC{#2} \BinaryInfC{#3} \DisplayProof}

% no indent
\setlength\parindent{0pt}

% reasoning proofs
\newcommand{\proofline}[3]{(#1)\ & #2 & \text{#3} \\}
\allowdisplaybreaks

% actual document
\begin{document}
    \section*{CO141 - Reasoning About Programs}
        \subsection*{Prelude}
            The content discussed here is part of CO141 - Reasoning About Programs (Computing MEng); taught by Sophia Drossopoulou, and Mark Wheelhouse, in Imperial College London during the academic year 2018/19. The notes are written for my personal use, and have no guarantee of being correct (although I hope it is, for my own sake). This should be used in conjunction with the (extremely detailed) notes.
        \subsection*{Material Order}
            These notes are primarily based off the notes on CATe, as they cover the lecture slides in great detail. This is the order in which they are uploaded (and I'd assume the order in which they are taught).
            \begin{enumerate}[1.]
                \itemsep0em
                \item \textit{Introduction and Motivation (full notes).pdf}
                \item \textit{Stylised Proofs (full notes).pdf}
                \item \textit{Induction over natural numbers (full notes).pdf}
                \item \textit{Induction over Haskell data structures (full notes).pdf}
                \item \textit{Induction over recursive relations and functions (full notes).pdf}
                \item \textit{Java - Program Specifications (full notes).pdf}
                \item \textit{Java - Conditional Branches (full notes).pdf}
                \item \textit{Java - Method Calls (full notes).pdf}
                \item \textit{Java - Recursion (full notes).pdf}
                \item \textit{Java - Iteration Informal (full notes).pdf}
                \item \textit{Java Reasoning - summary.pdf}
                \item \textit{Loop case study.pdf}
                \item \textit{Java - Iteration Formal (full notes).pdf}
                \item \textit{Case Studies - overview (full notes).pdf}
                \item \textit{Case Studies - Dutch Flag Problem (full notes).pdf}
                \item \textit{Quicksort (full notes).pdf}
            \end{enumerate}
        \subsection*{Introduction}
            This module will cover Proof by Induction from first principles, and shows how a recursive definition can implicitly introduce an inductive principle, how the inductive principle introduces a proof schema, and how the schema can be used to prove a property of a inductively defined set, relation or function. This will go into more detail regarding valid uses of quantifiers, when we're able to use the induction hypothesis, how auxiliary lemmas can help, as well as what cases we will need to strengthen properties to prove weaker ones.
        \subsection*{Binding Conventions}
            The binding conventions in this module are the same as the ones used in \textbf{CO140 - Logic}; with the addition of $\forall x$, and $\exists x$ before $\neg$.
        \subsection*{Formalising a Proof}
            For this section, we'll work on one example proof, with the given facts;
            \begin{enumerate}[(1)]
                \itemsep0em
                \item a person is happy if all their children are rich
                \item someone is a supervillain if at least one of their parents is a supervillain
                \item all supervillains are rich
            \end{enumerate}
            We want to show that "all supervillains are happy".
            \subsubsection*{Proof in Natural Language}
                The given argument is that "All of a supervillain's children must therefore also be supervillains; and as all supervillains are rich, all the children of a supervillain are rich. Therefore, any supervillain is happy". However; we've made a few assumptions in this proof - we assume that a supervillain is always a person, and that a supervillain has children (as well as the fact that parent, and child aren't formally defined to be related concepts).
                \medskip

                Therefore, we need to generalise statement (1) OR add an additional assumption (4);
                \begin{enumerate}[(1)]
                    \itemsep0em
                    \item \textbf{someone} is happy if all their children are happy
                    \setcounter{enumi}{3}
                    \item a supervillain is also a person
                \end{enumerate}
            \subsubsection*{Formal Argument}
            \vspace{-\baselineskip}
            \begin{align*}
                \intertext{Given:}
                \proofline{1}{\forall x [\text{person}(x) \land \forall y [\text{childof}(y, x) \rightarrow \text{rich}(y)] \rightarrow \text{happy}(x)]}{}
                \proofline{2}{\forall x [\exists y [\text{childof}(x, y) \land \text{supervillain}(y)] \rightarrow \text{supervillain}(x)]}{}
                \proofline{3}{\forall x [\text{supervillain}(x) \rightarrow \text{rich}(x)]}{}
                \proofline{4}{\forall x [\text{supervillain}(x) \rightarrow \text{person}(x)]}{}
                \intertext{To show:}
                \proofline{\alpha}{\forall x [\text{supervillain}(x) \rightarrow \text{happy}(x)]}{}
            \end{align*}
            While this can be proven fairly easily, and with great confidence, via first-order natural deduction, the proof is often tedious.
\end{document}
